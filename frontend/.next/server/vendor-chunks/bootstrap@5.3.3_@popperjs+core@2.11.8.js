"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/bootstrap@5.3.3_@popperjs+core@2.11.8";
exports.ids = ["vendor-chunks/bootstrap@5.3.3_@popperjs+core@2.11.8"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/bootstrap@5.3.3_@popperjs+core@2.11.8/node_modules/bootstrap/dist/js/bootstrap.bundle.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/bootstrap@5.3.3_@popperjs+core@2.11.8/node_modules/bootstrap/dist/js/bootstrap.bundle.js ***!
  \*********************************************************************************************************************/
/***/ ((module) => {

eval("\n/*!\n  * Bootstrap v5.3.3 (https://getbootstrap.com/)\n  * Copyright 2011-2024 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)\n  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n  */ (function(global, factory) {\n     true ? module.exports = factory() : 0;\n})(void 0, function() {\n    \"use strict\";\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap dom/data.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const elementMap = new Map();\n    const Data = {\n        set (element, key, instance) {\n            if (!elementMap.has(element)) {\n                elementMap.set(element, new Map());\n            }\n            const instanceMap = elementMap.get(element);\n            // make it clear we only want one instance per element\n            // can be removed later when multiple key/instances are fine to be used\n            if (!instanceMap.has(key) && instanceMap.size !== 0) {\n                // eslint-disable-next-line no-console\n                console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`);\n                return;\n            }\n            instanceMap.set(key, instance);\n        },\n        get (element, key) {\n            if (elementMap.has(element)) {\n                return elementMap.get(element).get(key) || null;\n            }\n            return null;\n        },\n        remove (element, key) {\n            if (!elementMap.has(element)) {\n                return;\n            }\n            const instanceMap = elementMap.get(element);\n            instanceMap.delete(key);\n            // free up element references if there are no instances left for an element\n            if (instanceMap.size === 0) {\n                elementMap.delete(element);\n            }\n        }\n    };\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap util/index.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ const MAX_UID = 1000000;\n    const MILLISECONDS_MULTIPLIER = 1000;\n    const TRANSITION_END = \"transitionend\";\n    /**\n   * Properly escape IDs selectors to handle weird IDs\n   * @param {string} selector\n   * @returns {string}\n   */ const parseSelector = (selector)=>{\n        if (selector && window.CSS && window.CSS.escape) {\n            // document.querySelector needs escaping to handle IDs (html5+) containing for instance /\n            selector = selector.replace(/#([^\\s\"#']+)/g, (match, id)=>`#${CSS.escape(id)}`);\n        }\n        return selector;\n    };\n    // Shout-out Angus Croll (https://goo.gl/pxwQGp)\n    const toType = (object)=>{\n        if (object === null || object === undefined) {\n            return `${object}`;\n        }\n        return Object.prototype.toString.call(object).match(/\\s([a-z]+)/i)[1].toLowerCase();\n    };\n    /**\n   * Public Util API\n   */ const getUID = (prefix)=>{\n        do {\n            prefix += Math.floor(Math.random() * MAX_UID);\n        }while (document.getElementById(prefix));\n        return prefix;\n    };\n    const getTransitionDurationFromElement = (element)=>{\n        if (!element) {\n            return 0;\n        }\n        // Get transition-duration of the element\n        let { transitionDuration, transitionDelay } = window.getComputedStyle(element);\n        const floatTransitionDuration = Number.parseFloat(transitionDuration);\n        const floatTransitionDelay = Number.parseFloat(transitionDelay);\n        // Return 0 if element or transition duration is not found\n        if (!floatTransitionDuration && !floatTransitionDelay) {\n            return 0;\n        }\n        // If multiple durations are defined, take the first\n        transitionDuration = transitionDuration.split(\",\")[0];\n        transitionDelay = transitionDelay.split(\",\")[0];\n        return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;\n    };\n    const triggerTransitionEnd = (element)=>{\n        element.dispatchEvent(new Event(TRANSITION_END));\n    };\n    const isElement$1 = (object)=>{\n        if (!object || typeof object !== \"object\") {\n            return false;\n        }\n        if (typeof object.jquery !== \"undefined\") {\n            object = object[0];\n        }\n        return typeof object.nodeType !== \"undefined\";\n    };\n    const getElement = (object)=>{\n        // it's a jQuery object or a node element\n        if (isElement$1(object)) {\n            return object.jquery ? object[0] : object;\n        }\n        if (typeof object === \"string\" && object.length > 0) {\n            return document.querySelector(parseSelector(object));\n        }\n        return null;\n    };\n    const isVisible = (element)=>{\n        if (!isElement$1(element) || element.getClientRects().length === 0) {\n            return false;\n        }\n        const elementIsVisible = getComputedStyle(element).getPropertyValue(\"visibility\") === \"visible\";\n        // Handle `details` element as its content may falsie appear visible when it is closed\n        const closedDetails = element.closest(\"details:not([open])\");\n        if (!closedDetails) {\n            return elementIsVisible;\n        }\n        if (closedDetails !== element) {\n            const summary = element.closest(\"summary\");\n            if (summary && summary.parentNode !== closedDetails) {\n                return false;\n            }\n            if (summary === null) {\n                return false;\n            }\n        }\n        return elementIsVisible;\n    };\n    const isDisabled = (element)=>{\n        if (!element || element.nodeType !== Node.ELEMENT_NODE) {\n            return true;\n        }\n        if (element.classList.contains(\"disabled\")) {\n            return true;\n        }\n        if (typeof element.disabled !== \"undefined\") {\n            return element.disabled;\n        }\n        return element.hasAttribute(\"disabled\") && element.getAttribute(\"disabled\") !== \"false\";\n    };\n    const findShadowRoot = (element)=>{\n        if (!document.documentElement.attachShadow) {\n            return null;\n        }\n        // Can find the shadow root otherwise it'll return the document\n        if (typeof element.getRootNode === \"function\") {\n            const root = element.getRootNode();\n            return root instanceof ShadowRoot ? root : null;\n        }\n        if (element instanceof ShadowRoot) {\n            return element;\n        }\n        // when we don't find a shadow root\n        if (!element.parentNode) {\n            return null;\n        }\n        return findShadowRoot(element.parentNode);\n    };\n    const noop = ()=>{};\n    /**\n   * Trick to restart an element's animation\n   *\n   * @param {HTMLElement} element\n   * @return void\n   *\n   * @see https://www.charistheo.io/blog/2021/02/restart-a-css-animation-with-javascript/#restarting-a-css-animation\n   */ const reflow = (element)=>{\n        element.offsetHeight; // eslint-disable-line no-unused-expressions\n    };\n    const getjQuery = ()=>{\n        if (window.jQuery && !document.body.hasAttribute(\"data-bs-no-jquery\")) {\n            return window.jQuery;\n        }\n        return null;\n    };\n    const DOMContentLoadedCallbacks = [];\n    const onDOMContentLoaded = (callback)=>{\n        if (document.readyState === \"loading\") {\n            // add listener on the first call when the document is in loading state\n            if (!DOMContentLoadedCallbacks.length) {\n                document.addEventListener(\"DOMContentLoaded\", ()=>{\n                    for (const callback of DOMContentLoadedCallbacks){\n                        callback();\n                    }\n                });\n            }\n            DOMContentLoadedCallbacks.push(callback);\n        } else {\n            callback();\n        }\n    };\n    const isRTL = ()=>document.documentElement.dir === \"rtl\";\n    const defineJQueryPlugin = (plugin)=>{\n        onDOMContentLoaded(()=>{\n            const $ = getjQuery();\n            /* istanbul ignore if */ if ($) {\n                const name = plugin.NAME;\n                const JQUERY_NO_CONFLICT = $.fn[name];\n                $.fn[name] = plugin.jQueryInterface;\n                $.fn[name].Constructor = plugin;\n                $.fn[name].noConflict = ()=>{\n                    $.fn[name] = JQUERY_NO_CONFLICT;\n                    return plugin.jQueryInterface;\n                };\n            }\n        });\n    };\n    const execute = (possibleCallback, args = [], defaultValue = possibleCallback)=>{\n        return typeof possibleCallback === \"function\" ? possibleCallback(...args) : defaultValue;\n    };\n    const executeAfterTransition = (callback, transitionElement, waitForTransition = true)=>{\n        if (!waitForTransition) {\n            execute(callback);\n            return;\n        }\n        const durationPadding = 5;\n        const emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;\n        let called = false;\n        const handler = ({ target })=>{\n            if (target !== transitionElement) {\n                return;\n            }\n            called = true;\n            transitionElement.removeEventListener(TRANSITION_END, handler);\n            execute(callback);\n        };\n        transitionElement.addEventListener(TRANSITION_END, handler);\n        setTimeout(()=>{\n            if (!called) {\n                triggerTransitionEnd(transitionElement);\n            }\n        }, emulatedDuration);\n    };\n    /**\n   * Return the previous/next element of a list.\n   *\n   * @param {array} list    The list of elements\n   * @param activeElement   The active element\n   * @param shouldGetNext   Choose to get next or previous element\n   * @param isCycleAllowed\n   * @return {Element|elem} The proper element\n   */ const getNextActiveElement = (list, activeElement, shouldGetNext, isCycleAllowed)=>{\n        const listLength = list.length;\n        let index = list.indexOf(activeElement);\n        // if the element does not exist in the list return an element\n        // depending on the direction and if cycle is allowed\n        if (index === -1) {\n            return !shouldGetNext && isCycleAllowed ? list[listLength - 1] : list[0];\n        }\n        index += shouldGetNext ? 1 : -1;\n        if (isCycleAllowed) {\n            index = (index + listLength) % listLength;\n        }\n        return list[Math.max(0, Math.min(index, listLength - 1))];\n    };\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap dom/event-handler.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const namespaceRegex = /[^.]*(?=\\..*)\\.|.*/;\n    const stripNameRegex = /\\..*/;\n    const stripUidRegex = /::\\d+$/;\n    const eventRegistry = {}; // Events storage\n    let uidEvent = 1;\n    const customEvents = {\n        mouseenter: \"mouseover\",\n        mouseleave: \"mouseout\"\n    };\n    const nativeEvents = new Set([\n        \"click\",\n        \"dblclick\",\n        \"mouseup\",\n        \"mousedown\",\n        \"contextmenu\",\n        \"mousewheel\",\n        \"DOMMouseScroll\",\n        \"mouseover\",\n        \"mouseout\",\n        \"mousemove\",\n        \"selectstart\",\n        \"selectend\",\n        \"keydown\",\n        \"keypress\",\n        \"keyup\",\n        \"orientationchange\",\n        \"touchstart\",\n        \"touchmove\",\n        \"touchend\",\n        \"touchcancel\",\n        \"pointerdown\",\n        \"pointermove\",\n        \"pointerup\",\n        \"pointerleave\",\n        \"pointercancel\",\n        \"gesturestart\",\n        \"gesturechange\",\n        \"gestureend\",\n        \"focus\",\n        \"blur\",\n        \"change\",\n        \"reset\",\n        \"select\",\n        \"submit\",\n        \"focusin\",\n        \"focusout\",\n        \"load\",\n        \"unload\",\n        \"beforeunload\",\n        \"resize\",\n        \"move\",\n        \"DOMContentLoaded\",\n        \"readystatechange\",\n        \"error\",\n        \"abort\",\n        \"scroll\"\n    ]);\n    /**\n   * Private methods\n   */ function makeEventUid(element, uid) {\n        return uid && `${uid}::${uidEvent++}` || element.uidEvent || uidEvent++;\n    }\n    function getElementEvents(element) {\n        const uid = makeEventUid(element);\n        element.uidEvent = uid;\n        eventRegistry[uid] = eventRegistry[uid] || {};\n        return eventRegistry[uid];\n    }\n    function bootstrapHandler(element, fn) {\n        return function handler(event) {\n            hydrateObj(event, {\n                delegateTarget: element\n            });\n            if (handler.oneOff) {\n                EventHandler.off(element, event.type, fn);\n            }\n            return fn.apply(element, [\n                event\n            ]);\n        };\n    }\n    function bootstrapDelegationHandler(element, selector, fn) {\n        return function handler(event) {\n            const domElements = element.querySelectorAll(selector);\n            for(let { target } = event; target && target !== this; target = target.parentNode){\n                for (const domElement of domElements){\n                    if (domElement !== target) {\n                        continue;\n                    }\n                    hydrateObj(event, {\n                        delegateTarget: target\n                    });\n                    if (handler.oneOff) {\n                        EventHandler.off(element, event.type, selector, fn);\n                    }\n                    return fn.apply(target, [\n                        event\n                    ]);\n                }\n            }\n        };\n    }\n    function findHandler(events, callable, delegationSelector = null) {\n        return Object.values(events).find((event)=>event.callable === callable && event.delegationSelector === delegationSelector);\n    }\n    function normalizeParameters(originalTypeEvent, handler, delegationFunction) {\n        const isDelegated = typeof handler === \"string\";\n        // TODO: tooltip passes `false` instead of selector, so we need to check\n        const callable = isDelegated ? delegationFunction : handler || delegationFunction;\n        let typeEvent = getTypeEvent(originalTypeEvent);\n        if (!nativeEvents.has(typeEvent)) {\n            typeEvent = originalTypeEvent;\n        }\n        return [\n            isDelegated,\n            callable,\n            typeEvent\n        ];\n    }\n    function addHandler(element, originalTypeEvent, handler, delegationFunction, oneOff) {\n        if (typeof originalTypeEvent !== \"string\" || !element) {\n            return;\n        }\n        let [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);\n        // in case of mouseenter or mouseleave wrap the handler within a function that checks for its DOM position\n        // this prevents the handler from being dispatched the same way as mouseover or mouseout does\n        if (originalTypeEvent in customEvents) {\n            const wrapFunction = (fn)=>{\n                return function(event) {\n                    if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {\n                        return fn.call(this, event);\n                    }\n                };\n            };\n            callable = wrapFunction(callable);\n        }\n        const events = getElementEvents(element);\n        const handlers = events[typeEvent] || (events[typeEvent] = {});\n        const previousFunction = findHandler(handlers, callable, isDelegated ? handler : null);\n        if (previousFunction) {\n            previousFunction.oneOff = previousFunction.oneOff && oneOff;\n            return;\n        }\n        const uid = makeEventUid(callable, originalTypeEvent.replace(namespaceRegex, \"\"));\n        const fn = isDelegated ? bootstrapDelegationHandler(element, handler, callable) : bootstrapHandler(element, callable);\n        fn.delegationSelector = isDelegated ? handler : null;\n        fn.callable = callable;\n        fn.oneOff = oneOff;\n        fn.uidEvent = uid;\n        handlers[uid] = fn;\n        element.addEventListener(typeEvent, fn, isDelegated);\n    }\n    function removeHandler(element, events, typeEvent, handler, delegationSelector) {\n        const fn = findHandler(events[typeEvent], handler, delegationSelector);\n        if (!fn) {\n            return;\n        }\n        element.removeEventListener(typeEvent, fn, Boolean(delegationSelector));\n        delete events[typeEvent][fn.uidEvent];\n    }\n    function removeNamespacedHandlers(element, events, typeEvent, namespace) {\n        const storeElementEvent = events[typeEvent] || {};\n        for (const [handlerKey, event] of Object.entries(storeElementEvent)){\n            if (handlerKey.includes(namespace)) {\n                removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);\n            }\n        }\n    }\n    function getTypeEvent(event) {\n        // allow to get the native events from namespaced events ('click.bs.button' --> 'click')\n        event = event.replace(stripNameRegex, \"\");\n        return customEvents[event] || event;\n    }\n    const EventHandler = {\n        on (element, event, handler, delegationFunction) {\n            addHandler(element, event, handler, delegationFunction, false);\n        },\n        one (element, event, handler, delegationFunction) {\n            addHandler(element, event, handler, delegationFunction, true);\n        },\n        off (element, originalTypeEvent, handler, delegationFunction) {\n            if (typeof originalTypeEvent !== \"string\" || !element) {\n                return;\n            }\n            const [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);\n            const inNamespace = typeEvent !== originalTypeEvent;\n            const events = getElementEvents(element);\n            const storeElementEvent = events[typeEvent] || {};\n            const isNamespace = originalTypeEvent.startsWith(\".\");\n            if (typeof callable !== \"undefined\") {\n                // Simplest case: handler is passed, remove that listener ONLY.\n                if (!Object.keys(storeElementEvent).length) {\n                    return;\n                }\n                removeHandler(element, events, typeEvent, callable, isDelegated ? handler : null);\n                return;\n            }\n            if (isNamespace) {\n                for (const elementEvent of Object.keys(events)){\n                    removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));\n                }\n            }\n            for (const [keyHandlers, event] of Object.entries(storeElementEvent)){\n                const handlerKey = keyHandlers.replace(stripUidRegex, \"\");\n                if (!inNamespace || originalTypeEvent.includes(handlerKey)) {\n                    removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);\n                }\n            }\n        },\n        trigger (element, event, args) {\n            if (typeof event !== \"string\" || !element) {\n                return null;\n            }\n            const $ = getjQuery();\n            const typeEvent = getTypeEvent(event);\n            const inNamespace = event !== typeEvent;\n            let jQueryEvent = null;\n            let bubbles = true;\n            let nativeDispatch = true;\n            let defaultPrevented = false;\n            if (inNamespace && $) {\n                jQueryEvent = $.Event(event, args);\n                $(element).trigger(jQueryEvent);\n                bubbles = !jQueryEvent.isPropagationStopped();\n                nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();\n                defaultPrevented = jQueryEvent.isDefaultPrevented();\n            }\n            const evt = hydrateObj(new Event(event, {\n                bubbles,\n                cancelable: true\n            }), args);\n            if (defaultPrevented) {\n                evt.preventDefault();\n            }\n            if (nativeDispatch) {\n                element.dispatchEvent(evt);\n            }\n            if (evt.defaultPrevented && jQueryEvent) {\n                jQueryEvent.preventDefault();\n            }\n            return evt;\n        }\n    };\n    function hydrateObj(obj, meta = {}) {\n        for (const [key, value] of Object.entries(meta)){\n            try {\n                obj[key] = value;\n            } catch (_unused) {\n                Object.defineProperty(obj, key, {\n                    configurable: true,\n                    get () {\n                        return value;\n                    }\n                });\n            }\n        }\n        return obj;\n    }\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap dom/manipulator.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ function normalizeData(value) {\n        if (value === \"true\") {\n            return true;\n        }\n        if (value === \"false\") {\n            return false;\n        }\n        if (value === Number(value).toString()) {\n            return Number(value);\n        }\n        if (value === \"\" || value === \"null\") {\n            return null;\n        }\n        if (typeof value !== \"string\") {\n            return value;\n        }\n        try {\n            return JSON.parse(decodeURIComponent(value));\n        } catch (_unused) {\n            return value;\n        }\n    }\n    function normalizeDataKey(key) {\n        return key.replace(/[A-Z]/g, (chr)=>`-${chr.toLowerCase()}`);\n    }\n    const Manipulator = {\n        setDataAttribute (element, key, value) {\n            element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value);\n        },\n        removeDataAttribute (element, key) {\n            element.removeAttribute(`data-bs-${normalizeDataKey(key)}`);\n        },\n        getDataAttributes (element) {\n            if (!element) {\n                return {};\n            }\n            const attributes = {};\n            const bsKeys = Object.keys(element.dataset).filter((key)=>key.startsWith(\"bs\") && !key.startsWith(\"bsConfig\"));\n            for (const key of bsKeys){\n                let pureKey = key.replace(/^bs/, \"\");\n                pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1, pureKey.length);\n                attributes[pureKey] = normalizeData(element.dataset[key]);\n            }\n            return attributes;\n        },\n        getDataAttribute (element, key) {\n            return normalizeData(element.getAttribute(`data-bs-${normalizeDataKey(key)}`));\n        }\n    };\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap util/config.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Class definition\n   */ class Config {\n        // Getters\n        static get Default() {\n            return {};\n        }\n        static get DefaultType() {\n            return {};\n        }\n        static get NAME() {\n            throw new Error('You have to implement the static method \"NAME\", for each component!');\n        }\n        _getConfig(config) {\n            config = this._mergeConfigObj(config);\n            config = this._configAfterMerge(config);\n            this._typeCheckConfig(config);\n            return config;\n        }\n        _configAfterMerge(config) {\n            return config;\n        }\n        _mergeConfigObj(config, element) {\n            const jsonConfig = isElement$1(element) ? Manipulator.getDataAttribute(element, \"config\") : {}; // try to parse\n            return {\n                ...this.constructor.Default,\n                ...typeof jsonConfig === \"object\" ? jsonConfig : {},\n                ...isElement$1(element) ? Manipulator.getDataAttributes(element) : {},\n                ...typeof config === \"object\" ? config : {}\n            };\n        }\n        _typeCheckConfig(config, configTypes = this.constructor.DefaultType) {\n            for (const [property, expectedTypes] of Object.entries(configTypes)){\n                const value = config[property];\n                const valueType = isElement$1(value) ? \"element\" : toType(value);\n                if (!new RegExp(expectedTypes).test(valueType)) {\n                    throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option \"${property}\" provided type \"${valueType}\" but expected type \"${expectedTypes}\".`);\n                }\n            }\n        }\n    }\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap base-component.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const VERSION = \"5.3.3\";\n    /**\n   * Class definition\n   */ class BaseComponent extends Config {\n        constructor(element, config){\n            super();\n            element = getElement(element);\n            if (!element) {\n                return;\n            }\n            this._element = element;\n            this._config = this._getConfig(config);\n            Data.set(this._element, this.constructor.DATA_KEY, this);\n        }\n        // Public\n        dispose() {\n            Data.remove(this._element, this.constructor.DATA_KEY);\n            EventHandler.off(this._element, this.constructor.EVENT_KEY);\n            for (const propertyName of Object.getOwnPropertyNames(this)){\n                this[propertyName] = null;\n            }\n        }\n        _queueCallback(callback, element, isAnimated = true) {\n            executeAfterTransition(callback, element, isAnimated);\n        }\n        _getConfig(config) {\n            config = this._mergeConfigObj(config, this._element);\n            config = this._configAfterMerge(config);\n            this._typeCheckConfig(config);\n            return config;\n        }\n        // Static\n        static getInstance(element) {\n            return Data.get(getElement(element), this.DATA_KEY);\n        }\n        static getOrCreateInstance(element, config = {}) {\n            return this.getInstance(element) || new this(element, typeof config === \"object\" ? config : null);\n        }\n        static get VERSION() {\n            return VERSION;\n        }\n        static get DATA_KEY() {\n            return `bs.${this.NAME}`;\n        }\n        static get EVENT_KEY() {\n            return `.${this.DATA_KEY}`;\n        }\n        static eventName(name) {\n            return `${name}${this.EVENT_KEY}`;\n        }\n    }\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap dom/selector-engine.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ const getSelector = (element)=>{\n        let selector = element.getAttribute(\"data-bs-target\");\n        if (!selector || selector === \"#\") {\n            let hrefAttribute = element.getAttribute(\"href\");\n            // The only valid content that could double as a selector are IDs or classes,\n            // so everything starting with `#` or `.`. If a \"real\" URL is used as the selector,\n            // `document.querySelector` will rightfully complain it is invalid.\n            // See https://github.com/twbs/bootstrap/issues/32273\n            if (!hrefAttribute || !hrefAttribute.includes(\"#\") && !hrefAttribute.startsWith(\".\")) {\n                return null;\n            }\n            // Just in case some CMS puts out a full URL with the anchor appended\n            if (hrefAttribute.includes(\"#\") && !hrefAttribute.startsWith(\"#\")) {\n                hrefAttribute = `#${hrefAttribute.split(\"#\")[1]}`;\n            }\n            selector = hrefAttribute && hrefAttribute !== \"#\" ? hrefAttribute.trim() : null;\n        }\n        return selector ? selector.split(\",\").map((sel)=>parseSelector(sel)).join(\",\") : null;\n    };\n    const SelectorEngine = {\n        find (selector, element = document.documentElement) {\n            return [].concat(...Element.prototype.querySelectorAll.call(element, selector));\n        },\n        findOne (selector, element = document.documentElement) {\n            return Element.prototype.querySelector.call(element, selector);\n        },\n        children (element, selector) {\n            return [].concat(...element.children).filter((child)=>child.matches(selector));\n        },\n        parents (element, selector) {\n            const parents = [];\n            let ancestor = element.parentNode.closest(selector);\n            while(ancestor){\n                parents.push(ancestor);\n                ancestor = ancestor.parentNode.closest(selector);\n            }\n            return parents;\n        },\n        prev (element, selector) {\n            let previous = element.previousElementSibling;\n            while(previous){\n                if (previous.matches(selector)) {\n                    return [\n                        previous\n                    ];\n                }\n                previous = previous.previousElementSibling;\n            }\n            return [];\n        },\n        // TODO: this is now unused; remove later along with prev()\n        next (element, selector) {\n            let next = element.nextElementSibling;\n            while(next){\n                if (next.matches(selector)) {\n                    return [\n                        next\n                    ];\n                }\n                next = next.nextElementSibling;\n            }\n            return [];\n        },\n        focusableChildren (element) {\n            const focusables = [\n                \"a\",\n                \"button\",\n                \"input\",\n                \"textarea\",\n                \"select\",\n                \"details\",\n                \"[tabindex]\",\n                '[contenteditable=\"true\"]'\n            ].map((selector)=>`${selector}:not([tabindex^=\"-\"])`).join(\",\");\n            return this.find(focusables, element).filter((el)=>!isDisabled(el) && isVisible(el));\n        },\n        getSelectorFromElement (element) {\n            const selector = getSelector(element);\n            if (selector) {\n                return SelectorEngine.findOne(selector) ? selector : null;\n            }\n            return null;\n        },\n        getElementFromSelector (element) {\n            const selector = getSelector(element);\n            return selector ? SelectorEngine.findOne(selector) : null;\n        },\n        getMultipleElementsFromSelector (element) {\n            const selector = getSelector(element);\n            return selector ? SelectorEngine.find(selector) : [];\n        }\n    };\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap util/component-functions.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ const enableDismissTrigger = (component, method = \"hide\")=>{\n        const clickEvent = `click.dismiss${component.EVENT_KEY}`;\n        const name = component.NAME;\n        EventHandler.on(document, clickEvent, `[data-bs-dismiss=\"${name}\"]`, function(event) {\n            if ([\n                \"A\",\n                \"AREA\"\n            ].includes(this.tagName)) {\n                event.preventDefault();\n            }\n            if (isDisabled(this)) {\n                return;\n            }\n            const target = SelectorEngine.getElementFromSelector(this) || this.closest(`.${name}`);\n            const instance = component.getOrCreateInstance(target);\n            // Method argument is left, for Alert and only, as it doesn't implement the 'hide' method\n            instance[method]();\n        });\n    };\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap alert.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$f = \"alert\";\n    const DATA_KEY$a = \"bs.alert\";\n    const EVENT_KEY$b = `.${DATA_KEY$a}`;\n    const EVENT_CLOSE = `close${EVENT_KEY$b}`;\n    const EVENT_CLOSED = `closed${EVENT_KEY$b}`;\n    const CLASS_NAME_FADE$5 = \"fade\";\n    const CLASS_NAME_SHOW$8 = \"show\";\n    /**\n   * Class definition\n   */ class Alert extends BaseComponent {\n        // Getters\n        static get NAME() {\n            return NAME$f;\n        }\n        // Public\n        close() {\n            const closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);\n            if (closeEvent.defaultPrevented) {\n                return;\n            }\n            this._element.classList.remove(CLASS_NAME_SHOW$8);\n            const isAnimated = this._element.classList.contains(CLASS_NAME_FADE$5);\n            this._queueCallback(()=>this._destroyElement(), this._element, isAnimated);\n        }\n        // Private\n        _destroyElement() {\n            this._element.remove();\n            EventHandler.trigger(this._element, EVENT_CLOSED);\n            this.dispose();\n        }\n        // Static\n        static jQueryInterface(config) {\n            return this.each(function() {\n                const data = Alert.getOrCreateInstance(this);\n                if (typeof config !== \"string\") {\n                    return;\n                }\n                if (data[config] === undefined || config.startsWith(\"_\") || config === \"constructor\") {\n                    throw new TypeError(`No method named \"${config}\"`);\n                }\n                data[config](this);\n            });\n        }\n    }\n    /**\n   * Data API implementation\n   */ enableDismissTrigger(Alert, \"close\");\n    /**\n   * jQuery\n   */ defineJQueryPlugin(Alert);\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap button.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$e = \"button\";\n    const DATA_KEY$9 = \"bs.button\";\n    const EVENT_KEY$a = `.${DATA_KEY$9}`;\n    const DATA_API_KEY$6 = \".data-api\";\n    const CLASS_NAME_ACTIVE$3 = \"active\";\n    const SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle=\"button\"]';\n    const EVENT_CLICK_DATA_API$6 = `click${EVENT_KEY$a}${DATA_API_KEY$6}`;\n    /**\n   * Class definition\n   */ class Button extends BaseComponent {\n        // Getters\n        static get NAME() {\n            return NAME$e;\n        }\n        // Public\n        toggle() {\n            // Toggle class and sync the `aria-pressed` attribute with the return value of the `.toggle()` method\n            this._element.setAttribute(\"aria-pressed\", this._element.classList.toggle(CLASS_NAME_ACTIVE$3));\n        }\n        // Static\n        static jQueryInterface(config) {\n            return this.each(function() {\n                const data = Button.getOrCreateInstance(this);\n                if (config === \"toggle\") {\n                    data[config]();\n                }\n            });\n        }\n    }\n    /**\n   * Data API implementation\n   */ EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, (event)=>{\n        event.preventDefault();\n        const button = event.target.closest(SELECTOR_DATA_TOGGLE$5);\n        const data = Button.getOrCreateInstance(button);\n        data.toggle();\n    });\n    /**\n   * jQuery\n   */ defineJQueryPlugin(Button);\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap util/swipe.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$d = \"swipe\";\n    const EVENT_KEY$9 = \".bs.swipe\";\n    const EVENT_TOUCHSTART = `touchstart${EVENT_KEY$9}`;\n    const EVENT_TOUCHMOVE = `touchmove${EVENT_KEY$9}`;\n    const EVENT_TOUCHEND = `touchend${EVENT_KEY$9}`;\n    const EVENT_POINTERDOWN = `pointerdown${EVENT_KEY$9}`;\n    const EVENT_POINTERUP = `pointerup${EVENT_KEY$9}`;\n    const POINTER_TYPE_TOUCH = \"touch\";\n    const POINTER_TYPE_PEN = \"pen\";\n    const CLASS_NAME_POINTER_EVENT = \"pointer-event\";\n    const SWIPE_THRESHOLD = 40;\n    const Default$c = {\n        endCallback: null,\n        leftCallback: null,\n        rightCallback: null\n    };\n    const DefaultType$c = {\n        endCallback: \"(function|null)\",\n        leftCallback: \"(function|null)\",\n        rightCallback: \"(function|null)\"\n    };\n    /**\n   * Class definition\n   */ class Swipe extends Config {\n        constructor(element, config){\n            super();\n            this._element = element;\n            if (!element || !Swipe.isSupported()) {\n                return;\n            }\n            this._config = this._getConfig(config);\n            this._deltaX = 0;\n            this._supportPointerEvents = Boolean(window.PointerEvent);\n            this._initEvents();\n        }\n        // Getters\n        static get Default() {\n            return Default$c;\n        }\n        static get DefaultType() {\n            return DefaultType$c;\n        }\n        static get NAME() {\n            return NAME$d;\n        }\n        // Public\n        dispose() {\n            EventHandler.off(this._element, EVENT_KEY$9);\n        }\n        // Private\n        _start(event) {\n            if (!this._supportPointerEvents) {\n                this._deltaX = event.touches[0].clientX;\n                return;\n            }\n            if (this._eventIsPointerPenTouch(event)) {\n                this._deltaX = event.clientX;\n            }\n        }\n        _end(event) {\n            if (this._eventIsPointerPenTouch(event)) {\n                this._deltaX = event.clientX - this._deltaX;\n            }\n            this._handleSwipe();\n            execute(this._config.endCallback);\n        }\n        _move(event) {\n            this._deltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this._deltaX;\n        }\n        _handleSwipe() {\n            const absDeltaX = Math.abs(this._deltaX);\n            if (absDeltaX <= SWIPE_THRESHOLD) {\n                return;\n            }\n            const direction = absDeltaX / this._deltaX;\n            this._deltaX = 0;\n            if (!direction) {\n                return;\n            }\n            execute(direction > 0 ? this._config.rightCallback : this._config.leftCallback);\n        }\n        _initEvents() {\n            if (this._supportPointerEvents) {\n                EventHandler.on(this._element, EVENT_POINTERDOWN, (event)=>this._start(event));\n                EventHandler.on(this._element, EVENT_POINTERUP, (event)=>this._end(event));\n                this._element.classList.add(CLASS_NAME_POINTER_EVENT);\n            } else {\n                EventHandler.on(this._element, EVENT_TOUCHSTART, (event)=>this._start(event));\n                EventHandler.on(this._element, EVENT_TOUCHMOVE, (event)=>this._move(event));\n                EventHandler.on(this._element, EVENT_TOUCHEND, (event)=>this._end(event));\n            }\n        }\n        _eventIsPointerPenTouch(event) {\n            return this._supportPointerEvents && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);\n        }\n        // Static\n        static isSupported() {\n            return \"ontouchstart\" in document.documentElement || navigator.maxTouchPoints > 0;\n        }\n    }\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap carousel.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$c = \"carousel\";\n    const DATA_KEY$8 = \"bs.carousel\";\n    const EVENT_KEY$8 = `.${DATA_KEY$8}`;\n    const DATA_API_KEY$5 = \".data-api\";\n    const ARROW_LEFT_KEY$1 = \"ArrowLeft\";\n    const ARROW_RIGHT_KEY$1 = \"ArrowRight\";\n    const TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch\n    const ORDER_NEXT = \"next\";\n    const ORDER_PREV = \"prev\";\n    const DIRECTION_LEFT = \"left\";\n    const DIRECTION_RIGHT = \"right\";\n    const EVENT_SLIDE = `slide${EVENT_KEY$8}`;\n    const EVENT_SLID = `slid${EVENT_KEY$8}`;\n    const EVENT_KEYDOWN$1 = `keydown${EVENT_KEY$8}`;\n    const EVENT_MOUSEENTER$1 = `mouseenter${EVENT_KEY$8}`;\n    const EVENT_MOUSELEAVE$1 = `mouseleave${EVENT_KEY$8}`;\n    const EVENT_DRAG_START = `dragstart${EVENT_KEY$8}`;\n    const EVENT_LOAD_DATA_API$3 = `load${EVENT_KEY$8}${DATA_API_KEY$5}`;\n    const EVENT_CLICK_DATA_API$5 = `click${EVENT_KEY$8}${DATA_API_KEY$5}`;\n    const CLASS_NAME_CAROUSEL = \"carousel\";\n    const CLASS_NAME_ACTIVE$2 = \"active\";\n    const CLASS_NAME_SLIDE = \"slide\";\n    const CLASS_NAME_END = \"carousel-item-end\";\n    const CLASS_NAME_START = \"carousel-item-start\";\n    const CLASS_NAME_NEXT = \"carousel-item-next\";\n    const CLASS_NAME_PREV = \"carousel-item-prev\";\n    const SELECTOR_ACTIVE = \".active\";\n    const SELECTOR_ITEM = \".carousel-item\";\n    const SELECTOR_ACTIVE_ITEM = SELECTOR_ACTIVE + SELECTOR_ITEM;\n    const SELECTOR_ITEM_IMG = \".carousel-item img\";\n    const SELECTOR_INDICATORS = \".carousel-indicators\";\n    const SELECTOR_DATA_SLIDE = \"[data-bs-slide], [data-bs-slide-to]\";\n    const SELECTOR_DATA_RIDE = '[data-bs-ride=\"carousel\"]';\n    const KEY_TO_DIRECTION = {\n        [ARROW_LEFT_KEY$1]: DIRECTION_RIGHT,\n        [ARROW_RIGHT_KEY$1]: DIRECTION_LEFT\n    };\n    const Default$b = {\n        interval: 5000,\n        keyboard: true,\n        pause: \"hover\",\n        ride: false,\n        touch: true,\n        wrap: true\n    };\n    const DefaultType$b = {\n        interval: \"(number|boolean)\",\n        // TODO:v6 remove boolean support\n        keyboard: \"boolean\",\n        pause: \"(string|boolean)\",\n        ride: \"(boolean|string)\",\n        touch: \"boolean\",\n        wrap: \"boolean\"\n    };\n    /**\n   * Class definition\n   */ class Carousel extends BaseComponent {\n        constructor(element, config){\n            super(element, config);\n            this._interval = null;\n            this._activeElement = null;\n            this._isSliding = false;\n            this.touchTimeout = null;\n            this._swipeHelper = null;\n            this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element);\n            this._addEventListeners();\n            if (this._config.ride === CLASS_NAME_CAROUSEL) {\n                this.cycle();\n            }\n        }\n        // Getters\n        static get Default() {\n            return Default$b;\n        }\n        static get DefaultType() {\n            return DefaultType$b;\n        }\n        static get NAME() {\n            return NAME$c;\n        }\n        // Public\n        next() {\n            this._slide(ORDER_NEXT);\n        }\n        nextWhenVisible() {\n            // FIXME TODO use `document.visibilityState`\n            // Don't call next when the page isn't visible\n            // or the carousel or its parent isn't visible\n            if (!document.hidden && isVisible(this._element)) {\n                this.next();\n            }\n        }\n        prev() {\n            this._slide(ORDER_PREV);\n        }\n        pause() {\n            if (this._isSliding) {\n                triggerTransitionEnd(this._element);\n            }\n            this._clearInterval();\n        }\n        cycle() {\n            this._clearInterval();\n            this._updateInterval();\n            this._interval = setInterval(()=>this.nextWhenVisible(), this._config.interval);\n        }\n        _maybeEnableCycle() {\n            if (!this._config.ride) {\n                return;\n            }\n            if (this._isSliding) {\n                EventHandler.one(this._element, EVENT_SLID, ()=>this.cycle());\n                return;\n            }\n            this.cycle();\n        }\n        to(index) {\n            const items = this._getItems();\n            if (index > items.length - 1 || index < 0) {\n                return;\n            }\n            if (this._isSliding) {\n                EventHandler.one(this._element, EVENT_SLID, ()=>this.to(index));\n                return;\n            }\n            const activeIndex = this._getItemIndex(this._getActive());\n            if (activeIndex === index) {\n                return;\n            }\n            const order = index > activeIndex ? ORDER_NEXT : ORDER_PREV;\n            this._slide(order, items[index]);\n        }\n        dispose() {\n            if (this._swipeHelper) {\n                this._swipeHelper.dispose();\n            }\n            super.dispose();\n        }\n        // Private\n        _configAfterMerge(config) {\n            config.defaultInterval = config.interval;\n            return config;\n        }\n        _addEventListeners() {\n            if (this._config.keyboard) {\n                EventHandler.on(this._element, EVENT_KEYDOWN$1, (event)=>this._keydown(event));\n            }\n            if (this._config.pause === \"hover\") {\n                EventHandler.on(this._element, EVENT_MOUSEENTER$1, ()=>this.pause());\n                EventHandler.on(this._element, EVENT_MOUSELEAVE$1, ()=>this._maybeEnableCycle());\n            }\n            if (this._config.touch && Swipe.isSupported()) {\n                this._addTouchEventListeners();\n            }\n        }\n        _addTouchEventListeners() {\n            for (const img of SelectorEngine.find(SELECTOR_ITEM_IMG, this._element)){\n                EventHandler.on(img, EVENT_DRAG_START, (event)=>event.preventDefault());\n            }\n            const endCallBack = ()=>{\n                if (this._config.pause !== \"hover\") {\n                    return;\n                }\n                // If it's a touch-enabled device, mouseenter/leave are fired as\n                // part of the mouse compatibility events on first tap - the carousel\n                // would stop cycling until user tapped out of it;\n                // here, we listen for touchend, explicitly pause the carousel\n                // (as if it's the second time we tap on it, mouseenter compat event\n                // is NOT fired) and after a timeout (to allow for mouse compatibility\n                // events to fire) we explicitly restart cycling\n                this.pause();\n                if (this.touchTimeout) {\n                    clearTimeout(this.touchTimeout);\n                }\n                this.touchTimeout = setTimeout(()=>this._maybeEnableCycle(), TOUCHEVENT_COMPAT_WAIT + this._config.interval);\n            };\n            const swipeConfig = {\n                leftCallback: ()=>this._slide(this._directionToOrder(DIRECTION_LEFT)),\n                rightCallback: ()=>this._slide(this._directionToOrder(DIRECTION_RIGHT)),\n                endCallback: endCallBack\n            };\n            this._swipeHelper = new Swipe(this._element, swipeConfig);\n        }\n        _keydown(event) {\n            if (/input|textarea/i.test(event.target.tagName)) {\n                return;\n            }\n            const direction = KEY_TO_DIRECTION[event.key];\n            if (direction) {\n                event.preventDefault();\n                this._slide(this._directionToOrder(direction));\n            }\n        }\n        _getItemIndex(element) {\n            return this._getItems().indexOf(element);\n        }\n        _setActiveIndicatorElement(index) {\n            if (!this._indicatorsElement) {\n                return;\n            }\n            const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE, this._indicatorsElement);\n            activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);\n            activeIndicator.removeAttribute(\"aria-current\");\n            const newActiveIndicator = SelectorEngine.findOne(`[data-bs-slide-to=\"${index}\"]`, this._indicatorsElement);\n            if (newActiveIndicator) {\n                newActiveIndicator.classList.add(CLASS_NAME_ACTIVE$2);\n                newActiveIndicator.setAttribute(\"aria-current\", \"true\");\n            }\n        }\n        _updateInterval() {\n            const element = this._activeElement || this._getActive();\n            if (!element) {\n                return;\n            }\n            const elementInterval = Number.parseInt(element.getAttribute(\"data-bs-interval\"), 10);\n            this._config.interval = elementInterval || this._config.defaultInterval;\n        }\n        _slide(order, element = null) {\n            if (this._isSliding) {\n                return;\n            }\n            const activeElement = this._getActive();\n            const isNext = order === ORDER_NEXT;\n            const nextElement = element || getNextActiveElement(this._getItems(), activeElement, isNext, this._config.wrap);\n            if (nextElement === activeElement) {\n                return;\n            }\n            const nextElementIndex = this._getItemIndex(nextElement);\n            const triggerEvent = (eventName)=>{\n                return EventHandler.trigger(this._element, eventName, {\n                    relatedTarget: nextElement,\n                    direction: this._orderToDirection(order),\n                    from: this._getItemIndex(activeElement),\n                    to: nextElementIndex\n                });\n            };\n            const slideEvent = triggerEvent(EVENT_SLIDE);\n            if (slideEvent.defaultPrevented) {\n                return;\n            }\n            if (!activeElement || !nextElement) {\n                // Some weirdness is happening, so we bail\n                // TODO: change tests that use empty divs to avoid this check\n                return;\n            }\n            const isCycling = Boolean(this._interval);\n            this.pause();\n            this._isSliding = true;\n            this._setActiveIndicatorElement(nextElementIndex);\n            this._activeElement = nextElement;\n            const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;\n            const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;\n            nextElement.classList.add(orderClassName);\n            reflow(nextElement);\n            activeElement.classList.add(directionalClassName);\n            nextElement.classList.add(directionalClassName);\n            const completeCallBack = ()=>{\n                nextElement.classList.remove(directionalClassName, orderClassName);\n                nextElement.classList.add(CLASS_NAME_ACTIVE$2);\n                activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);\n                this._isSliding = false;\n                triggerEvent(EVENT_SLID);\n            };\n            this._queueCallback(completeCallBack, activeElement, this._isAnimated());\n            if (isCycling) {\n                this.cycle();\n            }\n        }\n        _isAnimated() {\n            return this._element.classList.contains(CLASS_NAME_SLIDE);\n        }\n        _getActive() {\n            return SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);\n        }\n        _getItems() {\n            return SelectorEngine.find(SELECTOR_ITEM, this._element);\n        }\n        _clearInterval() {\n            if (this._interval) {\n                clearInterval(this._interval);\n                this._interval = null;\n            }\n        }\n        _directionToOrder(direction) {\n            if (isRTL()) {\n                return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;\n            }\n            return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;\n        }\n        _orderToDirection(order) {\n            if (isRTL()) {\n                return order === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;\n            }\n            return order === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;\n        }\n        // Static\n        static jQueryInterface(config) {\n            return this.each(function() {\n                const data = Carousel.getOrCreateInstance(this, config);\n                if (typeof config === \"number\") {\n                    data.to(config);\n                    return;\n                }\n                if (typeof config === \"string\") {\n                    if (data[config] === undefined || config.startsWith(\"_\") || config === \"constructor\") {\n                        throw new TypeError(`No method named \"${config}\"`);\n                    }\n                    data[config]();\n                }\n            });\n        }\n    }\n    /**\n   * Data API implementation\n   */ EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, function(event) {\n        const target = SelectorEngine.getElementFromSelector(this);\n        if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {\n            return;\n        }\n        event.preventDefault();\n        const carousel = Carousel.getOrCreateInstance(target);\n        const slideIndex = this.getAttribute(\"data-bs-slide-to\");\n        if (slideIndex) {\n            carousel.to(slideIndex);\n            carousel._maybeEnableCycle();\n            return;\n        }\n        if (Manipulator.getDataAttribute(this, \"slide\") === \"next\") {\n            carousel.next();\n            carousel._maybeEnableCycle();\n            return;\n        }\n        carousel.prev();\n        carousel._maybeEnableCycle();\n    });\n    EventHandler.on(window, EVENT_LOAD_DATA_API$3, ()=>{\n        const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);\n        for (const carousel of carousels){\n            Carousel.getOrCreateInstance(carousel);\n        }\n    });\n    /**\n   * jQuery\n   */ defineJQueryPlugin(Carousel);\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap collapse.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$b = \"collapse\";\n    const DATA_KEY$7 = \"bs.collapse\";\n    const EVENT_KEY$7 = `.${DATA_KEY$7}`;\n    const DATA_API_KEY$4 = \".data-api\";\n    const EVENT_SHOW$6 = `show${EVENT_KEY$7}`;\n    const EVENT_SHOWN$6 = `shown${EVENT_KEY$7}`;\n    const EVENT_HIDE$6 = `hide${EVENT_KEY$7}`;\n    const EVENT_HIDDEN$6 = `hidden${EVENT_KEY$7}`;\n    const EVENT_CLICK_DATA_API$4 = `click${EVENT_KEY$7}${DATA_API_KEY$4}`;\n    const CLASS_NAME_SHOW$7 = \"show\";\n    const CLASS_NAME_COLLAPSE = \"collapse\";\n    const CLASS_NAME_COLLAPSING = \"collapsing\";\n    const CLASS_NAME_COLLAPSED = \"collapsed\";\n    const CLASS_NAME_DEEPER_CHILDREN = `:scope .${CLASS_NAME_COLLAPSE} .${CLASS_NAME_COLLAPSE}`;\n    const CLASS_NAME_HORIZONTAL = \"collapse-horizontal\";\n    const WIDTH = \"width\";\n    const HEIGHT = \"height\";\n    const SELECTOR_ACTIVES = \".collapse.show, .collapse.collapsing\";\n    const SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle=\"collapse\"]';\n    const Default$a = {\n        parent: null,\n        toggle: true\n    };\n    const DefaultType$a = {\n        parent: \"(null|element)\",\n        toggle: \"boolean\"\n    };\n    /**\n   * Class definition\n   */ class Collapse extends BaseComponent {\n        constructor(element, config){\n            super(element, config);\n            this._isTransitioning = false;\n            this._triggerArray = [];\n            const toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);\n            for (const elem of toggleList){\n                const selector = SelectorEngine.getSelectorFromElement(elem);\n                const filterElement = SelectorEngine.find(selector).filter((foundElement)=>foundElement === this._element);\n                if (selector !== null && filterElement.length) {\n                    this._triggerArray.push(elem);\n                }\n            }\n            this._initializeChildren();\n            if (!this._config.parent) {\n                this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());\n            }\n            if (this._config.toggle) {\n                this.toggle();\n            }\n        }\n        // Getters\n        static get Default() {\n            return Default$a;\n        }\n        static get DefaultType() {\n            return DefaultType$a;\n        }\n        static get NAME() {\n            return NAME$b;\n        }\n        // Public\n        toggle() {\n            if (this._isShown()) {\n                this.hide();\n            } else {\n                this.show();\n            }\n        }\n        show() {\n            if (this._isTransitioning || this._isShown()) {\n                return;\n            }\n            let activeChildren = [];\n            // find active children\n            if (this._config.parent) {\n                activeChildren = this._getFirstLevelChildren(SELECTOR_ACTIVES).filter((element)=>element !== this._element).map((element)=>Collapse.getOrCreateInstance(element, {\n                        toggle: false\n                    }));\n            }\n            if (activeChildren.length && activeChildren[0]._isTransitioning) {\n                return;\n            }\n            const startEvent = EventHandler.trigger(this._element, EVENT_SHOW$6);\n            if (startEvent.defaultPrevented) {\n                return;\n            }\n            for (const activeInstance of activeChildren){\n                activeInstance.hide();\n            }\n            const dimension = this._getDimension();\n            this._element.classList.remove(CLASS_NAME_COLLAPSE);\n            this._element.classList.add(CLASS_NAME_COLLAPSING);\n            this._element.style[dimension] = 0;\n            this._addAriaAndCollapsedClass(this._triggerArray, true);\n            this._isTransitioning = true;\n            const complete = ()=>{\n                this._isTransitioning = false;\n                this._element.classList.remove(CLASS_NAME_COLLAPSING);\n                this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);\n                this._element.style[dimension] = \"\";\n                EventHandler.trigger(this._element, EVENT_SHOWN$6);\n            };\n            const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);\n            const scrollSize = `scroll${capitalizedDimension}`;\n            this._queueCallback(complete, this._element, true);\n            this._element.style[dimension] = `${this._element[scrollSize]}px`;\n        }\n        hide() {\n            if (this._isTransitioning || !this._isShown()) {\n                return;\n            }\n            const startEvent = EventHandler.trigger(this._element, EVENT_HIDE$6);\n            if (startEvent.defaultPrevented) {\n                return;\n            }\n            const dimension = this._getDimension();\n            this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;\n            reflow(this._element);\n            this._element.classList.add(CLASS_NAME_COLLAPSING);\n            this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);\n            for (const trigger of this._triggerArray){\n                const element = SelectorEngine.getElementFromSelector(trigger);\n                if (element && !this._isShown(element)) {\n                    this._addAriaAndCollapsedClass([\n                        trigger\n                    ], false);\n                }\n            }\n            this._isTransitioning = true;\n            const complete = ()=>{\n                this._isTransitioning = false;\n                this._element.classList.remove(CLASS_NAME_COLLAPSING);\n                this._element.classList.add(CLASS_NAME_COLLAPSE);\n                EventHandler.trigger(this._element, EVENT_HIDDEN$6);\n            };\n            this._element.style[dimension] = \"\";\n            this._queueCallback(complete, this._element, true);\n        }\n        _isShown(element = this._element) {\n            return element.classList.contains(CLASS_NAME_SHOW$7);\n        }\n        // Private\n        _configAfterMerge(config) {\n            config.toggle = Boolean(config.toggle); // Coerce string values\n            config.parent = getElement(config.parent);\n            return config;\n        }\n        _getDimension() {\n            return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;\n        }\n        _initializeChildren() {\n            if (!this._config.parent) {\n                return;\n            }\n            const children = this._getFirstLevelChildren(SELECTOR_DATA_TOGGLE$4);\n            for (const element of children){\n                const selected = SelectorEngine.getElementFromSelector(element);\n                if (selected) {\n                    this._addAriaAndCollapsedClass([\n                        element\n                    ], this._isShown(selected));\n                }\n            }\n        }\n        _getFirstLevelChildren(selector) {\n            const children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);\n            // remove children if greater depth\n            return SelectorEngine.find(selector, this._config.parent).filter((element)=>!children.includes(element));\n        }\n        _addAriaAndCollapsedClass(triggerArray, isOpen) {\n            if (!triggerArray.length) {\n                return;\n            }\n            for (const element of triggerArray){\n                element.classList.toggle(CLASS_NAME_COLLAPSED, !isOpen);\n                element.setAttribute(\"aria-expanded\", isOpen);\n            }\n        }\n        // Static\n        static jQueryInterface(config) {\n            const _config = {};\n            if (typeof config === \"string\" && /show|hide/.test(config)) {\n                _config.toggle = false;\n            }\n            return this.each(function() {\n                const data = Collapse.getOrCreateInstance(this, _config);\n                if (typeof config === \"string\") {\n                    if (typeof data[config] === \"undefined\") {\n                        throw new TypeError(`No method named \"${config}\"`);\n                    }\n                    data[config]();\n                }\n            });\n        }\n    }\n    /**\n   * Data API implementation\n   */ EventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function(event) {\n        // preventDefault only for <a> elements (which change the URL) not inside the collapsible element\n        if (event.target.tagName === \"A\" || event.delegateTarget && event.delegateTarget.tagName === \"A\") {\n            event.preventDefault();\n        }\n        for (const element of SelectorEngine.getMultipleElementsFromSelector(this)){\n            Collapse.getOrCreateInstance(element, {\n                toggle: false\n            }).toggle();\n        }\n    });\n    /**\n   * jQuery\n   */ defineJQueryPlugin(Collapse);\n    var top = \"top\";\n    var bottom = \"bottom\";\n    var right = \"right\";\n    var left = \"left\";\n    var auto = \"auto\";\n    var basePlacements = [\n        top,\n        bottom,\n        right,\n        left\n    ];\n    var start = \"start\";\n    var end = \"end\";\n    var clippingParents = \"clippingParents\";\n    var viewport = \"viewport\";\n    var popper = \"popper\";\n    var reference = \"reference\";\n    var variationPlacements = /*#__PURE__*/ basePlacements.reduce(function(acc, placement) {\n        return acc.concat([\n            placement + \"-\" + start,\n            placement + \"-\" + end\n        ]);\n    }, []);\n    var placements = /*#__PURE__*/ [].concat(basePlacements, [\n        auto\n    ]).reduce(function(acc, placement) {\n        return acc.concat([\n            placement,\n            placement + \"-\" + start,\n            placement + \"-\" + end\n        ]);\n    }, []); // modifiers that need to read the DOM\n    var beforeRead = \"beforeRead\";\n    var read = \"read\";\n    var afterRead = \"afterRead\"; // pure-logic modifiers\n    var beforeMain = \"beforeMain\";\n    var main = \"main\";\n    var afterMain = \"afterMain\"; // modifier with the purpose to write to the DOM (or write into a framework state)\n    var beforeWrite = \"beforeWrite\";\n    var write = \"write\";\n    var afterWrite = \"afterWrite\";\n    var modifierPhases = [\n        beforeRead,\n        read,\n        afterRead,\n        beforeMain,\n        main,\n        afterMain,\n        beforeWrite,\n        write,\n        afterWrite\n    ];\n    function getNodeName(element) {\n        return element ? (element.nodeName || \"\").toLowerCase() : null;\n    }\n    function getWindow(node) {\n        if (node == null) {\n            return window;\n        }\n        if (node.toString() !== \"[object Window]\") {\n            var ownerDocument = node.ownerDocument;\n            return ownerDocument ? ownerDocument.defaultView || window : window;\n        }\n        return node;\n    }\n    function isElement(node) {\n        var OwnElement = getWindow(node).Element;\n        return node instanceof OwnElement || node instanceof Element;\n    }\n    function isHTMLElement(node) {\n        var OwnElement = getWindow(node).HTMLElement;\n        return node instanceof OwnElement || node instanceof HTMLElement;\n    }\n    function isShadowRoot(node) {\n        // IE 11 has no ShadowRoot\n        if (typeof ShadowRoot === \"undefined\") {\n            return false;\n        }\n        var OwnElement = getWindow(node).ShadowRoot;\n        return node instanceof OwnElement || node instanceof ShadowRoot;\n    }\n    // and applies them to the HTMLElements such as popper and arrow\n    function applyStyles(_ref) {\n        var state = _ref.state;\n        Object.keys(state.elements).forEach(function(name) {\n            var style = state.styles[name] || {};\n            var attributes = state.attributes[name] || {};\n            var element = state.elements[name]; // arrow is optional + virtual elements\n            if (!isHTMLElement(element) || !getNodeName(element)) {\n                return;\n            } // Flow doesn't support to extend this property, but it's the most\n            // effective way to apply styles to an HTMLElement\n            // $FlowFixMe[cannot-write]\n            Object.assign(element.style, style);\n            Object.keys(attributes).forEach(function(name) {\n                var value = attributes[name];\n                if (value === false) {\n                    element.removeAttribute(name);\n                } else {\n                    element.setAttribute(name, value === true ? \"\" : value);\n                }\n            });\n        });\n    }\n    function effect$2(_ref2) {\n        var state = _ref2.state;\n        var initialStyles = {\n            popper: {\n                position: state.options.strategy,\n                left: \"0\",\n                top: \"0\",\n                margin: \"0\"\n            },\n            arrow: {\n                position: \"absolute\"\n            },\n            reference: {}\n        };\n        Object.assign(state.elements.popper.style, initialStyles.popper);\n        state.styles = initialStyles;\n        if (state.elements.arrow) {\n            Object.assign(state.elements.arrow.style, initialStyles.arrow);\n        }\n        return function() {\n            Object.keys(state.elements).forEach(function(name) {\n                var element = state.elements[name];\n                var attributes = state.attributes[name] || {};\n                var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them\n                var style = styleProperties.reduce(function(style, property) {\n                    style[property] = \"\";\n                    return style;\n                }, {}); // arrow is optional + virtual elements\n                if (!isHTMLElement(element) || !getNodeName(element)) {\n                    return;\n                }\n                Object.assign(element.style, style);\n                Object.keys(attributes).forEach(function(attribute) {\n                    element.removeAttribute(attribute);\n                });\n            });\n        };\n    } // eslint-disable-next-line import/no-unused-modules\n    const applyStyles$1 = {\n        name: \"applyStyles\",\n        enabled: true,\n        phase: \"write\",\n        fn: applyStyles,\n        effect: effect$2,\n        requires: [\n            \"computeStyles\"\n        ]\n    };\n    function getBasePlacement(placement) {\n        return placement.split(\"-\")[0];\n    }\n    var max = Math.max;\n    var min = Math.min;\n    var round = Math.round;\n    function getUAString() {\n        var uaData = navigator.userAgentData;\n        if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {\n            return uaData.brands.map(function(item) {\n                return item.brand + \"/\" + item.version;\n            }).join(\" \");\n        }\n        return navigator.userAgent;\n    }\n    function isLayoutViewport() {\n        return !/^((?!chrome|android).)*safari/i.test(getUAString());\n    }\n    function getBoundingClientRect(element, includeScale, isFixedStrategy) {\n        if (includeScale === void 0) {\n            includeScale = false;\n        }\n        if (isFixedStrategy === void 0) {\n            isFixedStrategy = false;\n        }\n        var clientRect = element.getBoundingClientRect();\n        var scaleX = 1;\n        var scaleY = 1;\n        if (includeScale && isHTMLElement(element)) {\n            scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\n            scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\n        }\n        var _ref = isElement(element) ? getWindow(element) : window, visualViewport = _ref.visualViewport;\n        var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\n        var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;\n        var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;\n        var width = clientRect.width / scaleX;\n        var height = clientRect.height / scaleY;\n        return {\n            width: width,\n            height: height,\n            top: y,\n            right: x + width,\n            bottom: y + height,\n            left: x,\n            x: x,\n            y: y\n        };\n    }\n    // means it doesn't take into account transforms.\n    function getLayoutRect(element) {\n        var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.\n        // Fixes https://github.com/popperjs/popper-core/issues/1223\n        var width = element.offsetWidth;\n        var height = element.offsetHeight;\n        if (Math.abs(clientRect.width - width) <= 1) {\n            width = clientRect.width;\n        }\n        if (Math.abs(clientRect.height - height) <= 1) {\n            height = clientRect.height;\n        }\n        return {\n            x: element.offsetLeft,\n            y: element.offsetTop,\n            width: width,\n            height: height\n        };\n    }\n    function contains(parent, child) {\n        var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method\n        if (parent.contains(child)) {\n            return true;\n        } else if (rootNode && isShadowRoot(rootNode)) {\n            var next = child;\n            do {\n                if (next && parent.isSameNode(next)) {\n                    return true;\n                } // $FlowFixMe[prop-missing]: need a better way to handle this...\n                next = next.parentNode || next.host;\n            }while (next);\n        } // Give up, the result is false\n        return false;\n    }\n    function getComputedStyle$1(element) {\n        return getWindow(element).getComputedStyle(element);\n    }\n    function isTableElement(element) {\n        return [\n            \"table\",\n            \"td\",\n            \"th\"\n        ].indexOf(getNodeName(element)) >= 0;\n    }\n    function getDocumentElement(element) {\n        // $FlowFixMe[incompatible-return]: assume body is always available\n        return ((isElement(element) ? element.ownerDocument : element.document) || window.document).documentElement;\n    }\n    function getParentNode(element) {\n        if (getNodeName(element) === \"html\") {\n            return element;\n        }\n        return(// $FlowFixMe[incompatible-return]\n        // $FlowFixMe[prop-missing]\n        element.assignedSlot || // step into the shadow DOM of the parent of a slotted node\n        element.parentNode || (isShadowRoot(element) ? element.host : null) || // ShadowRoot detected\n        // $FlowFixMe[incompatible-call]: HTMLElement is a Node\n        getDocumentElement(element) // fallback\n        );\n    }\n    function getTrueOffsetParent(element) {\n        if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837\n        getComputedStyle$1(element).position === \"fixed\") {\n            return null;\n        }\n        return element.offsetParent;\n    } // `.offsetParent` reports `null` for fixed elements, while absolute elements\n    // return the containing block\n    function getContainingBlock(element) {\n        var isFirefox = /firefox/i.test(getUAString());\n        var isIE = /Trident/i.test(getUAString());\n        if (isIE && isHTMLElement(element)) {\n            // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport\n            var elementCss = getComputedStyle$1(element);\n            if (elementCss.position === \"fixed\") {\n                return null;\n            }\n        }\n        var currentNode = getParentNode(element);\n        if (isShadowRoot(currentNode)) {\n            currentNode = currentNode.host;\n        }\n        while(isHTMLElement(currentNode) && [\n            \"html\",\n            \"body\"\n        ].indexOf(getNodeName(currentNode)) < 0){\n            var css = getComputedStyle$1(currentNode); // This is non-exhaustive but covers the most common CSS properties that\n            // create a containing block.\n            // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\n            if (css.transform !== \"none\" || css.perspective !== \"none\" || css.contain === \"paint\" || [\n                \"transform\",\n                \"perspective\"\n            ].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === \"filter\" || isFirefox && css.filter && css.filter !== \"none\") {\n                return currentNode;\n            } else {\n                currentNode = currentNode.parentNode;\n            }\n        }\n        return null;\n    } // Gets the closest ancestor positioned element. Handles some edge cases,\n    // such as table ancestors and cross browser bugs.\n    function getOffsetParent(element) {\n        var window1 = getWindow(element);\n        var offsetParent = getTrueOffsetParent(element);\n        while(offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === \"static\"){\n            offsetParent = getTrueOffsetParent(offsetParent);\n        }\n        if (offsetParent && (getNodeName(offsetParent) === \"html\" || getNodeName(offsetParent) === \"body\" && getComputedStyle$1(offsetParent).position === \"static\")) {\n            return window1;\n        }\n        return offsetParent || getContainingBlock(element) || window1;\n    }\n    function getMainAxisFromPlacement(placement) {\n        return [\n            \"top\",\n            \"bottom\"\n        ].indexOf(placement) >= 0 ? \"x\" : \"y\";\n    }\n    function within(min$1, value, max$1) {\n        return max(min$1, min(value, max$1));\n    }\n    function withinMaxClamp(min, value, max) {\n        var v = within(min, value, max);\n        return v > max ? max : v;\n    }\n    function getFreshSideObject() {\n        return {\n            top: 0,\n            right: 0,\n            bottom: 0,\n            left: 0\n        };\n    }\n    function mergePaddingObject(paddingObject) {\n        return Object.assign({}, getFreshSideObject(), paddingObject);\n    }\n    function expandToHashMap(value, keys) {\n        return keys.reduce(function(hashMap, key) {\n            hashMap[key] = value;\n            return hashMap;\n        }, {});\n    }\n    var toPaddingObject = function toPaddingObject(padding, state) {\n        padding = typeof padding === \"function\" ? padding(Object.assign({}, state.rects, {\n            placement: state.placement\n        })) : padding;\n        return mergePaddingObject(typeof padding !== \"number\" ? padding : expandToHashMap(padding, basePlacements));\n    };\n    function arrow(_ref) {\n        var _state$modifiersData$;\n        var state = _ref.state, name = _ref.name, options = _ref.options;\n        var arrowElement = state.elements.arrow;\n        var popperOffsets = state.modifiersData.popperOffsets;\n        var basePlacement = getBasePlacement(state.placement);\n        var axis = getMainAxisFromPlacement(basePlacement);\n        var isVertical = [\n            left,\n            right\n        ].indexOf(basePlacement) >= 0;\n        var len = isVertical ? \"height\" : \"width\";\n        if (!arrowElement || !popperOffsets) {\n            return;\n        }\n        var paddingObject = toPaddingObject(options.padding, state);\n        var arrowRect = getLayoutRect(arrowElement);\n        var minProp = axis === \"y\" ? top : left;\n        var maxProp = axis === \"y\" ? bottom : right;\n        var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\n        var startDiff = popperOffsets[axis] - state.rects.reference[axis];\n        var arrowOffsetParent = getOffsetParent(arrowElement);\n        var clientSize = arrowOffsetParent ? axis === \"y\" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\n        var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is\n        // outside of the popper bounds\n        var min = paddingObject[minProp];\n        var max = clientSize - arrowRect[len] - paddingObject[maxProp];\n        var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\n        var offset = within(min, center, max); // Prevents breaking syntax highlighting...\n        var axisProp = axis;\n        state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);\n    }\n    function effect$1(_ref2) {\n        var state = _ref2.state, options = _ref2.options;\n        var _options$element = options.element, arrowElement = _options$element === void 0 ? \"[data-popper-arrow]\" : _options$element;\n        if (arrowElement == null) {\n            return;\n        } // CSS selector\n        if (typeof arrowElement === \"string\") {\n            arrowElement = state.elements.popper.querySelector(arrowElement);\n            if (!arrowElement) {\n                return;\n            }\n        }\n        if (!contains(state.elements.popper, arrowElement)) {\n            return;\n        }\n        state.elements.arrow = arrowElement;\n    } // eslint-disable-next-line import/no-unused-modules\n    const arrow$1 = {\n        name: \"arrow\",\n        enabled: true,\n        phase: \"main\",\n        fn: arrow,\n        effect: effect$1,\n        requires: [\n            \"popperOffsets\"\n        ],\n        requiresIfExists: [\n            \"preventOverflow\"\n        ]\n    };\n    function getVariation(placement) {\n        return placement.split(\"-\")[1];\n    }\n    var unsetSides = {\n        top: \"auto\",\n        right: \"auto\",\n        bottom: \"auto\",\n        left: \"auto\"\n    }; // Round the offsets to the nearest suitable subpixel based on the DPR.\n    // Zooming can change the DPR, but it seems to report a value that will\n    // cleanly divide the values into the appropriate subpixels.\n    function roundOffsetsByDPR(_ref, win) {\n        var x = _ref.x, y = _ref.y;\n        var dpr = win.devicePixelRatio || 1;\n        return {\n            x: round(x * dpr) / dpr || 0,\n            y: round(y * dpr) / dpr || 0\n        };\n    }\n    function mapToStyles(_ref2) {\n        var _Object$assign2;\n        var popper = _ref2.popper, popperRect = _ref2.popperRect, placement = _ref2.placement, variation = _ref2.variation, offsets = _ref2.offsets, position = _ref2.position, gpuAcceleration = _ref2.gpuAcceleration, adaptive = _ref2.adaptive, roundOffsets = _ref2.roundOffsets, isFixed = _ref2.isFixed;\n        var _offsets$x = offsets.x, x = _offsets$x === void 0 ? 0 : _offsets$x, _offsets$y = offsets.y, y = _offsets$y === void 0 ? 0 : _offsets$y;\n        var _ref3 = typeof roundOffsets === \"function\" ? roundOffsets({\n            x: x,\n            y: y\n        }) : {\n            x: x,\n            y: y\n        };\n        x = _ref3.x;\n        y = _ref3.y;\n        var hasX = offsets.hasOwnProperty(\"x\");\n        var hasY = offsets.hasOwnProperty(\"y\");\n        var sideX = left;\n        var sideY = top;\n        var win = window;\n        if (adaptive) {\n            var offsetParent = getOffsetParent(popper);\n            var heightProp = \"clientHeight\";\n            var widthProp = \"clientWidth\";\n            if (offsetParent === getWindow(popper)) {\n                offsetParent = getDocumentElement(popper);\n                if (getComputedStyle$1(offsetParent).position !== \"static\" && position === \"absolute\") {\n                    heightProp = \"scrollHeight\";\n                    widthProp = \"scrollWidth\";\n                }\n            } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\n            offsetParent = offsetParent;\n            if (placement === top || (placement === left || placement === right) && variation === end) {\n                sideY = bottom;\n                var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : offsetParent[heightProp];\n                y -= offsetY - popperRect.height;\n                y *= gpuAcceleration ? 1 : -1;\n            }\n            if (placement === left || (placement === top || placement === bottom) && variation === end) {\n                sideX = right;\n                var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : offsetParent[widthProp];\n                x -= offsetX - popperRect.width;\n                x *= gpuAcceleration ? 1 : -1;\n            }\n        }\n        var commonStyles = Object.assign({\n            position: position\n        }, adaptive && unsetSides);\n        var _ref4 = roundOffsets === true ? roundOffsetsByDPR({\n            x: x,\n            y: y\n        }, getWindow(popper)) : {\n            x: x,\n            y: y\n        };\n        x = _ref4.x;\n        y = _ref4.y;\n        if (gpuAcceleration) {\n            var _Object$assign;\n            return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? \"0\" : \"\", _Object$assign[sideX] = hasX ? \"0\" : \"\", _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? \"translate(\" + x + \"px, \" + y + \"px)\" : \"translate3d(\" + x + \"px, \" + y + \"px, 0)\", _Object$assign));\n        }\n        return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + \"px\" : \"\", _Object$assign2[sideX] = hasX ? x + \"px\" : \"\", _Object$assign2.transform = \"\", _Object$assign2));\n    }\n    function computeStyles(_ref5) {\n        var state = _ref5.state, options = _ref5.options;\n        var _options$gpuAccelerat = options.gpuAcceleration, gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat, _options$adaptive = options.adaptive, adaptive = _options$adaptive === void 0 ? true : _options$adaptive, _options$roundOffsets = options.roundOffsets, roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;\n        var commonStyles = {\n            placement: getBasePlacement(state.placement),\n            variation: getVariation(state.placement),\n            popper: state.elements.popper,\n            popperRect: state.rects.popper,\n            gpuAcceleration: gpuAcceleration,\n            isFixed: state.options.strategy === \"fixed\"\n        };\n        if (state.modifiersData.popperOffsets != null) {\n            state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {\n                offsets: state.modifiersData.popperOffsets,\n                position: state.options.strategy,\n                adaptive: adaptive,\n                roundOffsets: roundOffsets\n            })));\n        }\n        if (state.modifiersData.arrow != null) {\n            state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {\n                offsets: state.modifiersData.arrow,\n                position: \"absolute\",\n                adaptive: false,\n                roundOffsets: roundOffsets\n            })));\n        }\n        state.attributes.popper = Object.assign({}, state.attributes.popper, {\n            \"data-popper-placement\": state.placement\n        });\n    } // eslint-disable-next-line import/no-unused-modules\n    const computeStyles$1 = {\n        name: \"computeStyles\",\n        enabled: true,\n        phase: \"beforeWrite\",\n        fn: computeStyles,\n        data: {}\n    };\n    var passive = {\n        passive: true\n    };\n    function effect(_ref) {\n        var state = _ref.state, instance = _ref.instance, options = _ref.options;\n        var _options$scroll = options.scroll, scroll = _options$scroll === void 0 ? true : _options$scroll, _options$resize = options.resize, resize = _options$resize === void 0 ? true : _options$resize;\n        var window1 = getWindow(state.elements.popper);\n        var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\n        if (scroll) {\n            scrollParents.forEach(function(scrollParent) {\n                scrollParent.addEventListener(\"scroll\", instance.update, passive);\n            });\n        }\n        if (resize) {\n            window1.addEventListener(\"resize\", instance.update, passive);\n        }\n        return function() {\n            if (scroll) {\n                scrollParents.forEach(function(scrollParent) {\n                    scrollParent.removeEventListener(\"scroll\", instance.update, passive);\n                });\n            }\n            if (resize) {\n                window1.removeEventListener(\"resize\", instance.update, passive);\n            }\n        };\n    } // eslint-disable-next-line import/no-unused-modules\n    const eventListeners = {\n        name: \"eventListeners\",\n        enabled: true,\n        phase: \"write\",\n        fn: function fn() {},\n        effect: effect,\n        data: {}\n    };\n    var hash$1 = {\n        left: \"right\",\n        right: \"left\",\n        bottom: \"top\",\n        top: \"bottom\"\n    };\n    function getOppositePlacement(placement) {\n        return placement.replace(/left|right|bottom|top/g, function(matched) {\n            return hash$1[matched];\n        });\n    }\n    var hash = {\n        start: \"end\",\n        end: \"start\"\n    };\n    function getOppositeVariationPlacement(placement) {\n        return placement.replace(/start|end/g, function(matched) {\n            return hash[matched];\n        });\n    }\n    function getWindowScroll(node) {\n        var win = getWindow(node);\n        var scrollLeft = win.pageXOffset;\n        var scrollTop = win.pageYOffset;\n        return {\n            scrollLeft: scrollLeft,\n            scrollTop: scrollTop\n        };\n    }\n    function getWindowScrollBarX(element) {\n        // If <html> has a CSS width greater than the viewport, then this will be\n        // incorrect for RTL.\n        // Popper 1 is broken in this case and never had a bug report so let's assume\n        // it's not an issue. I don't think anyone ever specifies width on <html>\n        // anyway.\n        // Browsers where the left scrollbar doesn't cause an issue report `0` for\n        // this (e.g. Edge 2019, IE11, Safari)\n        return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;\n    }\n    function getViewportRect(element, strategy) {\n        var win = getWindow(element);\n        var html = getDocumentElement(element);\n        var visualViewport = win.visualViewport;\n        var width = html.clientWidth;\n        var height = html.clientHeight;\n        var x = 0;\n        var y = 0;\n        if (visualViewport) {\n            width = visualViewport.width;\n            height = visualViewport.height;\n            var layoutViewport = isLayoutViewport();\n            if (layoutViewport || !layoutViewport && strategy === \"fixed\") {\n                x = visualViewport.offsetLeft;\n                y = visualViewport.offsetTop;\n            }\n        }\n        return {\n            width: width,\n            height: height,\n            x: x + getWindowScrollBarX(element),\n            y: y\n        };\n    }\n    // of the `<html>` and `<body>` rect bounds if horizontally scrollable\n    function getDocumentRect(element) {\n        var _element$ownerDocumen;\n        var html = getDocumentElement(element);\n        var winScroll = getWindowScroll(element);\n        var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\n        var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\n        var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\n        var x = -winScroll.scrollLeft + getWindowScrollBarX(element);\n        var y = -winScroll.scrollTop;\n        if (getComputedStyle$1(body || html).direction === \"rtl\") {\n            x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\n        }\n        return {\n            width: width,\n            height: height,\n            x: x,\n            y: y\n        };\n    }\n    function isScrollParent(element) {\n        // Firefox wants us to check `-x` and `-y` variations as well\n        var _getComputedStyle = getComputedStyle$1(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY;\n        return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\n    }\n    function getScrollParent(node) {\n        if ([\n            \"html\",\n            \"body\",\n            \"#document\"\n        ].indexOf(getNodeName(node)) >= 0) {\n            // $FlowFixMe[incompatible-return]: assume body is always available\n            return node.ownerDocument.body;\n        }\n        if (isHTMLElement(node) && isScrollParent(node)) {\n            return node;\n        }\n        return getScrollParent(getParentNode(node));\n    }\n    /*\n  given a DOM element, return the list of all scroll parents, up the list of ancesors\n  until we get to the top window object. This list is what we attach scroll listeners\n  to, because if any of these parent elements scroll, we'll need to re-calculate the\n  reference element's position.\n  */ function listScrollParents(element, list) {\n        var _element$ownerDocumen;\n        if (list === void 0) {\n            list = [];\n        }\n        var scrollParent = getScrollParent(element);\n        var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);\n        var win = getWindow(scrollParent);\n        var target = isBody ? [\n            win\n        ].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;\n        var updatedList = list.concat(target);\n        return isBody ? updatedList : updatedList.concat(listScrollParents(getParentNode(target)));\n    }\n    function rectToClientRect(rect) {\n        return Object.assign({}, rect, {\n            left: rect.x,\n            top: rect.y,\n            right: rect.x + rect.width,\n            bottom: rect.y + rect.height\n        });\n    }\n    function getInnerBoundingClientRect(element, strategy) {\n        var rect = getBoundingClientRect(element, false, strategy === \"fixed\");\n        rect.top = rect.top + element.clientTop;\n        rect.left = rect.left + element.clientLeft;\n        rect.bottom = rect.top + element.clientHeight;\n        rect.right = rect.left + element.clientWidth;\n        rect.width = element.clientWidth;\n        rect.height = element.clientHeight;\n        rect.x = rect.left;\n        rect.y = rect.top;\n        return rect;\n    }\n    function getClientRectFromMixedType(element, clippingParent, strategy) {\n        return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\n    } // A \"clipping parent\" is an overflowable container with the characteristic of\n    // clipping (or hiding) overflowing elements with a position different from\n    // `initial`\n    function getClippingParents(element) {\n        var clippingParents = listScrollParents(getParentNode(element));\n        var canEscapeClipping = [\n            \"absolute\",\n            \"fixed\"\n        ].indexOf(getComputedStyle$1(element).position) >= 0;\n        var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\n        if (!isElement(clipperElement)) {\n            return [];\n        } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414\n        return clippingParents.filter(function(clippingParent) {\n            return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== \"body\";\n        });\n    } // Gets the maximum area that the element is visible in due to any number of\n    // clipping parents\n    function getClippingRect(element, boundary, rootBoundary, strategy) {\n        var mainClippingParents = boundary === \"clippingParents\" ? getClippingParents(element) : [].concat(boundary);\n        var clippingParents = [].concat(mainClippingParents, [\n            rootBoundary\n        ]);\n        var firstClippingParent = clippingParents[0];\n        var clippingRect = clippingParents.reduce(function(accRect, clippingParent) {\n            var rect = getClientRectFromMixedType(element, clippingParent, strategy);\n            accRect.top = max(rect.top, accRect.top);\n            accRect.right = min(rect.right, accRect.right);\n            accRect.bottom = min(rect.bottom, accRect.bottom);\n            accRect.left = max(rect.left, accRect.left);\n            return accRect;\n        }, getClientRectFromMixedType(element, firstClippingParent, strategy));\n        clippingRect.width = clippingRect.right - clippingRect.left;\n        clippingRect.height = clippingRect.bottom - clippingRect.top;\n        clippingRect.x = clippingRect.left;\n        clippingRect.y = clippingRect.top;\n        return clippingRect;\n    }\n    function computeOffsets(_ref) {\n        var reference = _ref.reference, element = _ref.element, placement = _ref.placement;\n        var basePlacement = placement ? getBasePlacement(placement) : null;\n        var variation = placement ? getVariation(placement) : null;\n        var commonX = reference.x + reference.width / 2 - element.width / 2;\n        var commonY = reference.y + reference.height / 2 - element.height / 2;\n        var offsets;\n        switch(basePlacement){\n            case top:\n                offsets = {\n                    x: commonX,\n                    y: reference.y - element.height\n                };\n                break;\n            case bottom:\n                offsets = {\n                    x: commonX,\n                    y: reference.y + reference.height\n                };\n                break;\n            case right:\n                offsets = {\n                    x: reference.x + reference.width,\n                    y: commonY\n                };\n                break;\n            case left:\n                offsets = {\n                    x: reference.x - element.width,\n                    y: commonY\n                };\n                break;\n            default:\n                offsets = {\n                    x: reference.x,\n                    y: reference.y\n                };\n        }\n        var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;\n        if (mainAxis != null) {\n            var len = mainAxis === \"y\" ? \"height\" : \"width\";\n            switch(variation){\n                case start:\n                    offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);\n                    break;\n                case end:\n                    offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);\n                    break;\n            }\n        }\n        return offsets;\n    }\n    function detectOverflow(state, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        var _options = options, _options$placement = _options.placement, placement = _options$placement === void 0 ? state.placement : _options$placement, _options$strategy = _options.strategy, strategy = _options$strategy === void 0 ? state.strategy : _options$strategy, _options$boundary = _options.boundary, boundary = _options$boundary === void 0 ? clippingParents : _options$boundary, _options$rootBoundary = _options.rootBoundary, rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary, _options$elementConte = _options.elementContext, elementContext = _options$elementConte === void 0 ? popper : _options$elementConte, _options$altBoundary = _options.altBoundary, altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary, _options$padding = _options.padding, padding = _options$padding === void 0 ? 0 : _options$padding;\n        var paddingObject = mergePaddingObject(typeof padding !== \"number\" ? padding : expandToHashMap(padding, basePlacements));\n        var altContext = elementContext === popper ? reference : popper;\n        var popperRect = state.rects.popper;\n        var element = state.elements[altBoundary ? altContext : elementContext];\n        var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);\n        var referenceClientRect = getBoundingClientRect(state.elements.reference);\n        var popperOffsets = computeOffsets({\n            reference: referenceClientRect,\n            element: popperRect,\n            strategy: \"absolute\",\n            placement: placement\n        });\n        var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));\n        var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\n        // 0 or negative = within the clipping rect\n        var overflowOffsets = {\n            top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\n            bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\n            left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\n            right: elementClientRect.right - clippingClientRect.right + paddingObject.right\n        };\n        var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\n        if (elementContext === popper && offsetData) {\n            var offset = offsetData[placement];\n            Object.keys(overflowOffsets).forEach(function(key) {\n                var multiply = [\n                    right,\n                    bottom\n                ].indexOf(key) >= 0 ? 1 : -1;\n                var axis = [\n                    top,\n                    bottom\n                ].indexOf(key) >= 0 ? \"y\" : \"x\";\n                overflowOffsets[key] += offset[axis] * multiply;\n            });\n        }\n        return overflowOffsets;\n    }\n    function computeAutoPlacement(state, options) {\n        if (options === void 0) {\n            options = {};\n        }\n        var _options = options, placement = _options.placement, boundary = _options.boundary, rootBoundary = _options.rootBoundary, padding = _options.padding, flipVariations = _options.flipVariations, _options$allowedAutoP = _options.allowedAutoPlacements, allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;\n        var variation = getVariation(placement);\n        var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function(placement) {\n            return getVariation(placement) === variation;\n        }) : basePlacements;\n        var allowedPlacements = placements$1.filter(function(placement) {\n            return allowedAutoPlacements.indexOf(placement) >= 0;\n        });\n        if (allowedPlacements.length === 0) {\n            allowedPlacements = placements$1;\n        } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...\n        var overflows = allowedPlacements.reduce(function(acc, placement) {\n            acc[placement] = detectOverflow(state, {\n                placement: placement,\n                boundary: boundary,\n                rootBoundary: rootBoundary,\n                padding: padding\n            })[getBasePlacement(placement)];\n            return acc;\n        }, {});\n        return Object.keys(overflows).sort(function(a, b) {\n            return overflows[a] - overflows[b];\n        });\n    }\n    function getExpandedFallbackPlacements(placement) {\n        if (getBasePlacement(placement) === auto) {\n            return [];\n        }\n        var oppositePlacement = getOppositePlacement(placement);\n        return [\n            getOppositeVariationPlacement(placement),\n            oppositePlacement,\n            getOppositeVariationPlacement(oppositePlacement)\n        ];\n    }\n    function flip(_ref) {\n        var state = _ref.state, options = _ref.options, name = _ref.name;\n        if (state.modifiersData[name]._skip) {\n            return;\n        }\n        var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis, specifiedFallbackPlacements = options.fallbackPlacements, padding = options.padding, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, _options$flipVariatio = options.flipVariations, flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio, allowedAutoPlacements = options.allowedAutoPlacements;\n        var preferredPlacement = state.options.placement;\n        var basePlacement = getBasePlacement(preferredPlacement);\n        var isBasePlacement = basePlacement === preferredPlacement;\n        var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [\n            getOppositePlacement(preferredPlacement)\n        ] : getExpandedFallbackPlacements(preferredPlacement));\n        var placements = [\n            preferredPlacement\n        ].concat(fallbackPlacements).reduce(function(acc, placement) {\n            return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {\n                placement: placement,\n                boundary: boundary,\n                rootBoundary: rootBoundary,\n                padding: padding,\n                flipVariations: flipVariations,\n                allowedAutoPlacements: allowedAutoPlacements\n            }) : placement);\n        }, []);\n        var referenceRect = state.rects.reference;\n        var popperRect = state.rects.popper;\n        var checksMap = new Map();\n        var makeFallbackChecks = true;\n        var firstFittingPlacement = placements[0];\n        for(var i = 0; i < placements.length; i++){\n            var placement = placements[i];\n            var _basePlacement = getBasePlacement(placement);\n            var isStartVariation = getVariation(placement) === start;\n            var isVertical = [\n                top,\n                bottom\n            ].indexOf(_basePlacement) >= 0;\n            var len = isVertical ? \"width\" : \"height\";\n            var overflow = detectOverflow(state, {\n                placement: placement,\n                boundary: boundary,\n                rootBoundary: rootBoundary,\n                altBoundary: altBoundary,\n                padding: padding\n            });\n            var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;\n            if (referenceRect[len] > popperRect[len]) {\n                mainVariationSide = getOppositePlacement(mainVariationSide);\n            }\n            var altVariationSide = getOppositePlacement(mainVariationSide);\n            var checks = [];\n            if (checkMainAxis) {\n                checks.push(overflow[_basePlacement] <= 0);\n            }\n            if (checkAltAxis) {\n                checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\n            }\n            if (checks.every(function(check) {\n                return check;\n            })) {\n                firstFittingPlacement = placement;\n                makeFallbackChecks = false;\n                break;\n            }\n            checksMap.set(placement, checks);\n        }\n        if (makeFallbackChecks) {\n            // `2` may be desired in some cases – research later\n            var numberOfChecks = flipVariations ? 3 : 1;\n            var _loop = function _loop(_i) {\n                var fittingPlacement = placements.find(function(placement) {\n                    var checks = checksMap.get(placement);\n                    if (checks) {\n                        return checks.slice(0, _i).every(function(check) {\n                            return check;\n                        });\n                    }\n                });\n                if (fittingPlacement) {\n                    firstFittingPlacement = fittingPlacement;\n                    return \"break\";\n                }\n            };\n            for(var _i = numberOfChecks; _i > 0; _i--){\n                var _ret = _loop(_i);\n                if (_ret === \"break\") break;\n            }\n        }\n        if (state.placement !== firstFittingPlacement) {\n            state.modifiersData[name]._skip = true;\n            state.placement = firstFittingPlacement;\n            state.reset = true;\n        }\n    } // eslint-disable-next-line import/no-unused-modules\n    const flip$1 = {\n        name: \"flip\",\n        enabled: true,\n        phase: \"main\",\n        fn: flip,\n        requiresIfExists: [\n            \"offset\"\n        ],\n        data: {\n            _skip: false\n        }\n    };\n    function getSideOffsets(overflow, rect, preventedOffsets) {\n        if (preventedOffsets === void 0) {\n            preventedOffsets = {\n                x: 0,\n                y: 0\n            };\n        }\n        return {\n            top: overflow.top - rect.height - preventedOffsets.y,\n            right: overflow.right - rect.width + preventedOffsets.x,\n            bottom: overflow.bottom - rect.height + preventedOffsets.y,\n            left: overflow.left - rect.width - preventedOffsets.x\n        };\n    }\n    function isAnySideFullyClipped(overflow) {\n        return [\n            top,\n            right,\n            bottom,\n            left\n        ].some(function(side) {\n            return overflow[side] >= 0;\n        });\n    }\n    function hide(_ref) {\n        var state = _ref.state, name = _ref.name;\n        var referenceRect = state.rects.reference;\n        var popperRect = state.rects.popper;\n        var preventedOffsets = state.modifiersData.preventOverflow;\n        var referenceOverflow = detectOverflow(state, {\n            elementContext: \"reference\"\n        });\n        var popperAltOverflow = detectOverflow(state, {\n            altBoundary: true\n        });\n        var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);\n        var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);\n        var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\n        var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\n        state.modifiersData[name] = {\n            referenceClippingOffsets: referenceClippingOffsets,\n            popperEscapeOffsets: popperEscapeOffsets,\n            isReferenceHidden: isReferenceHidden,\n            hasPopperEscaped: hasPopperEscaped\n        };\n        state.attributes.popper = Object.assign({}, state.attributes.popper, {\n            \"data-popper-reference-hidden\": isReferenceHidden,\n            \"data-popper-escaped\": hasPopperEscaped\n        });\n    } // eslint-disable-next-line import/no-unused-modules\n    const hide$1 = {\n        name: \"hide\",\n        enabled: true,\n        phase: \"main\",\n        requiresIfExists: [\n            \"preventOverflow\"\n        ],\n        fn: hide\n    };\n    function distanceAndSkiddingToXY(placement, rects, offset) {\n        var basePlacement = getBasePlacement(placement);\n        var invertDistance = [\n            left,\n            top\n        ].indexOf(basePlacement) >= 0 ? -1 : 1;\n        var _ref = typeof offset === \"function\" ? offset(Object.assign({}, rects, {\n            placement: placement\n        })) : offset, skidding = _ref[0], distance = _ref[1];\n        skidding = skidding || 0;\n        distance = (distance || 0) * invertDistance;\n        return [\n            left,\n            right\n        ].indexOf(basePlacement) >= 0 ? {\n            x: distance,\n            y: skidding\n        } : {\n            x: skidding,\n            y: distance\n        };\n    }\n    function offset(_ref2) {\n        var state = _ref2.state, options = _ref2.options, name = _ref2.name;\n        var _options$offset = options.offset, offset = _options$offset === void 0 ? [\n            0,\n            0\n        ] : _options$offset;\n        var data = placements.reduce(function(acc, placement) {\n            acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);\n            return acc;\n        }, {});\n        var _data$state$placement = data[state.placement], x = _data$state$placement.x, y = _data$state$placement.y;\n        if (state.modifiersData.popperOffsets != null) {\n            state.modifiersData.popperOffsets.x += x;\n            state.modifiersData.popperOffsets.y += y;\n        }\n        state.modifiersData[name] = data;\n    } // eslint-disable-next-line import/no-unused-modules\n    const offset$1 = {\n        name: \"offset\",\n        enabled: true,\n        phase: \"main\",\n        requires: [\n            \"popperOffsets\"\n        ],\n        fn: offset\n    };\n    function popperOffsets(_ref) {\n        var state = _ref.state, name = _ref.name;\n        // Offsets are the actual position the popper needs to have to be\n        // properly positioned near its reference element\n        // This is the most basic placement, and will be adjusted by\n        // the modifiers in the next step\n        state.modifiersData[name] = computeOffsets({\n            reference: state.rects.reference,\n            element: state.rects.popper,\n            strategy: \"absolute\",\n            placement: state.placement\n        });\n    } // eslint-disable-next-line import/no-unused-modules\n    const popperOffsets$1 = {\n        name: \"popperOffsets\",\n        enabled: true,\n        phase: \"read\",\n        fn: popperOffsets,\n        data: {}\n    };\n    function getAltAxis(axis) {\n        return axis === \"x\" ? \"y\" : \"x\";\n    }\n    function preventOverflow(_ref) {\n        var state = _ref.state, options = _ref.options, name = _ref.name;\n        var _options$mainAxis = options.mainAxis, checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis, _options$altAxis = options.altAxis, checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis, boundary = options.boundary, rootBoundary = options.rootBoundary, altBoundary = options.altBoundary, padding = options.padding, _options$tether = options.tether, tether = _options$tether === void 0 ? true : _options$tether, _options$tetherOffset = options.tetherOffset, tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\n        var overflow = detectOverflow(state, {\n            boundary: boundary,\n            rootBoundary: rootBoundary,\n            padding: padding,\n            altBoundary: altBoundary\n        });\n        var basePlacement = getBasePlacement(state.placement);\n        var variation = getVariation(state.placement);\n        var isBasePlacement = !variation;\n        var mainAxis = getMainAxisFromPlacement(basePlacement);\n        var altAxis = getAltAxis(mainAxis);\n        var popperOffsets = state.modifiersData.popperOffsets;\n        var referenceRect = state.rects.reference;\n        var popperRect = state.rects.popper;\n        var tetherOffsetValue = typeof tetherOffset === \"function\" ? tetherOffset(Object.assign({}, state.rects, {\n            placement: state.placement\n        })) : tetherOffset;\n        var normalizedTetherOffsetValue = typeof tetherOffsetValue === \"number\" ? {\n            mainAxis: tetherOffsetValue,\n            altAxis: tetherOffsetValue\n        } : Object.assign({\n            mainAxis: 0,\n            altAxis: 0\n        }, tetherOffsetValue);\n        var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;\n        var data = {\n            x: 0,\n            y: 0\n        };\n        if (!popperOffsets) {\n            return;\n        }\n        if (checkMainAxis) {\n            var _offsetModifierState$;\n            var mainSide = mainAxis === \"y\" ? top : left;\n            var altSide = mainAxis === \"y\" ? bottom : right;\n            var len = mainAxis === \"y\" ? \"height\" : \"width\";\n            var offset = popperOffsets[mainAxis];\n            var min$1 = offset + overflow[mainSide];\n            var max$1 = offset - overflow[altSide];\n            var additive = tether ? -popperRect[len] / 2 : 0;\n            var minLen = variation === start ? referenceRect[len] : popperRect[len];\n            var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\n            // outside the reference bounds\n            var arrowElement = state.elements.arrow;\n            var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\n                width: 0,\n                height: 0\n            };\n            var arrowPaddingObject = state.modifiersData[\"arrow#persistent\"] ? state.modifiersData[\"arrow#persistent\"].padding : getFreshSideObject();\n            var arrowPaddingMin = arrowPaddingObject[mainSide];\n            var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\n            // to include its full size in the calculation. If the reference is small\n            // and near the edge of a boundary, the popper can overflow even if the\n            // reference is not overflowing as well (e.g. virtual elements with no\n            // width or height)\n            var arrowLen = within(0, referenceRect[len], arrowRect[len]);\n            var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;\n            var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;\n            var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\n            var clientOffset = arrowOffsetParent ? mainAxis === \"y\" ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\n            var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;\n            var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;\n            var tetherMax = offset + maxOffset - offsetModifierValue;\n            var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);\n            popperOffsets[mainAxis] = preventedOffset;\n            data[mainAxis] = preventedOffset - offset;\n        }\n        if (checkAltAxis) {\n            var _offsetModifierState$2;\n            var _mainSide = mainAxis === \"x\" ? top : left;\n            var _altSide = mainAxis === \"x\" ? bottom : right;\n            var _offset = popperOffsets[altAxis];\n            var _len = altAxis === \"y\" ? \"height\" : \"width\";\n            var _min = _offset + overflow[_mainSide];\n            var _max = _offset - overflow[_altSide];\n            var isOriginSide = [\n                top,\n                left\n            ].indexOf(basePlacement) !== -1;\n            var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;\n            var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;\n            var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;\n            var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);\n            popperOffsets[altAxis] = _preventedOffset;\n            data[altAxis] = _preventedOffset - _offset;\n        }\n        state.modifiersData[name] = data;\n    } // eslint-disable-next-line import/no-unused-modules\n    const preventOverflow$1 = {\n        name: \"preventOverflow\",\n        enabled: true,\n        phase: \"main\",\n        fn: preventOverflow,\n        requiresIfExists: [\n            \"offset\"\n        ]\n    };\n    function getHTMLElementScroll(element) {\n        return {\n            scrollLeft: element.scrollLeft,\n            scrollTop: element.scrollTop\n        };\n    }\n    function getNodeScroll(node) {\n        if (node === getWindow(node) || !isHTMLElement(node)) {\n            return getWindowScroll(node);\n        } else {\n            return getHTMLElementScroll(node);\n        }\n    }\n    function isElementScaled(element) {\n        var rect = element.getBoundingClientRect();\n        var scaleX = round(rect.width) / element.offsetWidth || 1;\n        var scaleY = round(rect.height) / element.offsetHeight || 1;\n        return scaleX !== 1 || scaleY !== 1;\n    } // Returns the composite rect of an element relative to its offsetParent.\n    // Composite means it takes into account transforms as well as layout.\n    function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\n        if (isFixed === void 0) {\n            isFixed = false;\n        }\n        var isOffsetParentAnElement = isHTMLElement(offsetParent);\n        var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);\n        var documentElement = getDocumentElement(offsetParent);\n        var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);\n        var scroll = {\n            scrollLeft: 0,\n            scrollTop: 0\n        };\n        var offsets = {\n            x: 0,\n            y: 0\n        };\n        if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\n            if (getNodeName(offsetParent) !== \"body\" || // https://github.com/popperjs/popper-core/issues/1078\n            isScrollParent(documentElement)) {\n                scroll = getNodeScroll(offsetParent);\n            }\n            if (isHTMLElement(offsetParent)) {\n                offsets = getBoundingClientRect(offsetParent, true);\n                offsets.x += offsetParent.clientLeft;\n                offsets.y += offsetParent.clientTop;\n            } else if (documentElement) {\n                offsets.x = getWindowScrollBarX(documentElement);\n            }\n        }\n        return {\n            x: rect.left + scroll.scrollLeft - offsets.x,\n            y: rect.top + scroll.scrollTop - offsets.y,\n            width: rect.width,\n            height: rect.height\n        };\n    }\n    function order(modifiers) {\n        var map = new Map();\n        var visited = new Set();\n        var result = [];\n        modifiers.forEach(function(modifier) {\n            map.set(modifier.name, modifier);\n        }); // On visiting object, check for its dependencies and visit them recursively\n        function sort(modifier) {\n            visited.add(modifier.name);\n            var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\n            requires.forEach(function(dep) {\n                if (!visited.has(dep)) {\n                    var depModifier = map.get(dep);\n                    if (depModifier) {\n                        sort(depModifier);\n                    }\n                }\n            });\n            result.push(modifier);\n        }\n        modifiers.forEach(function(modifier) {\n            if (!visited.has(modifier.name)) {\n                // check for visited object\n                sort(modifier);\n            }\n        });\n        return result;\n    }\n    function orderModifiers(modifiers) {\n        // order based on dependencies\n        var orderedModifiers = order(modifiers); // order based on phase\n        return modifierPhases.reduce(function(acc, phase) {\n            return acc.concat(orderedModifiers.filter(function(modifier) {\n                return modifier.phase === phase;\n            }));\n        }, []);\n    }\n    function debounce(fn) {\n        var pending;\n        return function() {\n            if (!pending) {\n                pending = new Promise(function(resolve) {\n                    Promise.resolve().then(function() {\n                        pending = undefined;\n                        resolve(fn());\n                    });\n                });\n            }\n            return pending;\n        };\n    }\n    function mergeByName(modifiers) {\n        var merged = modifiers.reduce(function(merged, current) {\n            var existing = merged[current.name];\n            merged[current.name] = existing ? Object.assign({}, existing, current, {\n                options: Object.assign({}, existing.options, current.options),\n                data: Object.assign({}, existing.data, current.data)\n            }) : current;\n            return merged;\n        }, {}); // IE11 does not support Object.values\n        return Object.keys(merged).map(function(key) {\n            return merged[key];\n        });\n    }\n    var DEFAULT_OPTIONS = {\n        placement: \"bottom\",\n        modifiers: [],\n        strategy: \"absolute\"\n    };\n    function areValidElements() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        return !args.some(function(element) {\n            return !(element && typeof element.getBoundingClientRect === \"function\");\n        });\n    }\n    function popperGenerator(generatorOptions) {\n        if (generatorOptions === void 0) {\n            generatorOptions = {};\n        }\n        var _generatorOptions = generatorOptions, _generatorOptions$def = _generatorOptions.defaultModifiers, defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def, _generatorOptions$def2 = _generatorOptions.defaultOptions, defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\n        return function createPopper(reference, popper, options) {\n            if (options === void 0) {\n                options = defaultOptions;\n            }\n            var state = {\n                placement: \"bottom\",\n                orderedModifiers: [],\n                options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\n                modifiersData: {},\n                elements: {\n                    reference: reference,\n                    popper: popper\n                },\n                attributes: {},\n                styles: {}\n            };\n            var effectCleanupFns = [];\n            var isDestroyed = false;\n            var instance = {\n                state: state,\n                setOptions: function setOptions(setOptionsAction) {\n                    var options = typeof setOptionsAction === \"function\" ? setOptionsAction(state.options) : setOptionsAction;\n                    cleanupModifierEffects();\n                    state.options = Object.assign({}, defaultOptions, state.options, options);\n                    state.scrollParents = {\n                        reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],\n                        popper: listScrollParents(popper)\n                    }; // Orders the modifiers based on their dependencies and `phase`\n                    // properties\n                    var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\n                    state.orderedModifiers = orderedModifiers.filter(function(m) {\n                        return m.enabled;\n                    });\n                    runModifierEffects();\n                    return instance.update();\n                },\n                // Sync update – it will always be executed, even if not necessary. This\n                // is useful for low frequency updates where sync behavior simplifies the\n                // logic.\n                // For high frequency updates (e.g. `resize` and `scroll` events), always\n                // prefer the async Popper#update method\n                forceUpdate: function forceUpdate() {\n                    if (isDestroyed) {\n                        return;\n                    }\n                    var _state$elements = state.elements, reference = _state$elements.reference, popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\n                    // anymore\n                    if (!areValidElements(reference, popper)) {\n                        return;\n                    } // Store the reference and popper rects to be read by modifiers\n                    state.rects = {\n                        reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === \"fixed\"),\n                        popper: getLayoutRect(popper)\n                    }; // Modifiers have the ability to reset the current update cycle. The\n                    // most common use case for this is the `flip` modifier changing the\n                    // placement, which then needs to re-run all the modifiers, because the\n                    // logic was previously ran for the previous placement and is therefore\n                    // stale/incorrect\n                    state.reset = false;\n                    state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\n                    // is filled with the initial data specified by the modifier. This means\n                    // it doesn't persist and is fresh on each update.\n                    // To ensure persistent data, use `${name}#persistent`\n                    state.orderedModifiers.forEach(function(modifier) {\n                        return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\n                    });\n                    for(var index = 0; index < state.orderedModifiers.length; index++){\n                        if (state.reset === true) {\n                            state.reset = false;\n                            index = -1;\n                            continue;\n                        }\n                        var _state$orderedModifie = state.orderedModifiers[index], fn = _state$orderedModifie.fn, _state$orderedModifie2 = _state$orderedModifie.options, _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2, name = _state$orderedModifie.name;\n                        if (typeof fn === \"function\") {\n                            state = fn({\n                                state: state,\n                                options: _options,\n                                name: name,\n                                instance: instance\n                            }) || state;\n                        }\n                    }\n                },\n                // Async and optimistically optimized update – it will not be executed if\n                // not necessary (debounced to run at most once-per-tick)\n                update: debounce(function() {\n                    return new Promise(function(resolve) {\n                        instance.forceUpdate();\n                        resolve(state);\n                    });\n                }),\n                destroy: function destroy() {\n                    cleanupModifierEffects();\n                    isDestroyed = true;\n                }\n            };\n            if (!areValidElements(reference, popper)) {\n                return instance;\n            }\n            instance.setOptions(options).then(function(state) {\n                if (!isDestroyed && options.onFirstUpdate) {\n                    options.onFirstUpdate(state);\n                }\n            }); // Modifiers have the ability to execute arbitrary code before the first\n            // update cycle runs. They will be executed in the same order as the update\n            // cycle. This is useful when a modifier adds some persistent data that\n            // other modifiers need to use, but the modifier is run after the dependent\n            // one.\n            function runModifierEffects() {\n                state.orderedModifiers.forEach(function(_ref) {\n                    var name = _ref.name, _ref$options = _ref.options, options = _ref$options === void 0 ? {} : _ref$options, effect = _ref.effect;\n                    if (typeof effect === \"function\") {\n                        var cleanupFn = effect({\n                            state: state,\n                            name: name,\n                            instance: instance,\n                            options: options\n                        });\n                        var noopFn = function noopFn() {};\n                        effectCleanupFns.push(cleanupFn || noopFn);\n                    }\n                });\n            }\n            function cleanupModifierEffects() {\n                effectCleanupFns.forEach(function(fn) {\n                    return fn();\n                });\n                effectCleanupFns = [];\n            }\n            return instance;\n        };\n    }\n    var createPopper$2 = /*#__PURE__*/ popperGenerator(); // eslint-disable-next-line import/no-unused-modules\n    var defaultModifiers$1 = [\n        eventListeners,\n        popperOffsets$1,\n        computeStyles$1,\n        applyStyles$1\n    ];\n    var createPopper$1 = /*#__PURE__*/ popperGenerator({\n        defaultModifiers: defaultModifiers$1\n    }); // eslint-disable-next-line import/no-unused-modules\n    var defaultModifiers = [\n        eventListeners,\n        popperOffsets$1,\n        computeStyles$1,\n        applyStyles$1,\n        offset$1,\n        flip$1,\n        preventOverflow$1,\n        arrow$1,\n        hide$1\n    ];\n    var createPopper = /*#__PURE__*/ popperGenerator({\n        defaultModifiers: defaultModifiers\n    }); // eslint-disable-next-line import/no-unused-modules\n    const Popper = /*#__PURE__*/ Object.freeze(/*#__PURE__*/ Object.defineProperty({\n        __proto__: null,\n        afterMain,\n        afterRead,\n        afterWrite,\n        applyStyles: applyStyles$1,\n        arrow: arrow$1,\n        auto,\n        basePlacements,\n        beforeMain,\n        beforeRead,\n        beforeWrite,\n        bottom,\n        clippingParents,\n        computeStyles: computeStyles$1,\n        createPopper,\n        createPopperBase: createPopper$2,\n        createPopperLite: createPopper$1,\n        detectOverflow,\n        end,\n        eventListeners,\n        flip: flip$1,\n        hide: hide$1,\n        left,\n        main,\n        modifierPhases,\n        offset: offset$1,\n        placements,\n        popper,\n        popperGenerator,\n        popperOffsets: popperOffsets$1,\n        preventOverflow: preventOverflow$1,\n        read,\n        reference,\n        right,\n        start,\n        top,\n        variationPlacements,\n        viewport,\n        write\n    }, Symbol.toStringTag, {\n        value: \"Module\"\n    }));\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap dropdown.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$a = \"dropdown\";\n    const DATA_KEY$6 = \"bs.dropdown\";\n    const EVENT_KEY$6 = `.${DATA_KEY$6}`;\n    const DATA_API_KEY$3 = \".data-api\";\n    const ESCAPE_KEY$2 = \"Escape\";\n    const TAB_KEY$1 = \"Tab\";\n    const ARROW_UP_KEY$1 = \"ArrowUp\";\n    const ARROW_DOWN_KEY$1 = \"ArrowDown\";\n    const RIGHT_MOUSE_BUTTON = 2; // MouseEvent.button value for the secondary button, usually the right button\n    const EVENT_HIDE$5 = `hide${EVENT_KEY$6}`;\n    const EVENT_HIDDEN$5 = `hidden${EVENT_KEY$6}`;\n    const EVENT_SHOW$5 = `show${EVENT_KEY$6}`;\n    const EVENT_SHOWN$5 = `shown${EVENT_KEY$6}`;\n    const EVENT_CLICK_DATA_API$3 = `click${EVENT_KEY$6}${DATA_API_KEY$3}`;\n    const EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY$6}${DATA_API_KEY$3}`;\n    const EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY$6}${DATA_API_KEY$3}`;\n    const CLASS_NAME_SHOW$6 = \"show\";\n    const CLASS_NAME_DROPUP = \"dropup\";\n    const CLASS_NAME_DROPEND = \"dropend\";\n    const CLASS_NAME_DROPSTART = \"dropstart\";\n    const CLASS_NAME_DROPUP_CENTER = \"dropup-center\";\n    const CLASS_NAME_DROPDOWN_CENTER = \"dropdown-center\";\n    const SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle=\"dropdown\"]:not(.disabled):not(:disabled)';\n    const SELECTOR_DATA_TOGGLE_SHOWN = `${SELECTOR_DATA_TOGGLE$3}.${CLASS_NAME_SHOW$6}`;\n    const SELECTOR_MENU = \".dropdown-menu\";\n    const SELECTOR_NAVBAR = \".navbar\";\n    const SELECTOR_NAVBAR_NAV = \".navbar-nav\";\n    const SELECTOR_VISIBLE_ITEMS = \".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)\";\n    const PLACEMENT_TOP = isRTL() ? \"top-end\" : \"top-start\";\n    const PLACEMENT_TOPEND = isRTL() ? \"top-start\" : \"top-end\";\n    const PLACEMENT_BOTTOM = isRTL() ? \"bottom-end\" : \"bottom-start\";\n    const PLACEMENT_BOTTOMEND = isRTL() ? \"bottom-start\" : \"bottom-end\";\n    const PLACEMENT_RIGHT = isRTL() ? \"left-start\" : \"right-start\";\n    const PLACEMENT_LEFT = isRTL() ? \"right-start\" : \"left-start\";\n    const PLACEMENT_TOPCENTER = \"top\";\n    const PLACEMENT_BOTTOMCENTER = \"bottom\";\n    const Default$9 = {\n        autoClose: true,\n        boundary: \"clippingParents\",\n        display: \"dynamic\",\n        offset: [\n            0,\n            2\n        ],\n        popperConfig: null,\n        reference: \"toggle\"\n    };\n    const DefaultType$9 = {\n        autoClose: \"(boolean|string)\",\n        boundary: \"(string|element)\",\n        display: \"string\",\n        offset: \"(array|string|function)\",\n        popperConfig: \"(null|object|function)\",\n        reference: \"(string|element|object)\"\n    };\n    /**\n   * Class definition\n   */ class Dropdown extends BaseComponent {\n        constructor(element, config){\n            super(element, config);\n            this._popper = null;\n            this._parent = this._element.parentNode; // dropdown wrapper\n            // TODO: v6 revert #37011 & change markup https://getbootstrap.com/docs/5.3/forms/input-group/\n            this._menu = SelectorEngine.next(this._element, SELECTOR_MENU)[0] || SelectorEngine.prev(this._element, SELECTOR_MENU)[0] || SelectorEngine.findOne(SELECTOR_MENU, this._parent);\n            this._inNavbar = this._detectNavbar();\n        }\n        // Getters\n        static get Default() {\n            return Default$9;\n        }\n        static get DefaultType() {\n            return DefaultType$9;\n        }\n        static get NAME() {\n            return NAME$a;\n        }\n        // Public\n        toggle() {\n            return this._isShown() ? this.hide() : this.show();\n        }\n        show() {\n            if (isDisabled(this._element) || this._isShown()) {\n                return;\n            }\n            const relatedTarget = {\n                relatedTarget: this._element\n            };\n            const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$5, relatedTarget);\n            if (showEvent.defaultPrevented) {\n                return;\n            }\n            this._createPopper();\n            // If this is a touch-enabled device we add extra\n            // empty mouseover listeners to the body's immediate children;\n            // only needed because of broken event delegation on iOS\n            // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n            if (\"ontouchstart\" in document.documentElement && !this._parent.closest(SELECTOR_NAVBAR_NAV)) {\n                for (const element of [].concat(...document.body.children)){\n                    EventHandler.on(element, \"mouseover\", noop);\n                }\n            }\n            this._element.focus();\n            this._element.setAttribute(\"aria-expanded\", true);\n            this._menu.classList.add(CLASS_NAME_SHOW$6);\n            this._element.classList.add(CLASS_NAME_SHOW$6);\n            EventHandler.trigger(this._element, EVENT_SHOWN$5, relatedTarget);\n        }\n        hide() {\n            if (isDisabled(this._element) || !this._isShown()) {\n                return;\n            }\n            const relatedTarget = {\n                relatedTarget: this._element\n            };\n            this._completeHide(relatedTarget);\n        }\n        dispose() {\n            if (this._popper) {\n                this._popper.destroy();\n            }\n            super.dispose();\n        }\n        update() {\n            this._inNavbar = this._detectNavbar();\n            if (this._popper) {\n                this._popper.update();\n            }\n        }\n        // Private\n        _completeHide(relatedTarget) {\n            const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$5, relatedTarget);\n            if (hideEvent.defaultPrevented) {\n                return;\n            }\n            // If this is a touch-enabled device we remove the extra\n            // empty mouseover listeners we added for iOS support\n            if (\"ontouchstart\" in document.documentElement) {\n                for (const element of [].concat(...document.body.children)){\n                    EventHandler.off(element, \"mouseover\", noop);\n                }\n            }\n            if (this._popper) {\n                this._popper.destroy();\n            }\n            this._menu.classList.remove(CLASS_NAME_SHOW$6);\n            this._element.classList.remove(CLASS_NAME_SHOW$6);\n            this._element.setAttribute(\"aria-expanded\", \"false\");\n            Manipulator.removeDataAttribute(this._menu, \"popper\");\n            EventHandler.trigger(this._element, EVENT_HIDDEN$5, relatedTarget);\n        }\n        _getConfig(config) {\n            config = super._getConfig(config);\n            if (typeof config.reference === \"object\" && !isElement$1(config.reference) && typeof config.reference.getBoundingClientRect !== \"function\") {\n                // Popper virtual elements require a getBoundingClientRect method\n                throw new TypeError(`${NAME$a.toUpperCase()}: Option \"reference\" provided type \"object\" without a required \"getBoundingClientRect\" method.`);\n            }\n            return config;\n        }\n        _createPopper() {\n            if (typeof Popper === \"undefined\") {\n                throw new TypeError(\"Bootstrap's dropdowns require Popper (https://popper.js.org)\");\n            }\n            let referenceElement = this._element;\n            if (this._config.reference === \"parent\") {\n                referenceElement = this._parent;\n            } else if (isElement$1(this._config.reference)) {\n                referenceElement = getElement(this._config.reference);\n            } else if (typeof this._config.reference === \"object\") {\n                referenceElement = this._config.reference;\n            }\n            const popperConfig = this._getPopperConfig();\n            this._popper = createPopper(referenceElement, this._menu, popperConfig);\n        }\n        _isShown() {\n            return this._menu.classList.contains(CLASS_NAME_SHOW$6);\n        }\n        _getPlacement() {\n            const parentDropdown = this._parent;\n            if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {\n                return PLACEMENT_RIGHT;\n            }\n            if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {\n                return PLACEMENT_LEFT;\n            }\n            if (parentDropdown.classList.contains(CLASS_NAME_DROPUP_CENTER)) {\n                return PLACEMENT_TOPCENTER;\n            }\n            if (parentDropdown.classList.contains(CLASS_NAME_DROPDOWN_CENTER)) {\n                return PLACEMENT_BOTTOMCENTER;\n            }\n            // We need to trim the value because custom properties can also include spaces\n            const isEnd = getComputedStyle(this._menu).getPropertyValue(\"--bs-position\").trim() === \"end\";\n            if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {\n                return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;\n            }\n            return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;\n        }\n        _detectNavbar() {\n            return this._element.closest(SELECTOR_NAVBAR) !== null;\n        }\n        _getOffset() {\n            const { offset } = this._config;\n            if (typeof offset === \"string\") {\n                return offset.split(\",\").map((value)=>Number.parseInt(value, 10));\n            }\n            if (typeof offset === \"function\") {\n                return (popperData)=>offset(popperData, this._element);\n            }\n            return offset;\n        }\n        _getPopperConfig() {\n            const defaultBsPopperConfig = {\n                placement: this._getPlacement(),\n                modifiers: [\n                    {\n                        name: \"preventOverflow\",\n                        options: {\n                            boundary: this._config.boundary\n                        }\n                    },\n                    {\n                        name: \"offset\",\n                        options: {\n                            offset: this._getOffset()\n                        }\n                    }\n                ]\n            };\n            // Disable Popper if we have a static display or Dropdown is in Navbar\n            if (this._inNavbar || this._config.display === \"static\") {\n                Manipulator.setDataAttribute(this._menu, \"popper\", \"static\"); // TODO: v6 remove\n                defaultBsPopperConfig.modifiers = [\n                    {\n                        name: \"applyStyles\",\n                        enabled: false\n                    }\n                ];\n            }\n            return {\n                ...defaultBsPopperConfig,\n                ...execute(this._config.popperConfig, [\n                    defaultBsPopperConfig\n                ])\n            };\n        }\n        _selectMenuItem({ key, target }) {\n            const items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter((element)=>isVisible(element));\n            if (!items.length) {\n                return;\n            }\n            // if target isn't included in items (e.g. when expanding the dropdown)\n            // allow cycling to get the last item in case key equals ARROW_UP_KEY\n            getNextActiveElement(items, target, key === ARROW_DOWN_KEY$1, !items.includes(target)).focus();\n        }\n        // Static\n        static jQueryInterface(config) {\n            return this.each(function() {\n                const data = Dropdown.getOrCreateInstance(this, config);\n                if (typeof config !== \"string\") {\n                    return;\n                }\n                if (typeof data[config] === \"undefined\") {\n                    throw new TypeError(`No method named \"${config}\"`);\n                }\n                data[config]();\n            });\n        }\n        static clearMenus(event) {\n            if (event.button === RIGHT_MOUSE_BUTTON || event.type === \"keyup\" && event.key !== TAB_KEY$1) {\n                return;\n            }\n            const openToggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE_SHOWN);\n            for (const toggle of openToggles){\n                const context = Dropdown.getInstance(toggle);\n                if (!context || context._config.autoClose === false) {\n                    continue;\n                }\n                const composedPath = event.composedPath();\n                const isMenuTarget = composedPath.includes(context._menu);\n                if (composedPath.includes(context._element) || context._config.autoClose === \"inside\" && !isMenuTarget || context._config.autoClose === \"outside\" && isMenuTarget) {\n                    continue;\n                }\n                // Tab navigation through the dropdown menu or events from contained inputs shouldn't close the menu\n                if (context._menu.contains(event.target) && (event.type === \"keyup\" && event.key === TAB_KEY$1 || /input|select|option|textarea|form/i.test(event.target.tagName))) {\n                    continue;\n                }\n                const relatedTarget = {\n                    relatedTarget: context._element\n                };\n                if (event.type === \"click\") {\n                    relatedTarget.clickEvent = event;\n                }\n                context._completeHide(relatedTarget);\n            }\n        }\n        static dataApiKeydownHandler(event) {\n            // If not an UP | DOWN | ESCAPE key => not a dropdown command\n            // If input/textarea && if key is other than ESCAPE => not a dropdown command\n            const isInput = /input|textarea/i.test(event.target.tagName);\n            const isEscapeEvent = event.key === ESCAPE_KEY$2;\n            const isUpOrDownEvent = [\n                ARROW_UP_KEY$1,\n                ARROW_DOWN_KEY$1\n            ].includes(event.key);\n            if (!isUpOrDownEvent && !isEscapeEvent) {\n                return;\n            }\n            if (isInput && !isEscapeEvent) {\n                return;\n            }\n            event.preventDefault();\n            // TODO: v6 revert #37011 & change markup https://getbootstrap.com/docs/5.3/forms/input-group/\n            const getToggleButton = this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.next(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.findOne(SELECTOR_DATA_TOGGLE$3, event.delegateTarget.parentNode);\n            const instance = Dropdown.getOrCreateInstance(getToggleButton);\n            if (isUpOrDownEvent) {\n                event.stopPropagation();\n                instance.show();\n                instance._selectMenuItem(event);\n                return;\n            }\n            if (instance._isShown()) {\n                // else is escape and we check if it is shown\n                event.stopPropagation();\n                instance.hide();\n                getToggleButton.focus();\n            }\n        }\n    }\n    /**\n   * Data API implementation\n   */ EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);\n    EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);\n    EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);\n    EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);\n    EventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function(event) {\n        event.preventDefault();\n        Dropdown.getOrCreateInstance(this).toggle();\n    });\n    /**\n   * jQuery\n   */ defineJQueryPlugin(Dropdown);\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap util/backdrop.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$9 = \"backdrop\";\n    const CLASS_NAME_FADE$4 = \"fade\";\n    const CLASS_NAME_SHOW$5 = \"show\";\n    const EVENT_MOUSEDOWN = `mousedown.bs.${NAME$9}`;\n    const Default$8 = {\n        className: \"modal-backdrop\",\n        clickCallback: null,\n        isAnimated: false,\n        isVisible: true,\n        // if false, we use the backdrop helper without adding any element to the dom\n        rootElement: \"body\" // give the choice to place backdrop under different elements\n    };\n    const DefaultType$8 = {\n        className: \"string\",\n        clickCallback: \"(function|null)\",\n        isAnimated: \"boolean\",\n        isVisible: \"boolean\",\n        rootElement: \"(element|string)\"\n    };\n    /**\n   * Class definition\n   */ class Backdrop extends Config {\n        constructor(config){\n            super();\n            this._config = this._getConfig(config);\n            this._isAppended = false;\n            this._element = null;\n        }\n        // Getters\n        static get Default() {\n            return Default$8;\n        }\n        static get DefaultType() {\n            return DefaultType$8;\n        }\n        static get NAME() {\n            return NAME$9;\n        }\n        // Public\n        show(callback) {\n            if (!this._config.isVisible) {\n                execute(callback);\n                return;\n            }\n            this._append();\n            const element = this._getElement();\n            if (this._config.isAnimated) {\n                reflow(element);\n            }\n            element.classList.add(CLASS_NAME_SHOW$5);\n            this._emulateAnimation(()=>{\n                execute(callback);\n            });\n        }\n        hide(callback) {\n            if (!this._config.isVisible) {\n                execute(callback);\n                return;\n            }\n            this._getElement().classList.remove(CLASS_NAME_SHOW$5);\n            this._emulateAnimation(()=>{\n                this.dispose();\n                execute(callback);\n            });\n        }\n        dispose() {\n            if (!this._isAppended) {\n                return;\n            }\n            EventHandler.off(this._element, EVENT_MOUSEDOWN);\n            this._element.remove();\n            this._isAppended = false;\n        }\n        // Private\n        _getElement() {\n            if (!this._element) {\n                const backdrop = document.createElement(\"div\");\n                backdrop.className = this._config.className;\n                if (this._config.isAnimated) {\n                    backdrop.classList.add(CLASS_NAME_FADE$4);\n                }\n                this._element = backdrop;\n            }\n            return this._element;\n        }\n        _configAfterMerge(config) {\n            // use getElement() with the default \"body\" to get a fresh Element on each instantiation\n            config.rootElement = getElement(config.rootElement);\n            return config;\n        }\n        _append() {\n            if (this._isAppended) {\n                return;\n            }\n            const element = this._getElement();\n            this._config.rootElement.append(element);\n            EventHandler.on(element, EVENT_MOUSEDOWN, ()=>{\n                execute(this._config.clickCallback);\n            });\n            this._isAppended = true;\n        }\n        _emulateAnimation(callback) {\n            executeAfterTransition(callback, this._getElement(), this._config.isAnimated);\n        }\n    }\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap util/focustrap.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$8 = \"focustrap\";\n    const DATA_KEY$5 = \"bs.focustrap\";\n    const EVENT_KEY$5 = `.${DATA_KEY$5}`;\n    const EVENT_FOCUSIN$2 = `focusin${EVENT_KEY$5}`;\n    const EVENT_KEYDOWN_TAB = `keydown.tab${EVENT_KEY$5}`;\n    const TAB_KEY = \"Tab\";\n    const TAB_NAV_FORWARD = \"forward\";\n    const TAB_NAV_BACKWARD = \"backward\";\n    const Default$7 = {\n        autofocus: true,\n        trapElement: null // The element to trap focus inside of\n    };\n    const DefaultType$7 = {\n        autofocus: \"boolean\",\n        trapElement: \"element\"\n    };\n    /**\n   * Class definition\n   */ class FocusTrap extends Config {\n        constructor(config){\n            super();\n            this._config = this._getConfig(config);\n            this._isActive = false;\n            this._lastTabNavDirection = null;\n        }\n        // Getters\n        static get Default() {\n            return Default$7;\n        }\n        static get DefaultType() {\n            return DefaultType$7;\n        }\n        static get NAME() {\n            return NAME$8;\n        }\n        // Public\n        activate() {\n            if (this._isActive) {\n                return;\n            }\n            if (this._config.autofocus) {\n                this._config.trapElement.focus();\n            }\n            EventHandler.off(document, EVENT_KEY$5); // guard against infinite focus loop\n            EventHandler.on(document, EVENT_FOCUSIN$2, (event)=>this._handleFocusin(event));\n            EventHandler.on(document, EVENT_KEYDOWN_TAB, (event)=>this._handleKeydown(event));\n            this._isActive = true;\n        }\n        deactivate() {\n            if (!this._isActive) {\n                return;\n            }\n            this._isActive = false;\n            EventHandler.off(document, EVENT_KEY$5);\n        }\n        // Private\n        _handleFocusin(event) {\n            const { trapElement } = this._config;\n            if (event.target === document || event.target === trapElement || trapElement.contains(event.target)) {\n                return;\n            }\n            const elements = SelectorEngine.focusableChildren(trapElement);\n            if (elements.length === 0) {\n                trapElement.focus();\n            } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {\n                elements[elements.length - 1].focus();\n            } else {\n                elements[0].focus();\n            }\n        }\n        _handleKeydown(event) {\n            if (event.key !== TAB_KEY) {\n                return;\n            }\n            this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;\n        }\n    }\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap util/scrollBar.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const SELECTOR_FIXED_CONTENT = \".fixed-top, .fixed-bottom, .is-fixed, .sticky-top\";\n    const SELECTOR_STICKY_CONTENT = \".sticky-top\";\n    const PROPERTY_PADDING = \"padding-right\";\n    const PROPERTY_MARGIN = \"margin-right\";\n    /**\n   * Class definition\n   */ class ScrollBarHelper {\n        constructor(){\n            this._element = document.body;\n        }\n        // Public\n        getWidth() {\n            // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes\n            const documentWidth = document.documentElement.clientWidth;\n            return Math.abs(window.innerWidth - documentWidth);\n        }\n        hide() {\n            const width = this.getWidth();\n            this._disableOverFlow();\n            // give padding to element to balance the hidden scrollbar width\n            this._setElementAttributes(this._element, PROPERTY_PADDING, (calculatedValue)=>calculatedValue + width);\n            // trick: We adjust positive paddingRight and negative marginRight to sticky-top elements to keep showing fullwidth\n            this._setElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING, (calculatedValue)=>calculatedValue + width);\n            this._setElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN, (calculatedValue)=>calculatedValue - width);\n        }\n        reset() {\n            this._resetElementAttributes(this._element, \"overflow\");\n            this._resetElementAttributes(this._element, PROPERTY_PADDING);\n            this._resetElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING);\n            this._resetElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN);\n        }\n        isOverflowing() {\n            return this.getWidth() > 0;\n        }\n        // Private\n        _disableOverFlow() {\n            this._saveInitialAttribute(this._element, \"overflow\");\n            this._element.style.overflow = \"hidden\";\n        }\n        _setElementAttributes(selector, styleProperty, callback) {\n            const scrollbarWidth = this.getWidth();\n            const manipulationCallBack = (element)=>{\n                if (element !== this._element && window.innerWidth > element.clientWidth + scrollbarWidth) {\n                    return;\n                }\n                this._saveInitialAttribute(element, styleProperty);\n                const calculatedValue = window.getComputedStyle(element).getPropertyValue(styleProperty);\n                element.style.setProperty(styleProperty, `${callback(Number.parseFloat(calculatedValue))}px`);\n            };\n            this._applyManipulationCallback(selector, manipulationCallBack);\n        }\n        _saveInitialAttribute(element, styleProperty) {\n            const actualValue = element.style.getPropertyValue(styleProperty);\n            if (actualValue) {\n                Manipulator.setDataAttribute(element, styleProperty, actualValue);\n            }\n        }\n        _resetElementAttributes(selector, styleProperty) {\n            const manipulationCallBack = (element)=>{\n                const value = Manipulator.getDataAttribute(element, styleProperty);\n                // We only want to remove the property if the value is `null`; the value can also be zero\n                if (value === null) {\n                    element.style.removeProperty(styleProperty);\n                    return;\n                }\n                Manipulator.removeDataAttribute(element, styleProperty);\n                element.style.setProperty(styleProperty, value);\n            };\n            this._applyManipulationCallback(selector, manipulationCallBack);\n        }\n        _applyManipulationCallback(selector, callBack) {\n            if (isElement$1(selector)) {\n                callBack(selector);\n                return;\n            }\n            for (const sel of SelectorEngine.find(selector, this._element)){\n                callBack(sel);\n            }\n        }\n    }\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap modal.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$7 = \"modal\";\n    const DATA_KEY$4 = \"bs.modal\";\n    const EVENT_KEY$4 = `.${DATA_KEY$4}`;\n    const DATA_API_KEY$2 = \".data-api\";\n    const ESCAPE_KEY$1 = \"Escape\";\n    const EVENT_HIDE$4 = `hide${EVENT_KEY$4}`;\n    const EVENT_HIDE_PREVENTED$1 = `hidePrevented${EVENT_KEY$4}`;\n    const EVENT_HIDDEN$4 = `hidden${EVENT_KEY$4}`;\n    const EVENT_SHOW$4 = `show${EVENT_KEY$4}`;\n    const EVENT_SHOWN$4 = `shown${EVENT_KEY$4}`;\n    const EVENT_RESIZE$1 = `resize${EVENT_KEY$4}`;\n    const EVENT_CLICK_DISMISS = `click.dismiss${EVENT_KEY$4}`;\n    const EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY$4}`;\n    const EVENT_KEYDOWN_DISMISS$1 = `keydown.dismiss${EVENT_KEY$4}`;\n    const EVENT_CLICK_DATA_API$2 = `click${EVENT_KEY$4}${DATA_API_KEY$2}`;\n    const CLASS_NAME_OPEN = \"modal-open\";\n    const CLASS_NAME_FADE$3 = \"fade\";\n    const CLASS_NAME_SHOW$4 = \"show\";\n    const CLASS_NAME_STATIC = \"modal-static\";\n    const OPEN_SELECTOR$1 = \".modal.show\";\n    const SELECTOR_DIALOG = \".modal-dialog\";\n    const SELECTOR_MODAL_BODY = \".modal-body\";\n    const SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle=\"modal\"]';\n    const Default$6 = {\n        backdrop: true,\n        focus: true,\n        keyboard: true\n    };\n    const DefaultType$6 = {\n        backdrop: \"(boolean|string)\",\n        focus: \"boolean\",\n        keyboard: \"boolean\"\n    };\n    /**\n   * Class definition\n   */ class Modal extends BaseComponent {\n        constructor(element, config){\n            super(element, config);\n            this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);\n            this._backdrop = this._initializeBackDrop();\n            this._focustrap = this._initializeFocusTrap();\n            this._isShown = false;\n            this._isTransitioning = false;\n            this._scrollBar = new ScrollBarHelper();\n            this._addEventListeners();\n        }\n        // Getters\n        static get Default() {\n            return Default$6;\n        }\n        static get DefaultType() {\n            return DefaultType$6;\n        }\n        static get NAME() {\n            return NAME$7;\n        }\n        // Public\n        toggle(relatedTarget) {\n            return this._isShown ? this.hide() : this.show(relatedTarget);\n        }\n        show(relatedTarget) {\n            if (this._isShown || this._isTransitioning) {\n                return;\n            }\n            const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, {\n                relatedTarget\n            });\n            if (showEvent.defaultPrevented) {\n                return;\n            }\n            this._isShown = true;\n            this._isTransitioning = true;\n            this._scrollBar.hide();\n            document.body.classList.add(CLASS_NAME_OPEN);\n            this._adjustDialog();\n            this._backdrop.show(()=>this._showElement(relatedTarget));\n        }\n        hide() {\n            if (!this._isShown || this._isTransitioning) {\n                return;\n            }\n            const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4);\n            if (hideEvent.defaultPrevented) {\n                return;\n            }\n            this._isShown = false;\n            this._isTransitioning = true;\n            this._focustrap.deactivate();\n            this._element.classList.remove(CLASS_NAME_SHOW$4);\n            this._queueCallback(()=>this._hideModal(), this._element, this._isAnimated());\n        }\n        dispose() {\n            EventHandler.off(window, EVENT_KEY$4);\n            EventHandler.off(this._dialog, EVENT_KEY$4);\n            this._backdrop.dispose();\n            this._focustrap.deactivate();\n            super.dispose();\n        }\n        handleUpdate() {\n            this._adjustDialog();\n        }\n        // Private\n        _initializeBackDrop() {\n            return new Backdrop({\n                isVisible: Boolean(this._config.backdrop),\n                // 'static' option will be translated to true, and booleans will keep their value,\n                isAnimated: this._isAnimated()\n            });\n        }\n        _initializeFocusTrap() {\n            return new FocusTrap({\n                trapElement: this._element\n            });\n        }\n        _showElement(relatedTarget) {\n            // try to append dynamic modal\n            if (!document.body.contains(this._element)) {\n                document.body.append(this._element);\n            }\n            this._element.style.display = \"block\";\n            this._element.removeAttribute(\"aria-hidden\");\n            this._element.setAttribute(\"aria-modal\", true);\n            this._element.setAttribute(\"role\", \"dialog\");\n            this._element.scrollTop = 0;\n            const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);\n            if (modalBody) {\n                modalBody.scrollTop = 0;\n            }\n            reflow(this._element);\n            this._element.classList.add(CLASS_NAME_SHOW$4);\n            const transitionComplete = ()=>{\n                if (this._config.focus) {\n                    this._focustrap.activate();\n                }\n                this._isTransitioning = false;\n                EventHandler.trigger(this._element, EVENT_SHOWN$4, {\n                    relatedTarget\n                });\n            };\n            this._queueCallback(transitionComplete, this._dialog, this._isAnimated());\n        }\n        _addEventListeners() {\n            EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, (event)=>{\n                if (event.key !== ESCAPE_KEY$1) {\n                    return;\n                }\n                if (this._config.keyboard) {\n                    this.hide();\n                    return;\n                }\n                this._triggerBackdropTransition();\n            });\n            EventHandler.on(window, EVENT_RESIZE$1, ()=>{\n                if (this._isShown && !this._isTransitioning) {\n                    this._adjustDialog();\n                }\n            });\n            EventHandler.on(this._element, EVENT_MOUSEDOWN_DISMISS, (event)=>{\n                // a bad trick to segregate clicks that may start inside dialog but end outside, and avoid listen to scrollbar clicks\n                EventHandler.one(this._element, EVENT_CLICK_DISMISS, (event2)=>{\n                    if (this._element !== event.target || this._element !== event2.target) {\n                        return;\n                    }\n                    if (this._config.backdrop === \"static\") {\n                        this._triggerBackdropTransition();\n                        return;\n                    }\n                    if (this._config.backdrop) {\n                        this.hide();\n                    }\n                });\n            });\n        }\n        _hideModal() {\n            this._element.style.display = \"none\";\n            this._element.setAttribute(\"aria-hidden\", true);\n            this._element.removeAttribute(\"aria-modal\");\n            this._element.removeAttribute(\"role\");\n            this._isTransitioning = false;\n            this._backdrop.hide(()=>{\n                document.body.classList.remove(CLASS_NAME_OPEN);\n                this._resetAdjustments();\n                this._scrollBar.reset();\n                EventHandler.trigger(this._element, EVENT_HIDDEN$4);\n            });\n        }\n        _isAnimated() {\n            return this._element.classList.contains(CLASS_NAME_FADE$3);\n        }\n        _triggerBackdropTransition() {\n            const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED$1);\n            if (hideEvent.defaultPrevented) {\n                return;\n            }\n            const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\n            const initialOverflowY = this._element.style.overflowY;\n            // return if the following background transition hasn't yet completed\n            if (initialOverflowY === \"hidden\" || this._element.classList.contains(CLASS_NAME_STATIC)) {\n                return;\n            }\n            if (!isModalOverflowing) {\n                this._element.style.overflowY = \"hidden\";\n            }\n            this._element.classList.add(CLASS_NAME_STATIC);\n            this._queueCallback(()=>{\n                this._element.classList.remove(CLASS_NAME_STATIC);\n                this._queueCallback(()=>{\n                    this._element.style.overflowY = initialOverflowY;\n                }, this._dialog);\n            }, this._dialog);\n            this._element.focus();\n        }\n        /**\n     * The following methods are used to handle overflowing modals\n     */ _adjustDialog() {\n            const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\n            const scrollbarWidth = this._scrollBar.getWidth();\n            const isBodyOverflowing = scrollbarWidth > 0;\n            if (isBodyOverflowing && !isModalOverflowing) {\n                const property = isRTL() ? \"paddingLeft\" : \"paddingRight\";\n                this._element.style[property] = `${scrollbarWidth}px`;\n            }\n            if (!isBodyOverflowing && isModalOverflowing) {\n                const property = isRTL() ? \"paddingRight\" : \"paddingLeft\";\n                this._element.style[property] = `${scrollbarWidth}px`;\n            }\n        }\n        _resetAdjustments() {\n            this._element.style.paddingLeft = \"\";\n            this._element.style.paddingRight = \"\";\n        }\n        // Static\n        static jQueryInterface(config, relatedTarget) {\n            return this.each(function() {\n                const data = Modal.getOrCreateInstance(this, config);\n                if (typeof config !== \"string\") {\n                    return;\n                }\n                if (typeof data[config] === \"undefined\") {\n                    throw new TypeError(`No method named \"${config}\"`);\n                }\n                data[config](relatedTarget);\n            });\n        }\n    }\n    /**\n   * Data API implementation\n   */ EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function(event) {\n        const target = SelectorEngine.getElementFromSelector(this);\n        if ([\n            \"A\",\n            \"AREA\"\n        ].includes(this.tagName)) {\n            event.preventDefault();\n        }\n        EventHandler.one(target, EVENT_SHOW$4, (showEvent)=>{\n            if (showEvent.defaultPrevented) {\n                // only register focus restorer if modal will actually get shown\n                return;\n            }\n            EventHandler.one(target, EVENT_HIDDEN$4, ()=>{\n                if (isVisible(this)) {\n                    this.focus();\n                }\n            });\n        });\n        // avoid conflict when clicking modal toggler while another one is open\n        const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR$1);\n        if (alreadyOpen) {\n            Modal.getInstance(alreadyOpen).hide();\n        }\n        const data = Modal.getOrCreateInstance(target);\n        data.toggle(this);\n    });\n    enableDismissTrigger(Modal);\n    /**\n   * jQuery\n   */ defineJQueryPlugin(Modal);\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap offcanvas.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$6 = \"offcanvas\";\n    const DATA_KEY$3 = \"bs.offcanvas\";\n    const EVENT_KEY$3 = `.${DATA_KEY$3}`;\n    const DATA_API_KEY$1 = \".data-api\";\n    const EVENT_LOAD_DATA_API$2 = `load${EVENT_KEY$3}${DATA_API_KEY$1}`;\n    const ESCAPE_KEY = \"Escape\";\n    const CLASS_NAME_SHOW$3 = \"show\";\n    const CLASS_NAME_SHOWING$1 = \"showing\";\n    const CLASS_NAME_HIDING = \"hiding\";\n    const CLASS_NAME_BACKDROP = \"offcanvas-backdrop\";\n    const OPEN_SELECTOR = \".offcanvas.show\";\n    const EVENT_SHOW$3 = `show${EVENT_KEY$3}`;\n    const EVENT_SHOWN$3 = `shown${EVENT_KEY$3}`;\n    const EVENT_HIDE$3 = `hide${EVENT_KEY$3}`;\n    const EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY$3}`;\n    const EVENT_HIDDEN$3 = `hidden${EVENT_KEY$3}`;\n    const EVENT_RESIZE = `resize${EVENT_KEY$3}`;\n    const EVENT_CLICK_DATA_API$1 = `click${EVENT_KEY$3}${DATA_API_KEY$1}`;\n    const EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY$3}`;\n    const SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle=\"offcanvas\"]';\n    const Default$5 = {\n        backdrop: true,\n        keyboard: true,\n        scroll: false\n    };\n    const DefaultType$5 = {\n        backdrop: \"(boolean|string)\",\n        keyboard: \"boolean\",\n        scroll: \"boolean\"\n    };\n    /**\n   * Class definition\n   */ class Offcanvas extends BaseComponent {\n        constructor(element, config){\n            super(element, config);\n            this._isShown = false;\n            this._backdrop = this._initializeBackDrop();\n            this._focustrap = this._initializeFocusTrap();\n            this._addEventListeners();\n        }\n        // Getters\n        static get Default() {\n            return Default$5;\n        }\n        static get DefaultType() {\n            return DefaultType$5;\n        }\n        static get NAME() {\n            return NAME$6;\n        }\n        // Public\n        toggle(relatedTarget) {\n            return this._isShown ? this.hide() : this.show(relatedTarget);\n        }\n        show(relatedTarget) {\n            if (this._isShown) {\n                return;\n            }\n            const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {\n                relatedTarget\n            });\n            if (showEvent.defaultPrevented) {\n                return;\n            }\n            this._isShown = true;\n            this._backdrop.show();\n            if (!this._config.scroll) {\n                new ScrollBarHelper().hide();\n            }\n            this._element.setAttribute(\"aria-modal\", true);\n            this._element.setAttribute(\"role\", \"dialog\");\n            this._element.classList.add(CLASS_NAME_SHOWING$1);\n            const completeCallBack = ()=>{\n                if (!this._config.scroll || this._config.backdrop) {\n                    this._focustrap.activate();\n                }\n                this._element.classList.add(CLASS_NAME_SHOW$3);\n                this._element.classList.remove(CLASS_NAME_SHOWING$1);\n                EventHandler.trigger(this._element, EVENT_SHOWN$3, {\n                    relatedTarget\n                });\n            };\n            this._queueCallback(completeCallBack, this._element, true);\n        }\n        hide() {\n            if (!this._isShown) {\n                return;\n            }\n            const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);\n            if (hideEvent.defaultPrevented) {\n                return;\n            }\n            this._focustrap.deactivate();\n            this._element.blur();\n            this._isShown = false;\n            this._element.classList.add(CLASS_NAME_HIDING);\n            this._backdrop.hide();\n            const completeCallback = ()=>{\n                this._element.classList.remove(CLASS_NAME_SHOW$3, CLASS_NAME_HIDING);\n                this._element.removeAttribute(\"aria-modal\");\n                this._element.removeAttribute(\"role\");\n                if (!this._config.scroll) {\n                    new ScrollBarHelper().reset();\n                }\n                EventHandler.trigger(this._element, EVENT_HIDDEN$3);\n            };\n            this._queueCallback(completeCallback, this._element, true);\n        }\n        dispose() {\n            this._backdrop.dispose();\n            this._focustrap.deactivate();\n            super.dispose();\n        }\n        // Private\n        _initializeBackDrop() {\n            const clickCallback = ()=>{\n                if (this._config.backdrop === \"static\") {\n                    EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);\n                    return;\n                }\n                this.hide();\n            };\n            // 'static' option will be translated to true, and booleans will keep their value\n            const isVisible = Boolean(this._config.backdrop);\n            return new Backdrop({\n                className: CLASS_NAME_BACKDROP,\n                isVisible,\n                isAnimated: true,\n                rootElement: this._element.parentNode,\n                clickCallback: isVisible ? clickCallback : null\n            });\n        }\n        _initializeFocusTrap() {\n            return new FocusTrap({\n                trapElement: this._element\n            });\n        }\n        _addEventListeners() {\n            EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, (event)=>{\n                if (event.key !== ESCAPE_KEY) {\n                    return;\n                }\n                if (this._config.keyboard) {\n                    this.hide();\n                    return;\n                }\n                EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);\n            });\n        }\n        // Static\n        static jQueryInterface(config) {\n            return this.each(function() {\n                const data = Offcanvas.getOrCreateInstance(this, config);\n                if (typeof config !== \"string\") {\n                    return;\n                }\n                if (data[config] === undefined || config.startsWith(\"_\") || config === \"constructor\") {\n                    throw new TypeError(`No method named \"${config}\"`);\n                }\n                data[config](this);\n            });\n        }\n    }\n    /**\n   * Data API implementation\n   */ EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function(event) {\n        const target = SelectorEngine.getElementFromSelector(this);\n        if ([\n            \"A\",\n            \"AREA\"\n        ].includes(this.tagName)) {\n            event.preventDefault();\n        }\n        if (isDisabled(this)) {\n            return;\n        }\n        EventHandler.one(target, EVENT_HIDDEN$3, ()=>{\n            // focus on trigger when it is closed\n            if (isVisible(this)) {\n                this.focus();\n            }\n        });\n        // avoid conflict when clicking a toggler of an offcanvas, while another is open\n        const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);\n        if (alreadyOpen && alreadyOpen !== target) {\n            Offcanvas.getInstance(alreadyOpen).hide();\n        }\n        const data = Offcanvas.getOrCreateInstance(target);\n        data.toggle(this);\n    });\n    EventHandler.on(window, EVENT_LOAD_DATA_API$2, ()=>{\n        for (const selector of SelectorEngine.find(OPEN_SELECTOR)){\n            Offcanvas.getOrCreateInstance(selector).show();\n        }\n    });\n    EventHandler.on(window, EVENT_RESIZE, ()=>{\n        for (const element of SelectorEngine.find(\"[aria-modal][class*=show][class*=offcanvas-]\")){\n            if (getComputedStyle(element).position !== \"fixed\") {\n                Offcanvas.getOrCreateInstance(element).hide();\n            }\n        }\n    });\n    enableDismissTrigger(Offcanvas);\n    /**\n   * jQuery\n   */ defineJQueryPlugin(Offcanvas);\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap util/sanitizer.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ // js-docs-start allow-list\n    const ARIA_ATTRIBUTE_PATTERN = /^aria-[\\w-]*$/i;\n    const DefaultAllowlist = {\n        // Global attributes allowed on any supplied element below.\n        \"*\": [\n            \"class\",\n            \"dir\",\n            \"id\",\n            \"lang\",\n            \"role\",\n            ARIA_ATTRIBUTE_PATTERN\n        ],\n        a: [\n            \"target\",\n            \"href\",\n            \"title\",\n            \"rel\"\n        ],\n        area: [],\n        b: [],\n        br: [],\n        col: [],\n        code: [],\n        dd: [],\n        div: [],\n        dl: [],\n        dt: [],\n        em: [],\n        hr: [],\n        h1: [],\n        h2: [],\n        h3: [],\n        h4: [],\n        h5: [],\n        h6: [],\n        i: [],\n        img: [\n            \"src\",\n            \"srcset\",\n            \"alt\",\n            \"title\",\n            \"width\",\n            \"height\"\n        ],\n        li: [],\n        ol: [],\n        p: [],\n        pre: [],\n        s: [],\n        small: [],\n        span: [],\n        sub: [],\n        sup: [],\n        strong: [],\n        u: [],\n        ul: []\n    };\n    // js-docs-end allow-list\n    const uriAttributes = new Set([\n        \"background\",\n        \"cite\",\n        \"href\",\n        \"itemtype\",\n        \"longdesc\",\n        \"poster\",\n        \"src\",\n        \"xlink:href\"\n    ]);\n    /**\n   * A pattern that recognizes URLs that are safe wrt. XSS in URL navigation\n   * contexts.\n   *\n   * Shout-out to Angular https://github.com/angular/angular/blob/15.2.8/packages/core/src/sanitization/url_sanitizer.ts#L38\n   */ // eslint-disable-next-line unicorn/better-regex\n    const SAFE_URL_PATTERN = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i;\n    const allowedAttribute = (attribute, allowedAttributeList)=>{\n        const attributeName = attribute.nodeName.toLowerCase();\n        if (allowedAttributeList.includes(attributeName)) {\n            if (uriAttributes.has(attributeName)) {\n                return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue));\n            }\n            return true;\n        }\n        // Check if a regular expression validates the attribute.\n        return allowedAttributeList.filter((attributeRegex)=>attributeRegex instanceof RegExp).some((regex)=>regex.test(attributeName));\n    };\n    function sanitizeHtml(unsafeHtml, allowList, sanitizeFunction) {\n        if (!unsafeHtml.length) {\n            return unsafeHtml;\n        }\n        if (sanitizeFunction && typeof sanitizeFunction === \"function\") {\n            return sanitizeFunction(unsafeHtml);\n        }\n        const domParser = new window.DOMParser();\n        const createdDocument = domParser.parseFromString(unsafeHtml, \"text/html\");\n        const elements = [].concat(...createdDocument.body.querySelectorAll(\"*\"));\n        for (const element of elements){\n            const elementName = element.nodeName.toLowerCase();\n            if (!Object.keys(allowList).includes(elementName)) {\n                element.remove();\n                continue;\n            }\n            const attributeList = [].concat(...element.attributes);\n            const allowedAttributes = [].concat(allowList[\"*\"] || [], allowList[elementName] || []);\n            for (const attribute of attributeList){\n                if (!allowedAttribute(attribute, allowedAttributes)) {\n                    element.removeAttribute(attribute.nodeName);\n                }\n            }\n        }\n        return createdDocument.body.innerHTML;\n    }\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap util/template-factory.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$5 = \"TemplateFactory\";\n    const Default$4 = {\n        allowList: DefaultAllowlist,\n        content: {},\n        // { selector : text ,  selector2 : text2 , }\n        extraClass: \"\",\n        html: false,\n        sanitize: true,\n        sanitizeFn: null,\n        template: \"<div></div>\"\n    };\n    const DefaultType$4 = {\n        allowList: \"object\",\n        content: \"object\",\n        extraClass: \"(string|function)\",\n        html: \"boolean\",\n        sanitize: \"boolean\",\n        sanitizeFn: \"(null|function)\",\n        template: \"string\"\n    };\n    const DefaultContentType = {\n        entry: \"(string|element|function|null)\",\n        selector: \"(string|element)\"\n    };\n    /**\n   * Class definition\n   */ class TemplateFactory extends Config {\n        constructor(config){\n            super();\n            this._config = this._getConfig(config);\n        }\n        // Getters\n        static get Default() {\n            return Default$4;\n        }\n        static get DefaultType() {\n            return DefaultType$4;\n        }\n        static get NAME() {\n            return NAME$5;\n        }\n        // Public\n        getContent() {\n            return Object.values(this._config.content).map((config)=>this._resolvePossibleFunction(config)).filter(Boolean);\n        }\n        hasContent() {\n            return this.getContent().length > 0;\n        }\n        changeContent(content) {\n            this._checkContent(content);\n            this._config.content = {\n                ...this._config.content,\n                ...content\n            };\n            return this;\n        }\n        toHtml() {\n            const templateWrapper = document.createElement(\"div\");\n            templateWrapper.innerHTML = this._maybeSanitize(this._config.template);\n            for (const [selector, text] of Object.entries(this._config.content)){\n                this._setContent(templateWrapper, text, selector);\n            }\n            const template = templateWrapper.children[0];\n            const extraClass = this._resolvePossibleFunction(this._config.extraClass);\n            if (extraClass) {\n                template.classList.add(...extraClass.split(\" \"));\n            }\n            return template;\n        }\n        // Private\n        _typeCheckConfig(config) {\n            super._typeCheckConfig(config);\n            this._checkContent(config.content);\n        }\n        _checkContent(arg) {\n            for (const [selector, content] of Object.entries(arg)){\n                super._typeCheckConfig({\n                    selector,\n                    entry: content\n                }, DefaultContentType);\n            }\n        }\n        _setContent(template, content, selector) {\n            const templateElement = SelectorEngine.findOne(selector, template);\n            if (!templateElement) {\n                return;\n            }\n            content = this._resolvePossibleFunction(content);\n            if (!content) {\n                templateElement.remove();\n                return;\n            }\n            if (isElement$1(content)) {\n                this._putElementInTemplate(getElement(content), templateElement);\n                return;\n            }\n            if (this._config.html) {\n                templateElement.innerHTML = this._maybeSanitize(content);\n                return;\n            }\n            templateElement.textContent = content;\n        }\n        _maybeSanitize(arg) {\n            return this._config.sanitize ? sanitizeHtml(arg, this._config.allowList, this._config.sanitizeFn) : arg;\n        }\n        _resolvePossibleFunction(arg) {\n            return execute(arg, [\n                this\n            ]);\n        }\n        _putElementInTemplate(element, templateElement) {\n            if (this._config.html) {\n                templateElement.innerHTML = \"\";\n                templateElement.append(element);\n                return;\n            }\n            templateElement.textContent = element.textContent;\n        }\n    }\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap tooltip.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$4 = \"tooltip\";\n    const DISALLOWED_ATTRIBUTES = new Set([\n        \"sanitize\",\n        \"allowList\",\n        \"sanitizeFn\"\n    ]);\n    const CLASS_NAME_FADE$2 = \"fade\";\n    const CLASS_NAME_MODAL = \"modal\";\n    const CLASS_NAME_SHOW$2 = \"show\";\n    const SELECTOR_TOOLTIP_INNER = \".tooltip-inner\";\n    const SELECTOR_MODAL = `.${CLASS_NAME_MODAL}`;\n    const EVENT_MODAL_HIDE = \"hide.bs.modal\";\n    const TRIGGER_HOVER = \"hover\";\n    const TRIGGER_FOCUS = \"focus\";\n    const TRIGGER_CLICK = \"click\";\n    const TRIGGER_MANUAL = \"manual\";\n    const EVENT_HIDE$2 = \"hide\";\n    const EVENT_HIDDEN$2 = \"hidden\";\n    const EVENT_SHOW$2 = \"show\";\n    const EVENT_SHOWN$2 = \"shown\";\n    const EVENT_INSERTED = \"inserted\";\n    const EVENT_CLICK$1 = \"click\";\n    const EVENT_FOCUSIN$1 = \"focusin\";\n    const EVENT_FOCUSOUT$1 = \"focusout\";\n    const EVENT_MOUSEENTER = \"mouseenter\";\n    const EVENT_MOUSELEAVE = \"mouseleave\";\n    const AttachmentMap = {\n        AUTO: \"auto\",\n        TOP: \"top\",\n        RIGHT: isRTL() ? \"left\" : \"right\",\n        BOTTOM: \"bottom\",\n        LEFT: isRTL() ? \"right\" : \"left\"\n    };\n    const Default$3 = {\n        allowList: DefaultAllowlist,\n        animation: true,\n        boundary: \"clippingParents\",\n        container: false,\n        customClass: \"\",\n        delay: 0,\n        fallbackPlacements: [\n            \"top\",\n            \"right\",\n            \"bottom\",\n            \"left\"\n        ],\n        html: false,\n        offset: [\n            0,\n            6\n        ],\n        placement: \"top\",\n        popperConfig: null,\n        sanitize: true,\n        sanitizeFn: null,\n        selector: false,\n        template: '<div class=\"tooltip\" role=\"tooltip\">' + '<div class=\"tooltip-arrow\"></div>' + '<div class=\"tooltip-inner\"></div>' + \"</div>\",\n        title: \"\",\n        trigger: \"hover focus\"\n    };\n    const DefaultType$3 = {\n        allowList: \"object\",\n        animation: \"boolean\",\n        boundary: \"(string|element)\",\n        container: \"(string|element|boolean)\",\n        customClass: \"(string|function)\",\n        delay: \"(number|object)\",\n        fallbackPlacements: \"array\",\n        html: \"boolean\",\n        offset: \"(array|string|function)\",\n        placement: \"(string|function)\",\n        popperConfig: \"(null|object|function)\",\n        sanitize: \"boolean\",\n        sanitizeFn: \"(null|function)\",\n        selector: \"(string|boolean)\",\n        template: \"string\",\n        title: \"(string|element|function)\",\n        trigger: \"string\"\n    };\n    /**\n   * Class definition\n   */ class Tooltip extends BaseComponent {\n        constructor(element, config){\n            if (typeof Popper === \"undefined\") {\n                throw new TypeError(\"Bootstrap's tooltips require Popper (https://popper.js.org)\");\n            }\n            super(element, config);\n            // Private\n            this._isEnabled = true;\n            this._timeout = 0;\n            this._isHovered = null;\n            this._activeTrigger = {};\n            this._popper = null;\n            this._templateFactory = null;\n            this._newContent = null;\n            // Protected\n            this.tip = null;\n            this._setListeners();\n            if (!this._config.selector) {\n                this._fixTitle();\n            }\n        }\n        // Getters\n        static get Default() {\n            return Default$3;\n        }\n        static get DefaultType() {\n            return DefaultType$3;\n        }\n        static get NAME() {\n            return NAME$4;\n        }\n        // Public\n        enable() {\n            this._isEnabled = true;\n        }\n        disable() {\n            this._isEnabled = false;\n        }\n        toggleEnabled() {\n            this._isEnabled = !this._isEnabled;\n        }\n        toggle() {\n            if (!this._isEnabled) {\n                return;\n            }\n            this._activeTrigger.click = !this._activeTrigger.click;\n            if (this._isShown()) {\n                this._leave();\n                return;\n            }\n            this._enter();\n        }\n        dispose() {\n            clearTimeout(this._timeout);\n            EventHandler.off(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);\n            if (this._element.getAttribute(\"data-bs-original-title\")) {\n                this._element.setAttribute(\"title\", this._element.getAttribute(\"data-bs-original-title\"));\n            }\n            this._disposePopper();\n            super.dispose();\n        }\n        show() {\n            if (this._element.style.display === \"none\") {\n                throw new Error(\"Please use show on visible elements\");\n            }\n            if (!(this._isWithContent() && this._isEnabled)) {\n                return;\n            }\n            const showEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOW$2));\n            const shadowRoot = findShadowRoot(this._element);\n            const isInTheDom = (shadowRoot || this._element.ownerDocument.documentElement).contains(this._element);\n            if (showEvent.defaultPrevented || !isInTheDom) {\n                return;\n            }\n            // TODO: v6 remove this or make it optional\n            this._disposePopper();\n            const tip = this._getTipElement();\n            this._element.setAttribute(\"aria-describedby\", tip.getAttribute(\"id\"));\n            const { container } = this._config;\n            if (!this._element.ownerDocument.documentElement.contains(this.tip)) {\n                container.append(tip);\n                EventHandler.trigger(this._element, this.constructor.eventName(EVENT_INSERTED));\n            }\n            this._popper = this._createPopper(tip);\n            tip.classList.add(CLASS_NAME_SHOW$2);\n            // If this is a touch-enabled device we add extra\n            // empty mouseover listeners to the body's immediate children;\n            // only needed because of broken event delegation on iOS\n            // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\n            if (\"ontouchstart\" in document.documentElement) {\n                for (const element of [].concat(...document.body.children)){\n                    EventHandler.on(element, \"mouseover\", noop);\n                }\n            }\n            const complete = ()=>{\n                EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOWN$2));\n                if (this._isHovered === false) {\n                    this._leave();\n                }\n                this._isHovered = false;\n            };\n            this._queueCallback(complete, this.tip, this._isAnimated());\n        }\n        hide() {\n            if (!this._isShown()) {\n                return;\n            }\n            const hideEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDE$2));\n            if (hideEvent.defaultPrevented) {\n                return;\n            }\n            const tip = this._getTipElement();\n            tip.classList.remove(CLASS_NAME_SHOW$2);\n            // If this is a touch-enabled device we remove the extra\n            // empty mouseover listeners we added for iOS support\n            if (\"ontouchstart\" in document.documentElement) {\n                for (const element of [].concat(...document.body.children)){\n                    EventHandler.off(element, \"mouseover\", noop);\n                }\n            }\n            this._activeTrigger[TRIGGER_CLICK] = false;\n            this._activeTrigger[TRIGGER_FOCUS] = false;\n            this._activeTrigger[TRIGGER_HOVER] = false;\n            this._isHovered = null; // it is a trick to support manual triggering\n            const complete = ()=>{\n                if (this._isWithActiveTrigger()) {\n                    return;\n                }\n                if (!this._isHovered) {\n                    this._disposePopper();\n                }\n                this._element.removeAttribute(\"aria-describedby\");\n                EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDDEN$2));\n            };\n            this._queueCallback(complete, this.tip, this._isAnimated());\n        }\n        update() {\n            if (this._popper) {\n                this._popper.update();\n            }\n        }\n        // Protected\n        _isWithContent() {\n            return Boolean(this._getTitle());\n        }\n        _getTipElement() {\n            if (!this.tip) {\n                this.tip = this._createTipElement(this._newContent || this._getContentForTemplate());\n            }\n            return this.tip;\n        }\n        _createTipElement(content) {\n            const tip = this._getTemplateFactory(content).toHtml();\n            // TODO: remove this check in v6\n            if (!tip) {\n                return null;\n            }\n            tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2);\n            // TODO: v6 the following can be achieved with CSS only\n            tip.classList.add(`bs-${this.constructor.NAME}-auto`);\n            const tipId = getUID(this.constructor.NAME).toString();\n            tip.setAttribute(\"id\", tipId);\n            if (this._isAnimated()) {\n                tip.classList.add(CLASS_NAME_FADE$2);\n            }\n            return tip;\n        }\n        setContent(content) {\n            this._newContent = content;\n            if (this._isShown()) {\n                this._disposePopper();\n                this.show();\n            }\n        }\n        _getTemplateFactory(content) {\n            if (this._templateFactory) {\n                this._templateFactory.changeContent(content);\n            } else {\n                this._templateFactory = new TemplateFactory({\n                    ...this._config,\n                    // the `content` var has to be after `this._config`\n                    // to override config.content in case of popover\n                    content,\n                    extraClass: this._resolvePossibleFunction(this._config.customClass)\n                });\n            }\n            return this._templateFactory;\n        }\n        _getContentForTemplate() {\n            return {\n                [SELECTOR_TOOLTIP_INNER]: this._getTitle()\n            };\n        }\n        _getTitle() {\n            return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute(\"data-bs-original-title\");\n        }\n        // Private\n        _initializeOnDelegatedTarget(event) {\n            return this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig());\n        }\n        _isAnimated() {\n            return this._config.animation || this.tip && this.tip.classList.contains(CLASS_NAME_FADE$2);\n        }\n        _isShown() {\n            return this.tip && this.tip.classList.contains(CLASS_NAME_SHOW$2);\n        }\n        _createPopper(tip) {\n            const placement = execute(this._config.placement, [\n                this,\n                tip,\n                this._element\n            ]);\n            const attachment = AttachmentMap[placement.toUpperCase()];\n            return createPopper(this._element, tip, this._getPopperConfig(attachment));\n        }\n        _getOffset() {\n            const { offset } = this._config;\n            if (typeof offset === \"string\") {\n                return offset.split(\",\").map((value)=>Number.parseInt(value, 10));\n            }\n            if (typeof offset === \"function\") {\n                return (popperData)=>offset(popperData, this._element);\n            }\n            return offset;\n        }\n        _resolvePossibleFunction(arg) {\n            return execute(arg, [\n                this._element\n            ]);\n        }\n        _getPopperConfig(attachment) {\n            const defaultBsPopperConfig = {\n                placement: attachment,\n                modifiers: [\n                    {\n                        name: \"flip\",\n                        options: {\n                            fallbackPlacements: this._config.fallbackPlacements\n                        }\n                    },\n                    {\n                        name: \"offset\",\n                        options: {\n                            offset: this._getOffset()\n                        }\n                    },\n                    {\n                        name: \"preventOverflow\",\n                        options: {\n                            boundary: this._config.boundary\n                        }\n                    },\n                    {\n                        name: \"arrow\",\n                        options: {\n                            element: `.${this.constructor.NAME}-arrow`\n                        }\n                    },\n                    {\n                        name: \"preSetPlacement\",\n                        enabled: true,\n                        phase: \"beforeMain\",\n                        fn: (data)=>{\n                            // Pre-set Popper's placement attribute in order to read the arrow sizes properly.\n                            // Otherwise, Popper mixes up the width and height dimensions since the initial arrow style is for top placement\n                            this._getTipElement().setAttribute(\"data-popper-placement\", data.state.placement);\n                        }\n                    }\n                ]\n            };\n            return {\n                ...defaultBsPopperConfig,\n                ...execute(this._config.popperConfig, [\n                    defaultBsPopperConfig\n                ])\n            };\n        }\n        _setListeners() {\n            const triggers = this._config.trigger.split(\" \");\n            for (const trigger of triggers){\n                if (trigger === \"click\") {\n                    EventHandler.on(this._element, this.constructor.eventName(EVENT_CLICK$1), this._config.selector, (event)=>{\n                        const context = this._initializeOnDelegatedTarget(event);\n                        context.toggle();\n                    });\n                } else if (trigger !== TRIGGER_MANUAL) {\n                    const eventIn = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSEENTER) : this.constructor.eventName(EVENT_FOCUSIN$1);\n                    const eventOut = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSELEAVE) : this.constructor.eventName(EVENT_FOCUSOUT$1);\n                    EventHandler.on(this._element, eventIn, this._config.selector, (event)=>{\n                        const context = this._initializeOnDelegatedTarget(event);\n                        context._activeTrigger[event.type === \"focusin\" ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;\n                        context._enter();\n                    });\n                    EventHandler.on(this._element, eventOut, this._config.selector, (event)=>{\n                        const context = this._initializeOnDelegatedTarget(event);\n                        context._activeTrigger[event.type === \"focusout\" ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);\n                        context._leave();\n                    });\n                }\n            }\n            this._hideModalHandler = ()=>{\n                if (this._element) {\n                    this.hide();\n                }\n            };\n            EventHandler.on(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);\n        }\n        _fixTitle() {\n            const title = this._element.getAttribute(\"title\");\n            if (!title) {\n                return;\n            }\n            if (!this._element.getAttribute(\"aria-label\") && !this._element.textContent.trim()) {\n                this._element.setAttribute(\"aria-label\", title);\n            }\n            this._element.setAttribute(\"data-bs-original-title\", title); // DO NOT USE IT. Is only for backwards compatibility\n            this._element.removeAttribute(\"title\");\n        }\n        _enter() {\n            if (this._isShown() || this._isHovered) {\n                this._isHovered = true;\n                return;\n            }\n            this._isHovered = true;\n            this._setTimeout(()=>{\n                if (this._isHovered) {\n                    this.show();\n                }\n            }, this._config.delay.show);\n        }\n        _leave() {\n            if (this._isWithActiveTrigger()) {\n                return;\n            }\n            this._isHovered = false;\n            this._setTimeout(()=>{\n                if (!this._isHovered) {\n                    this.hide();\n                }\n            }, this._config.delay.hide);\n        }\n        _setTimeout(handler, timeout) {\n            clearTimeout(this._timeout);\n            this._timeout = setTimeout(handler, timeout);\n        }\n        _isWithActiveTrigger() {\n            return Object.values(this._activeTrigger).includes(true);\n        }\n        _getConfig(config) {\n            const dataAttributes = Manipulator.getDataAttributes(this._element);\n            for (const dataAttribute of Object.keys(dataAttributes)){\n                if (DISALLOWED_ATTRIBUTES.has(dataAttribute)) {\n                    delete dataAttributes[dataAttribute];\n                }\n            }\n            config = {\n                ...dataAttributes,\n                ...typeof config === \"object\" && config ? config : {}\n            };\n            config = this._mergeConfigObj(config);\n            config = this._configAfterMerge(config);\n            this._typeCheckConfig(config);\n            return config;\n        }\n        _configAfterMerge(config) {\n            config.container = config.container === false ? document.body : getElement(config.container);\n            if (typeof config.delay === \"number\") {\n                config.delay = {\n                    show: config.delay,\n                    hide: config.delay\n                };\n            }\n            if (typeof config.title === \"number\") {\n                config.title = config.title.toString();\n            }\n            if (typeof config.content === \"number\") {\n                config.content = config.content.toString();\n            }\n            return config;\n        }\n        _getDelegateConfig() {\n            const config = {};\n            for (const [key, value] of Object.entries(this._config)){\n                if (this.constructor.Default[key] !== value) {\n                    config[key] = value;\n                }\n            }\n            config.selector = false;\n            config.trigger = \"manual\";\n            // In the future can be replaced with:\n            // const keysWithDifferentValues = Object.entries(this._config).filter(entry => this.constructor.Default[entry[0]] !== this._config[entry[0]])\n            // `Object.fromEntries(keysWithDifferentValues)`\n            return config;\n        }\n        _disposePopper() {\n            if (this._popper) {\n                this._popper.destroy();\n                this._popper = null;\n            }\n            if (this.tip) {\n                this.tip.remove();\n                this.tip = null;\n            }\n        }\n        // Static\n        static jQueryInterface(config) {\n            return this.each(function() {\n                const data = Tooltip.getOrCreateInstance(this, config);\n                if (typeof config !== \"string\") {\n                    return;\n                }\n                if (typeof data[config] === \"undefined\") {\n                    throw new TypeError(`No method named \"${config}\"`);\n                }\n                data[config]();\n            });\n        }\n    }\n    /**\n   * jQuery\n   */ defineJQueryPlugin(Tooltip);\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap popover.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$3 = \"popover\";\n    const SELECTOR_TITLE = \".popover-header\";\n    const SELECTOR_CONTENT = \".popover-body\";\n    const Default$2 = {\n        ...Tooltip.Default,\n        content: \"\",\n        offset: [\n            0,\n            8\n        ],\n        placement: \"right\",\n        template: '<div class=\"popover\" role=\"tooltip\">' + '<div class=\"popover-arrow\"></div>' + '<h3 class=\"popover-header\"></h3>' + '<div class=\"popover-body\"></div>' + \"</div>\",\n        trigger: \"click\"\n    };\n    const DefaultType$2 = {\n        ...Tooltip.DefaultType,\n        content: \"(null|string|element|function)\"\n    };\n    /**\n   * Class definition\n   */ class Popover extends Tooltip {\n        // Getters\n        static get Default() {\n            return Default$2;\n        }\n        static get DefaultType() {\n            return DefaultType$2;\n        }\n        static get NAME() {\n            return NAME$3;\n        }\n        // Overrides\n        _isWithContent() {\n            return this._getTitle() || this._getContent();\n        }\n        // Private\n        _getContentForTemplate() {\n            return {\n                [SELECTOR_TITLE]: this._getTitle(),\n                [SELECTOR_CONTENT]: this._getContent()\n            };\n        }\n        _getContent() {\n            return this._resolvePossibleFunction(this._config.content);\n        }\n        // Static\n        static jQueryInterface(config) {\n            return this.each(function() {\n                const data = Popover.getOrCreateInstance(this, config);\n                if (typeof config !== \"string\") {\n                    return;\n                }\n                if (typeof data[config] === \"undefined\") {\n                    throw new TypeError(`No method named \"${config}\"`);\n                }\n                data[config]();\n            });\n        }\n    }\n    /**\n   * jQuery\n   */ defineJQueryPlugin(Popover);\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap scrollspy.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$2 = \"scrollspy\";\n    const DATA_KEY$2 = \"bs.scrollspy\";\n    const EVENT_KEY$2 = `.${DATA_KEY$2}`;\n    const DATA_API_KEY = \".data-api\";\n    const EVENT_ACTIVATE = `activate${EVENT_KEY$2}`;\n    const EVENT_CLICK = `click${EVENT_KEY$2}`;\n    const EVENT_LOAD_DATA_API$1 = `load${EVENT_KEY$2}${DATA_API_KEY}`;\n    const CLASS_NAME_DROPDOWN_ITEM = \"dropdown-item\";\n    const CLASS_NAME_ACTIVE$1 = \"active\";\n    const SELECTOR_DATA_SPY = '[data-bs-spy=\"scroll\"]';\n    const SELECTOR_TARGET_LINKS = \"[href]\";\n    const SELECTOR_NAV_LIST_GROUP = \".nav, .list-group\";\n    const SELECTOR_NAV_LINKS = \".nav-link\";\n    const SELECTOR_NAV_ITEMS = \".nav-item\";\n    const SELECTOR_LIST_ITEMS = \".list-group-item\";\n    const SELECTOR_LINK_ITEMS = `${SELECTOR_NAV_LINKS}, ${SELECTOR_NAV_ITEMS} > ${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}`;\n    const SELECTOR_DROPDOWN = \".dropdown\";\n    const SELECTOR_DROPDOWN_TOGGLE$1 = \".dropdown-toggle\";\n    const Default$1 = {\n        offset: null,\n        // TODO: v6 @deprecated, keep it for backwards compatibility reasons\n        rootMargin: \"0px 0px -25%\",\n        smoothScroll: false,\n        target: null,\n        threshold: [\n            0.1,\n            0.5,\n            1\n        ]\n    };\n    const DefaultType$1 = {\n        offset: \"(number|null)\",\n        // TODO v6 @deprecated, keep it for backwards compatibility reasons\n        rootMargin: \"string\",\n        smoothScroll: \"boolean\",\n        target: \"element\",\n        threshold: \"array\"\n    };\n    /**\n   * Class definition\n   */ class ScrollSpy extends BaseComponent {\n        constructor(element, config){\n            super(element, config);\n            // this._element is the observablesContainer and config.target the menu links wrapper\n            this._targetLinks = new Map();\n            this._observableSections = new Map();\n            this._rootElement = getComputedStyle(this._element).overflowY === \"visible\" ? null : this._element;\n            this._activeTarget = null;\n            this._observer = null;\n            this._previousScrollData = {\n                visibleEntryTop: 0,\n                parentScrollTop: 0\n            };\n            this.refresh(); // initialize\n        }\n        // Getters\n        static get Default() {\n            return Default$1;\n        }\n        static get DefaultType() {\n            return DefaultType$1;\n        }\n        static get NAME() {\n            return NAME$2;\n        }\n        // Public\n        refresh() {\n            this._initializeTargetsAndObservables();\n            this._maybeEnableSmoothScroll();\n            if (this._observer) {\n                this._observer.disconnect();\n            } else {\n                this._observer = this._getNewObserver();\n            }\n            for (const section of this._observableSections.values()){\n                this._observer.observe(section);\n            }\n        }\n        dispose() {\n            this._observer.disconnect();\n            super.dispose();\n        }\n        // Private\n        _configAfterMerge(config) {\n            // TODO: on v6 target should be given explicitly & remove the {target: 'ss-target'} case\n            config.target = getElement(config.target) || document.body;\n            // TODO: v6 Only for backwards compatibility reasons. Use rootMargin only\n            config.rootMargin = config.offset ? `${config.offset}px 0px -30%` : config.rootMargin;\n            if (typeof config.threshold === \"string\") {\n                config.threshold = config.threshold.split(\",\").map((value)=>Number.parseFloat(value));\n            }\n            return config;\n        }\n        _maybeEnableSmoothScroll() {\n            if (!this._config.smoothScroll) {\n                return;\n            }\n            // unregister any previous listeners\n            EventHandler.off(this._config.target, EVENT_CLICK);\n            EventHandler.on(this._config.target, EVENT_CLICK, SELECTOR_TARGET_LINKS, (event)=>{\n                const observableSection = this._observableSections.get(event.target.hash);\n                if (observableSection) {\n                    event.preventDefault();\n                    const root = this._rootElement || window;\n                    const height = observableSection.offsetTop - this._element.offsetTop;\n                    if (root.scrollTo) {\n                        root.scrollTo({\n                            top: height,\n                            behavior: \"smooth\"\n                        });\n                        return;\n                    }\n                    // Chrome 60 doesn't support `scrollTo`\n                    root.scrollTop = height;\n                }\n            });\n        }\n        _getNewObserver() {\n            const options = {\n                root: this._rootElement,\n                threshold: this._config.threshold,\n                rootMargin: this._config.rootMargin\n            };\n            return new IntersectionObserver((entries)=>this._observerCallback(entries), options);\n        }\n        // The logic of selection\n        _observerCallback(entries) {\n            const targetElement = (entry)=>this._targetLinks.get(`#${entry.target.id}`);\n            const activate = (entry)=>{\n                this._previousScrollData.visibleEntryTop = entry.target.offsetTop;\n                this._process(targetElement(entry));\n            };\n            const parentScrollTop = (this._rootElement || document.documentElement).scrollTop;\n            const userScrollsDown = parentScrollTop >= this._previousScrollData.parentScrollTop;\n            this._previousScrollData.parentScrollTop = parentScrollTop;\n            for (const entry of entries){\n                if (!entry.isIntersecting) {\n                    this._activeTarget = null;\n                    this._clearActiveClass(targetElement(entry));\n                    continue;\n                }\n                const entryIsLowerThanPrevious = entry.target.offsetTop >= this._previousScrollData.visibleEntryTop;\n                // if we are scrolling down, pick the bigger offsetTop\n                if (userScrollsDown && entryIsLowerThanPrevious) {\n                    activate(entry);\n                    // if parent isn't scrolled, let's keep the first visible item, breaking the iteration\n                    if (!parentScrollTop) {\n                        return;\n                    }\n                    continue;\n                }\n                // if we are scrolling up, pick the smallest offsetTop\n                if (!userScrollsDown && !entryIsLowerThanPrevious) {\n                    activate(entry);\n                }\n            }\n        }\n        _initializeTargetsAndObservables() {\n            this._targetLinks = new Map();\n            this._observableSections = new Map();\n            const targetLinks = SelectorEngine.find(SELECTOR_TARGET_LINKS, this._config.target);\n            for (const anchor of targetLinks){\n                // ensure that the anchor has an id and is not disabled\n                if (!anchor.hash || isDisabled(anchor)) {\n                    continue;\n                }\n                const observableSection = SelectorEngine.findOne(decodeURI(anchor.hash), this._element);\n                // ensure that the observableSection exists & is visible\n                if (isVisible(observableSection)) {\n                    this._targetLinks.set(decodeURI(anchor.hash), anchor);\n                    this._observableSections.set(anchor.hash, observableSection);\n                }\n            }\n        }\n        _process(target) {\n            if (this._activeTarget === target) {\n                return;\n            }\n            this._clearActiveClass(this._config.target);\n            this._activeTarget = target;\n            target.classList.add(CLASS_NAME_ACTIVE$1);\n            this._activateParents(target);\n            EventHandler.trigger(this._element, EVENT_ACTIVATE, {\n                relatedTarget: target\n            });\n        }\n        _activateParents(target) {\n            // Activate dropdown parents\n            if (target.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {\n                SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, target.closest(SELECTOR_DROPDOWN)).classList.add(CLASS_NAME_ACTIVE$1);\n                return;\n            }\n            for (const listGroup of SelectorEngine.parents(target, SELECTOR_NAV_LIST_GROUP)){\n                // Set triggered links parents as active\n                // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor\n                for (const item of SelectorEngine.prev(listGroup, SELECTOR_LINK_ITEMS)){\n                    item.classList.add(CLASS_NAME_ACTIVE$1);\n                }\n            }\n        }\n        _clearActiveClass(parent) {\n            parent.classList.remove(CLASS_NAME_ACTIVE$1);\n            const activeNodes = SelectorEngine.find(`${SELECTOR_TARGET_LINKS}.${CLASS_NAME_ACTIVE$1}`, parent);\n            for (const node of activeNodes){\n                node.classList.remove(CLASS_NAME_ACTIVE$1);\n            }\n        }\n        // Static\n        static jQueryInterface(config) {\n            return this.each(function() {\n                const data = ScrollSpy.getOrCreateInstance(this, config);\n                if (typeof config !== \"string\") {\n                    return;\n                }\n                if (data[config] === undefined || config.startsWith(\"_\") || config === \"constructor\") {\n                    throw new TypeError(`No method named \"${config}\"`);\n                }\n                data[config]();\n            });\n        }\n    }\n    /**\n   * Data API implementation\n   */ EventHandler.on(window, EVENT_LOAD_DATA_API$1, ()=>{\n        for (const spy of SelectorEngine.find(SELECTOR_DATA_SPY)){\n            ScrollSpy.getOrCreateInstance(spy);\n        }\n    });\n    /**\n   * jQuery\n   */ defineJQueryPlugin(ScrollSpy);\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap tab.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME$1 = \"tab\";\n    const DATA_KEY$1 = \"bs.tab\";\n    const EVENT_KEY$1 = `.${DATA_KEY$1}`;\n    const EVENT_HIDE$1 = `hide${EVENT_KEY$1}`;\n    const EVENT_HIDDEN$1 = `hidden${EVENT_KEY$1}`;\n    const EVENT_SHOW$1 = `show${EVENT_KEY$1}`;\n    const EVENT_SHOWN$1 = `shown${EVENT_KEY$1}`;\n    const EVENT_CLICK_DATA_API = `click${EVENT_KEY$1}`;\n    const EVENT_KEYDOWN = `keydown${EVENT_KEY$1}`;\n    const EVENT_LOAD_DATA_API = `load${EVENT_KEY$1}`;\n    const ARROW_LEFT_KEY = \"ArrowLeft\";\n    const ARROW_RIGHT_KEY = \"ArrowRight\";\n    const ARROW_UP_KEY = \"ArrowUp\";\n    const ARROW_DOWN_KEY = \"ArrowDown\";\n    const HOME_KEY = \"Home\";\n    const END_KEY = \"End\";\n    const CLASS_NAME_ACTIVE = \"active\";\n    const CLASS_NAME_FADE$1 = \"fade\";\n    const CLASS_NAME_SHOW$1 = \"show\";\n    const CLASS_DROPDOWN = \"dropdown\";\n    const SELECTOR_DROPDOWN_TOGGLE = \".dropdown-toggle\";\n    const SELECTOR_DROPDOWN_MENU = \".dropdown-menu\";\n    const NOT_SELECTOR_DROPDOWN_TOGGLE = `:not(${SELECTOR_DROPDOWN_TOGGLE})`;\n    const SELECTOR_TAB_PANEL = '.list-group, .nav, [role=\"tablist\"]';\n    const SELECTOR_OUTER = \".nav-item, .list-group-item\";\n    const SELECTOR_INNER = `.nav-link${NOT_SELECTOR_DROPDOWN_TOGGLE}, .list-group-item${NOT_SELECTOR_DROPDOWN_TOGGLE}, [role=\"tab\"]${NOT_SELECTOR_DROPDOWN_TOGGLE}`;\n    const SELECTOR_DATA_TOGGLE = '[data-bs-toggle=\"tab\"], [data-bs-toggle=\"pill\"], [data-bs-toggle=\"list\"]'; // TODO: could only be `tab` in v6\n    const SELECTOR_INNER_ELEM = `${SELECTOR_INNER}, ${SELECTOR_DATA_TOGGLE}`;\n    const SELECTOR_DATA_TOGGLE_ACTIVE = `.${CLASS_NAME_ACTIVE}[data-bs-toggle=\"tab\"], .${CLASS_NAME_ACTIVE}[data-bs-toggle=\"pill\"], .${CLASS_NAME_ACTIVE}[data-bs-toggle=\"list\"]`;\n    /**\n   * Class definition\n   */ class Tab extends BaseComponent {\n        constructor(element){\n            super(element);\n            this._parent = this._element.closest(SELECTOR_TAB_PANEL);\n            if (!this._parent) {\n                return;\n            // TODO: should throw exception in v6\n            // throw new TypeError(`${element.outerHTML} has not a valid parent ${SELECTOR_INNER_ELEM}`)\n            }\n            // Set up initial aria attributes\n            this._setInitialAttributes(this._parent, this._getChildren());\n            EventHandler.on(this._element, EVENT_KEYDOWN, (event)=>this._keydown(event));\n        }\n        // Getters\n        static get NAME() {\n            return NAME$1;\n        }\n        // Public\n        show() {\n            // Shows this elem and deactivate the active sibling if exists\n            const innerElem = this._element;\n            if (this._elemIsActive(innerElem)) {\n                return;\n            }\n            // Search for active tab on same parent to deactivate it\n            const active = this._getActiveElem();\n            const hideEvent = active ? EventHandler.trigger(active, EVENT_HIDE$1, {\n                relatedTarget: innerElem\n            }) : null;\n            const showEvent = EventHandler.trigger(innerElem, EVENT_SHOW$1, {\n                relatedTarget: active\n            });\n            if (showEvent.defaultPrevented || hideEvent && hideEvent.defaultPrevented) {\n                return;\n            }\n            this._deactivate(active, innerElem);\n            this._activate(innerElem, active);\n        }\n        // Private\n        _activate(element, relatedElem) {\n            if (!element) {\n                return;\n            }\n            element.classList.add(CLASS_NAME_ACTIVE);\n            this._activate(SelectorEngine.getElementFromSelector(element)); // Search and activate/show the proper section\n            const complete = ()=>{\n                if (element.getAttribute(\"role\") !== \"tab\") {\n                    element.classList.add(CLASS_NAME_SHOW$1);\n                    return;\n                }\n                element.removeAttribute(\"tabindex\");\n                element.setAttribute(\"aria-selected\", true);\n                this._toggleDropDown(element, true);\n                EventHandler.trigger(element, EVENT_SHOWN$1, {\n                    relatedTarget: relatedElem\n                });\n            };\n            this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));\n        }\n        _deactivate(element, relatedElem) {\n            if (!element) {\n                return;\n            }\n            element.classList.remove(CLASS_NAME_ACTIVE);\n            element.blur();\n            this._deactivate(SelectorEngine.getElementFromSelector(element)); // Search and deactivate the shown section too\n            const complete = ()=>{\n                if (element.getAttribute(\"role\") !== \"tab\") {\n                    element.classList.remove(CLASS_NAME_SHOW$1);\n                    return;\n                }\n                element.setAttribute(\"aria-selected\", false);\n                element.setAttribute(\"tabindex\", \"-1\");\n                this._toggleDropDown(element, false);\n                EventHandler.trigger(element, EVENT_HIDDEN$1, {\n                    relatedTarget: relatedElem\n                });\n            };\n            this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));\n        }\n        _keydown(event) {\n            if (![\n                ARROW_LEFT_KEY,\n                ARROW_RIGHT_KEY,\n                ARROW_UP_KEY,\n                ARROW_DOWN_KEY,\n                HOME_KEY,\n                END_KEY\n            ].includes(event.key)) {\n                return;\n            }\n            event.stopPropagation(); // stopPropagation/preventDefault both added to support up/down keys without scrolling the page\n            event.preventDefault();\n            const children = this._getChildren().filter((element)=>!isDisabled(element));\n            let nextActiveElement;\n            if ([\n                HOME_KEY,\n                END_KEY\n            ].includes(event.key)) {\n                nextActiveElement = children[event.key === HOME_KEY ? 0 : children.length - 1];\n            } else {\n                const isNext = [\n                    ARROW_RIGHT_KEY,\n                    ARROW_DOWN_KEY\n                ].includes(event.key);\n                nextActiveElement = getNextActiveElement(children, event.target, isNext, true);\n            }\n            if (nextActiveElement) {\n                nextActiveElement.focus({\n                    preventScroll: true\n                });\n                Tab.getOrCreateInstance(nextActiveElement).show();\n            }\n        }\n        _getChildren() {\n            // collection of inner elements\n            return SelectorEngine.find(SELECTOR_INNER_ELEM, this._parent);\n        }\n        _getActiveElem() {\n            return this._getChildren().find((child)=>this._elemIsActive(child)) || null;\n        }\n        _setInitialAttributes(parent, children) {\n            this._setAttributeIfNotExists(parent, \"role\", \"tablist\");\n            for (const child of children){\n                this._setInitialAttributesOnChild(child);\n            }\n        }\n        _setInitialAttributesOnChild(child) {\n            child = this._getInnerElement(child);\n            const isActive = this._elemIsActive(child);\n            const outerElem = this._getOuterElement(child);\n            child.setAttribute(\"aria-selected\", isActive);\n            if (outerElem !== child) {\n                this._setAttributeIfNotExists(outerElem, \"role\", \"presentation\");\n            }\n            if (!isActive) {\n                child.setAttribute(\"tabindex\", \"-1\");\n            }\n            this._setAttributeIfNotExists(child, \"role\", \"tab\");\n            // set attributes to the related panel too\n            this._setInitialAttributesOnTargetPanel(child);\n        }\n        _setInitialAttributesOnTargetPanel(child) {\n            const target = SelectorEngine.getElementFromSelector(child);\n            if (!target) {\n                return;\n            }\n            this._setAttributeIfNotExists(target, \"role\", \"tabpanel\");\n            if (child.id) {\n                this._setAttributeIfNotExists(target, \"aria-labelledby\", `${child.id}`);\n            }\n        }\n        _toggleDropDown(element, open) {\n            const outerElem = this._getOuterElement(element);\n            if (!outerElem.classList.contains(CLASS_DROPDOWN)) {\n                return;\n            }\n            const toggle = (selector, className)=>{\n                const element = SelectorEngine.findOne(selector, outerElem);\n                if (element) {\n                    element.classList.toggle(className, open);\n                }\n            };\n            toggle(SELECTOR_DROPDOWN_TOGGLE, CLASS_NAME_ACTIVE);\n            toggle(SELECTOR_DROPDOWN_MENU, CLASS_NAME_SHOW$1);\n            outerElem.setAttribute(\"aria-expanded\", open);\n        }\n        _setAttributeIfNotExists(element, attribute, value) {\n            if (!element.hasAttribute(attribute)) {\n                element.setAttribute(attribute, value);\n            }\n        }\n        _elemIsActive(elem) {\n            return elem.classList.contains(CLASS_NAME_ACTIVE);\n        }\n        // Try to get the inner element (usually the .nav-link)\n        _getInnerElement(elem) {\n            return elem.matches(SELECTOR_INNER_ELEM) ? elem : SelectorEngine.findOne(SELECTOR_INNER_ELEM, elem);\n        }\n        // Try to get the outer element (usually the .nav-item)\n        _getOuterElement(elem) {\n            return elem.closest(SELECTOR_OUTER) || elem;\n        }\n        // Static\n        static jQueryInterface(config) {\n            return this.each(function() {\n                const data = Tab.getOrCreateInstance(this);\n                if (typeof config !== \"string\") {\n                    return;\n                }\n                if (data[config] === undefined || config.startsWith(\"_\") || config === \"constructor\") {\n                    throw new TypeError(`No method named \"${config}\"`);\n                }\n                data[config]();\n            });\n        }\n    }\n    /**\n   * Data API implementation\n   */ EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function(event) {\n        if ([\n            \"A\",\n            \"AREA\"\n        ].includes(this.tagName)) {\n            event.preventDefault();\n        }\n        if (isDisabled(this)) {\n            return;\n        }\n        Tab.getOrCreateInstance(this).show();\n    });\n    /**\n   * Initialize on focus\n   */ EventHandler.on(window, EVENT_LOAD_DATA_API, ()=>{\n        for (const element of SelectorEngine.find(SELECTOR_DATA_TOGGLE_ACTIVE)){\n            Tab.getOrCreateInstance(element);\n        }\n    });\n    /**\n   * jQuery\n   */ defineJQueryPlugin(Tab);\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap toast.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ /**\n   * Constants\n   */ const NAME = \"toast\";\n    const DATA_KEY = \"bs.toast\";\n    const EVENT_KEY = `.${DATA_KEY}`;\n    const EVENT_MOUSEOVER = `mouseover${EVENT_KEY}`;\n    const EVENT_MOUSEOUT = `mouseout${EVENT_KEY}`;\n    const EVENT_FOCUSIN = `focusin${EVENT_KEY}`;\n    const EVENT_FOCUSOUT = `focusout${EVENT_KEY}`;\n    const EVENT_HIDE = `hide${EVENT_KEY}`;\n    const EVENT_HIDDEN = `hidden${EVENT_KEY}`;\n    const EVENT_SHOW = `show${EVENT_KEY}`;\n    const EVENT_SHOWN = `shown${EVENT_KEY}`;\n    const CLASS_NAME_FADE = \"fade\";\n    const CLASS_NAME_HIDE = \"hide\"; // @deprecated - kept here only for backwards compatibility\n    const CLASS_NAME_SHOW = \"show\";\n    const CLASS_NAME_SHOWING = \"showing\";\n    const DefaultType = {\n        animation: \"boolean\",\n        autohide: \"boolean\",\n        delay: \"number\"\n    };\n    const Default = {\n        animation: true,\n        autohide: true,\n        delay: 5000\n    };\n    /**\n   * Class definition\n   */ class Toast extends BaseComponent {\n        constructor(element, config){\n            super(element, config);\n            this._timeout = null;\n            this._hasMouseInteraction = false;\n            this._hasKeyboardInteraction = false;\n            this._setListeners();\n        }\n        // Getters\n        static get Default() {\n            return Default;\n        }\n        static get DefaultType() {\n            return DefaultType;\n        }\n        static get NAME() {\n            return NAME;\n        }\n        // Public\n        show() {\n            const showEvent = EventHandler.trigger(this._element, EVENT_SHOW);\n            if (showEvent.defaultPrevented) {\n                return;\n            }\n            this._clearTimeout();\n            if (this._config.animation) {\n                this._element.classList.add(CLASS_NAME_FADE);\n            }\n            const complete = ()=>{\n                this._element.classList.remove(CLASS_NAME_SHOWING);\n                EventHandler.trigger(this._element, EVENT_SHOWN);\n                this._maybeScheduleHide();\n            };\n            this._element.classList.remove(CLASS_NAME_HIDE); // @deprecated\n            reflow(this._element);\n            this._element.classList.add(CLASS_NAME_SHOW, CLASS_NAME_SHOWING);\n            this._queueCallback(complete, this._element, this._config.animation);\n        }\n        hide() {\n            if (!this.isShown()) {\n                return;\n            }\n            const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);\n            if (hideEvent.defaultPrevented) {\n                return;\n            }\n            const complete = ()=>{\n                this._element.classList.add(CLASS_NAME_HIDE); // @deprecated\n                this._element.classList.remove(CLASS_NAME_SHOWING, CLASS_NAME_SHOW);\n                EventHandler.trigger(this._element, EVENT_HIDDEN);\n            };\n            this._element.classList.add(CLASS_NAME_SHOWING);\n            this._queueCallback(complete, this._element, this._config.animation);\n        }\n        dispose() {\n            this._clearTimeout();\n            if (this.isShown()) {\n                this._element.classList.remove(CLASS_NAME_SHOW);\n            }\n            super.dispose();\n        }\n        isShown() {\n            return this._element.classList.contains(CLASS_NAME_SHOW);\n        }\n        // Private\n        _maybeScheduleHide() {\n            if (!this._config.autohide) {\n                return;\n            }\n            if (this._hasMouseInteraction || this._hasKeyboardInteraction) {\n                return;\n            }\n            this._timeout = setTimeout(()=>{\n                this.hide();\n            }, this._config.delay);\n        }\n        _onInteraction(event, isInteracting) {\n            switch(event.type){\n                case \"mouseover\":\n                case \"mouseout\":\n                    {\n                        this._hasMouseInteraction = isInteracting;\n                        break;\n                    }\n                case \"focusin\":\n                case \"focusout\":\n                    {\n                        this._hasKeyboardInteraction = isInteracting;\n                        break;\n                    }\n            }\n            if (isInteracting) {\n                this._clearTimeout();\n                return;\n            }\n            const nextElement = event.relatedTarget;\n            if (this._element === nextElement || this._element.contains(nextElement)) {\n                return;\n            }\n            this._maybeScheduleHide();\n        }\n        _setListeners() {\n            EventHandler.on(this._element, EVENT_MOUSEOVER, (event)=>this._onInteraction(event, true));\n            EventHandler.on(this._element, EVENT_MOUSEOUT, (event)=>this._onInteraction(event, false));\n            EventHandler.on(this._element, EVENT_FOCUSIN, (event)=>this._onInteraction(event, true));\n            EventHandler.on(this._element, EVENT_FOCUSOUT, (event)=>this._onInteraction(event, false));\n        }\n        _clearTimeout() {\n            clearTimeout(this._timeout);\n            this._timeout = null;\n        }\n        // Static\n        static jQueryInterface(config) {\n            return this.each(function() {\n                const data = Toast.getOrCreateInstance(this, config);\n                if (typeof config === \"string\") {\n                    if (typeof data[config] === \"undefined\") {\n                        throw new TypeError(`No method named \"${config}\"`);\n                    }\n                    data[config](this);\n                }\n            });\n        }\n    }\n    /**\n   * Data API implementation\n   */ enableDismissTrigger(Toast);\n    /**\n   * jQuery\n   */ defineJQueryPlugin(Toast);\n    /**\n   * --------------------------------------------------------------------------\n   * Bootstrap index.umd.js\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\n   * --------------------------------------------------------------------------\n   */ const index_umd = {\n        Alert,\n        Button,\n        Carousel,\n        Collapse,\n        Dropdown,\n        Modal,\n        Offcanvas,\n        Popover,\n        ScrollSpy,\n        Tab,\n        Toast,\n        Tooltip\n    };\n    return index_umd;\n}); //# sourceMappingURL=bootstrap.bundle.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vYm9vdHN0cmFwQDUuMy4zX0Bwb3BwZXJqcytjb3JlQDIuMTEuOC9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL2Rpc3QvanMvYm9vdHN0cmFwLmJ1bmRsZS5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7Ozs7RUFJRSxHQUNELFVBQVVBLE1BQU0sRUFBRUMsT0FBTztJQUN4QixLQUFpRCxHQUFjRSxPQUFPRCxPQUFPLEdBQUdELFlBQ2hGLENBQ3VHO0FBQ3pHLEdBQUcsUUFBTztJQUFjO0lBRXRCOzs7OztHQUtDLEdBRUQ7O0dBRUMsR0FFRCxNQUFNUSxhQUFhLElBQUlDO0lBQ3ZCLE1BQU1DLE9BQU87UUFDWEMsS0FBSUMsT0FBTyxFQUFFQyxHQUFHLEVBQUVDLFFBQVE7WUFDeEIsSUFBSSxDQUFDTixXQUFXTyxHQUFHLENBQUNILFVBQVU7Z0JBQzVCSixXQUFXRyxHQUFHLENBQUNDLFNBQVMsSUFBSUg7WUFDOUI7WUFDQSxNQUFNTyxjQUFjUixXQUFXUyxHQUFHLENBQUNMO1lBRW5DLHNEQUFzRDtZQUN0RCx1RUFBdUU7WUFDdkUsSUFBSSxDQUFDSSxZQUFZRCxHQUFHLENBQUNGLFFBQVFHLFlBQVlFLElBQUksS0FBSyxHQUFHO2dCQUNuRCxzQ0FBc0M7Z0JBQ3RDQyxRQUFRQyxLQUFLLENBQUMsQ0FBQyw0RUFBNEUsRUFBRUMsTUFBTUMsSUFBSSxDQUFDTixZQUFZTyxJQUFJLEdBQUcsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO2dCQUNqSTtZQUNGO1lBQ0FQLFlBQVlMLEdBQUcsQ0FBQ0UsS0FBS0M7UUFDdkI7UUFDQUcsS0FBSUwsT0FBTyxFQUFFQyxHQUFHO1lBQ2QsSUFBSUwsV0FBV08sR0FBRyxDQUFDSCxVQUFVO2dCQUMzQixPQUFPSixXQUFXUyxHQUFHLENBQUNMLFNBQVNLLEdBQUcsQ0FBQ0osUUFBUTtZQUM3QztZQUNBLE9BQU87UUFDVDtRQUNBVyxRQUFPWixPQUFPLEVBQUVDLEdBQUc7WUFDakIsSUFBSSxD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LElBQUksQ0FBQzR5QixRQUFRO1lBQzFCLElBQUksQ0FBQ0EsUUFBUSxHQUFHO1FBQ2xCO1FBRUEsU0FBUztRQUNULE9BQU92bUMsZ0JBQWdCK0gsTUFBTSxFQUFFO1lBQzdCLE9BQU8sSUFBSSxDQUFDc0UsSUFBSSxDQUFDO2dCQUNmLE1BQU1DLE9BQU9xa0MsTUFBTWxuQyxtQkFBbUIsQ0FBQyxJQUFJLEVBQUUxQjtnQkFDN0MsSUFBSSxPQUFPQSxXQUFXLFVBQVU7b0JBQzlCLElBQUksT0FBT3VFLElBQUksQ0FBQ3ZFLE9BQU8sS0FBSyxhQUFhO3dCQUN2QyxNQUFNLElBQUlZLFVBQVUsQ0FBQyxpQkFBaUIsRUFBRVosT0FBTyxDQUFDLENBQUM7b0JBQ25EO29CQUNBdUUsSUFBSSxDQUFDdkUsT0FBTyxDQUFDLElBQUk7Z0JBQ25CO1lBQ0Y7UUFDRjtJQUNGO0lBRUE7O0dBRUMsR0FFRHNELHFCQUFxQnNsQztJQUVyQjs7R0FFQyxHQUVEbHhDLG1CQUFtQmt4QztJQUVuQjs7Ozs7R0FLQyxHQUVELE1BQU1RLFlBQVk7UUFDaEJsbEM7UUFDQWE7UUFDQWlGO1FBQ0F5RTtRQUNBNmU7UUFDQW1IO1FBQ0E0QztRQUNBNko7UUFDQXlCO1FBQ0ErRDtRQUNBa0M7UUFDQXRLO0lBQ0Y7SUFFQSxPQUFPOEs7QUFFVCxJQUNBLDRDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL25hdmJhci8uL25vZGVfbW9kdWxlcy8ucG5wbS9ib290c3RyYXBANS4zLjNfQHBvcHBlcmpzK2NvcmVAMi4xMS44L25vZGVfbW9kdWxlcy9ib290c3RyYXAvZGlzdC9qcy9ib290c3RyYXAuYnVuZGxlLmpzP2FhMjgiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gICogQm9vdHN0cmFwIHY1LjMuMyAoaHR0cHM6Ly9nZXRib290c3RyYXAuY29tLylcbiAgKiBDb3B5cmlnaHQgMjAxMS0yMDI0IFRoZSBCb290c3RyYXAgQXV0aG9ycyAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2dyYXBocy9jb250cmlidXRvcnMpXG4gICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gICovXG4oZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICB0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XG4gIChnbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogZ2xvYmFsIHx8IHNlbGYsIGdsb2JhbC5ib290c3RyYXAgPSBmYWN0b3J5KCkpO1xufSkodGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgZG9tL2RhdGEuanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIC8qKlxuICAgKiBDb25zdGFudHNcbiAgICovXG5cbiAgY29uc3QgZWxlbWVudE1hcCA9IG5ldyBNYXAoKTtcbiAgY29uc3QgRGF0YSA9IHtcbiAgICBzZXQoZWxlbWVudCwga2V5LCBpbnN0YW5jZSkge1xuICAgICAgaWYgKCFlbGVtZW50TWFwLmhhcyhlbGVtZW50KSkge1xuICAgICAgICBlbGVtZW50TWFwLnNldChlbGVtZW50LCBuZXcgTWFwKCkpO1xuICAgICAgfVxuICAgICAgY29uc3QgaW5zdGFuY2VNYXAgPSBlbGVtZW50TWFwLmdldChlbGVtZW50KTtcblxuICAgICAgLy8gbWFrZSBpdCBjbGVhciB3ZSBvbmx5IHdhbnQgb25lIGluc3RhbmNlIHBlciBlbGVtZW50XG4gICAgICAvLyBjYW4gYmUgcmVtb3ZlZCBsYXRlciB3aGVuIG11bHRpcGxlIGtleS9pbnN0YW5jZXMgYXJlIGZpbmUgdG8gYmUgdXNlZFxuICAgICAgaWYgKCFpbnN0YW5jZU1hcC5oYXMoa2V5KSAmJiBpbnN0YW5jZU1hcC5zaXplICE9PSAwKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEJvb3RzdHJhcCBkb2Vzbid0IGFsbG93IG1vcmUgdGhhbiBvbmUgaW5zdGFuY2UgcGVyIGVsZW1lbnQuIEJvdW5kIGluc3RhbmNlOiAke0FycmF5LmZyb20oaW5zdGFuY2VNYXAua2V5cygpKVswXX0uYCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGluc3RhbmNlTWFwLnNldChrZXksIGluc3RhbmNlKTtcbiAgICB9LFxuICAgIGdldChlbGVtZW50LCBrZXkpIHtcbiAgICAgIGlmIChlbGVtZW50TWFwLmhhcyhlbGVtZW50KSkge1xuICAgICAgICByZXR1cm4gZWxlbWVudE1hcC5nZXQoZWxlbWVudCkuZ2V0KGtleSkgfHwgbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgcmVtb3ZlKGVsZW1lbnQsIGtleSkge1xuICAgICAgaWYgKCFlbGVtZW50TWFwLmhhcyhlbGVtZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpbnN0YW5jZU1hcCA9IGVsZW1lbnRNYXAuZ2V0KGVsZW1lbnQpO1xuICAgICAgaW5zdGFuY2VNYXAuZGVsZXRlKGtleSk7XG5cbiAgICAgIC8vIGZyZWUgdXAgZWxlbWVudCByZWZlcmVuY2VzIGlmIHRoZXJlIGFyZSBubyBpbnN0YW5jZXMgbGVmdCBmb3IgYW4gZWxlbWVudFxuICAgICAgaWYgKGluc3RhbmNlTWFwLnNpemUgPT09IDApIHtcbiAgICAgICAgZWxlbWVudE1hcC5kZWxldGUoZWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgdXRpbC9pbmRleC5qc1xuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgY29uc3QgTUFYX1VJRCA9IDEwMDAwMDA7XG4gIGNvbnN0IE1JTExJU0VDT05EU19NVUxUSVBMSUVSID0gMTAwMDtcbiAgY29uc3QgVFJBTlNJVElPTl9FTkQgPSAndHJhbnNpdGlvbmVuZCc7XG5cbiAgLyoqXG4gICAqIFByb3Blcmx5IGVzY2FwZSBJRHMgc2VsZWN0b3JzIHRvIGhhbmRsZSB3ZWlyZCBJRHNcbiAgICogQHBhcmFtIHtzdHJpbmd9IHNlbGVjdG9yXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAqL1xuICBjb25zdCBwYXJzZVNlbGVjdG9yID0gc2VsZWN0b3IgPT4ge1xuICAgIGlmIChzZWxlY3RvciAmJiB3aW5kb3cuQ1NTICYmIHdpbmRvdy5DU1MuZXNjYXBlKSB7XG4gICAgICAvLyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yIG5lZWRzIGVzY2FwaW5nIHRvIGhhbmRsZSBJRHMgKGh0bWw1KykgY29udGFpbmluZyBmb3IgaW5zdGFuY2UgL1xuICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKC8jKFteXFxzXCIjJ10rKS9nLCAobWF0Y2gsIGlkKSA9PiBgIyR7Q1NTLmVzY2FwZShpZCl9YCk7XG4gICAgfVxuICAgIHJldHVybiBzZWxlY3RvcjtcbiAgfTtcblxuICAvLyBTaG91dC1vdXQgQW5ndXMgQ3JvbGwgKGh0dHBzOi8vZ29vLmdsL3B4d1FHcClcbiAgY29uc3QgdG9UeXBlID0gb2JqZWN0ID0+IHtcbiAgICBpZiAob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gYCR7b2JqZWN0fWA7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KS5tYXRjaCgvXFxzKFthLXpdKykvaSlbMV0udG9Mb3dlckNhc2UoKTtcbiAgfTtcblxuICAvKipcbiAgICogUHVibGljIFV0aWwgQVBJXG4gICAqL1xuXG4gIGNvbnN0IGdldFVJRCA9IHByZWZpeCA9PiB7XG4gICAgZG8ge1xuICAgICAgcHJlZml4ICs9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIE1BWF9VSUQpO1xuICAgIH0gd2hpbGUgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHByZWZpeCkpO1xuICAgIHJldHVybiBwcmVmaXg7XG4gIH07XG4gIGNvbnN0IGdldFRyYW5zaXRpb25EdXJhdGlvbkZyb21FbGVtZW50ID0gZWxlbWVudCA9PiB7XG4gICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICByZXR1cm4gMDtcbiAgICB9XG5cbiAgICAvLyBHZXQgdHJhbnNpdGlvbi1kdXJhdGlvbiBvZiB0aGUgZWxlbWVudFxuICAgIGxldCB7XG4gICAgICB0cmFuc2l0aW9uRHVyYXRpb24sXG4gICAgICB0cmFuc2l0aW9uRGVsYXlcbiAgICB9ID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCk7XG4gICAgY29uc3QgZmxvYXRUcmFuc2l0aW9uRHVyYXRpb24gPSBOdW1iZXIucGFyc2VGbG9hdCh0cmFuc2l0aW9uRHVyYXRpb24pO1xuICAgIGNvbnN0IGZsb2F0VHJhbnNpdGlvbkRlbGF5ID0gTnVtYmVyLnBhcnNlRmxvYXQodHJhbnNpdGlvbkRlbGF5KTtcblxuICAgIC8vIFJldHVybiAwIGlmIGVsZW1lbnQgb3IgdHJhbnNpdGlvbiBkdXJhdGlvbiBpcyBub3QgZm91bmRcbiAgICBpZiAoIWZsb2F0VHJhbnNpdGlvbkR1cmF0aW9uICYmICFmbG9hdFRyYW5zaXRpb25EZWxheSkge1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLy8gSWYgbXVsdGlwbGUgZHVyYXRpb25zIGFyZSBkZWZpbmVkLCB0YWtlIHRoZSBmaXJzdFxuICAgIHRyYW5zaXRpb25EdXJhdGlvbiA9IHRyYW5zaXRpb25EdXJhdGlvbi5zcGxpdCgnLCcpWzBdO1xuICAgIHRyYW5zaXRpb25EZWxheSA9IHRyYW5zaXRpb25EZWxheS5zcGxpdCgnLCcpWzBdO1xuICAgIHJldHVybiAoTnVtYmVyLnBhcnNlRmxvYXQodHJhbnNpdGlvbkR1cmF0aW9uKSArIE51bWJlci5wYXJzZUZsb2F0KHRyYW5zaXRpb25EZWxheSkpICogTUlMTElTRUNPTkRTX01VTFRJUExJRVI7XG4gIH07XG4gIGNvbnN0IHRyaWdnZXJUcmFuc2l0aW9uRW5kID0gZWxlbWVudCA9PiB7XG4gICAgZWxlbWVudC5kaXNwYXRjaEV2ZW50KG5ldyBFdmVudChUUkFOU0lUSU9OX0VORCkpO1xuICB9O1xuICBjb25zdCBpc0VsZW1lbnQkMSA9IG9iamVjdCA9PiB7XG4gICAgaWYgKCFvYmplY3QgfHwgdHlwZW9mIG9iamVjdCAhPT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvYmplY3QuanF1ZXJ5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgb2JqZWN0ID0gb2JqZWN0WzBdO1xuICAgIH1cbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdC5ub2RlVHlwZSAhPT0gJ3VuZGVmaW5lZCc7XG4gIH07XG4gIGNvbnN0IGdldEVsZW1lbnQgPSBvYmplY3QgPT4ge1xuICAgIC8vIGl0J3MgYSBqUXVlcnkgb2JqZWN0IG9yIGEgbm9kZSBlbGVtZW50XG4gICAgaWYgKGlzRWxlbWVudCQxKG9iamVjdCkpIHtcbiAgICAgIHJldHVybiBvYmplY3QuanF1ZXJ5ID8gb2JqZWN0WzBdIDogb2JqZWN0O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIG9iamVjdCA9PT0gJ3N0cmluZycgJiYgb2JqZWN0Lmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHBhcnNlU2VsZWN0b3Iob2JqZWN0KSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuICBjb25zdCBpc1Zpc2libGUgPSBlbGVtZW50ID0+IHtcbiAgICBpZiAoIWlzRWxlbWVudCQxKGVsZW1lbnQpIHx8IGVsZW1lbnQuZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgY29uc3QgZWxlbWVudElzVmlzaWJsZSA9IGdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuZ2V0UHJvcGVydHlWYWx1ZSgndmlzaWJpbGl0eScpID09PSAndmlzaWJsZSc7XG4gICAgLy8gSGFuZGxlIGBkZXRhaWxzYCBlbGVtZW50IGFzIGl0cyBjb250ZW50IG1heSBmYWxzaWUgYXBwZWFyIHZpc2libGUgd2hlbiBpdCBpcyBjbG9zZWRcbiAgICBjb25zdCBjbG9zZWREZXRhaWxzID0gZWxlbWVudC5jbG9zZXN0KCdkZXRhaWxzOm5vdChbb3Blbl0pJyk7XG4gICAgaWYgKCFjbG9zZWREZXRhaWxzKSB7XG4gICAgICByZXR1cm4gZWxlbWVudElzVmlzaWJsZTtcbiAgICB9XG4gICAgaWYgKGNsb3NlZERldGFpbHMgIT09IGVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHN1bW1hcnkgPSBlbGVtZW50LmNsb3Nlc3QoJ3N1bW1hcnknKTtcbiAgICAgIGlmIChzdW1tYXJ5ICYmIHN1bW1hcnkucGFyZW50Tm9kZSAhPT0gY2xvc2VkRGV0YWlscykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoc3VtbWFyeSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50SXNWaXNpYmxlO1xuICB9O1xuICBjb25zdCBpc0Rpc2FibGVkID0gZWxlbWVudCA9PiB7XG4gICAgaWYgKCFlbGVtZW50IHx8IGVsZW1lbnQubm9kZVR5cGUgIT09IE5vZGUuRUxFTUVOVF9OT0RFKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKCdkaXNhYmxlZCcpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBlbGVtZW50LmRpc2FibGVkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgcmV0dXJuIGVsZW1lbnQuZGlzYWJsZWQ7XG4gICAgfVxuICAgIHJldHVybiBlbGVtZW50Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSAmJiBlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGlzYWJsZWQnKSAhPT0gJ2ZhbHNlJztcbiAgfTtcbiAgY29uc3QgZmluZFNoYWRvd1Jvb3QgPSBlbGVtZW50ID0+IHtcbiAgICBpZiAoIWRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hdHRhY2hTaGFkb3cpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIC8vIENhbiBmaW5kIHRoZSBzaGFkb3cgcm9vdCBvdGhlcndpc2UgaXQnbGwgcmV0dXJuIHRoZSBkb2N1bWVudFxuICAgIGlmICh0eXBlb2YgZWxlbWVudC5nZXRSb290Tm9kZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29uc3Qgcm9vdCA9IGVsZW1lbnQuZ2V0Um9vdE5vZGUoKTtcbiAgICAgIHJldHVybiByb290IGluc3RhbmNlb2YgU2hhZG93Um9vdCA/IHJvb3QgOiBudWxsO1xuICAgIH1cbiAgICBpZiAoZWxlbWVudCBpbnN0YW5jZW9mIFNoYWRvd1Jvb3QpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIC8vIHdoZW4gd2UgZG9uJ3QgZmluZCBhIHNoYWRvdyByb290XG4gICAgaWYgKCFlbGVtZW50LnBhcmVudE5vZGUpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZmluZFNoYWRvd1Jvb3QoZWxlbWVudC5wYXJlbnROb2RlKTtcbiAgfTtcbiAgY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xuXG4gIC8qKlxuICAgKiBUcmljayB0byByZXN0YXJ0IGFuIGVsZW1lbnQncyBhbmltYXRpb25cbiAgICpcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICAgKiBAcmV0dXJuIHZvaWRcbiAgICpcbiAgICogQHNlZSBodHRwczovL3d3dy5jaGFyaXN0aGVvLmlvL2Jsb2cvMjAyMS8wMi9yZXN0YXJ0LWEtY3NzLWFuaW1hdGlvbi13aXRoLWphdmFzY3JpcHQvI3Jlc3RhcnRpbmctYS1jc3MtYW5pbWF0aW9uXG4gICAqL1xuICBjb25zdCByZWZsb3cgPSBlbGVtZW50ID0+IHtcbiAgICBlbGVtZW50Lm9mZnNldEhlaWdodDsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnNcbiAgfTtcbiAgY29uc3QgZ2V0alF1ZXJ5ID0gKCkgPT4ge1xuICAgIGlmICh3aW5kb3cualF1ZXJ5ICYmICFkb2N1bWVudC5ib2R5Lmhhc0F0dHJpYnV0ZSgnZGF0YS1icy1uby1qcXVlcnknKSkge1xuICAgICAgcmV0dXJuIHdpbmRvdy5qUXVlcnk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9O1xuICBjb25zdCBET01Db250ZW50TG9hZGVkQ2FsbGJhY2tzID0gW107XG4gIGNvbnN0IG9uRE9NQ29udGVudExvYWRlZCA9IGNhbGxiYWNrID0+IHtcbiAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2xvYWRpbmcnKSB7XG4gICAgICAvLyBhZGQgbGlzdGVuZXIgb24gdGhlIGZpcnN0IGNhbGwgd2hlbiB0aGUgZG9jdW1lbnQgaXMgaW4gbG9hZGluZyBzdGF0ZVxuICAgICAgaWYgKCFET01Db250ZW50TG9hZGVkQ2FsbGJhY2tzLmxlbmd0aCkge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgKCkgPT4ge1xuICAgICAgICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgRE9NQ29udGVudExvYWRlZENhbGxiYWNrcykge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgRE9NQ29udGVudExvYWRlZENhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IGlzUlRMID0gKCkgPT4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRpciA9PT0gJ3J0bCc7XG4gIGNvbnN0IGRlZmluZUpRdWVyeVBsdWdpbiA9IHBsdWdpbiA9PiB7XG4gICAgb25ET01Db250ZW50TG9hZGVkKCgpID0+IHtcbiAgICAgIGNvbnN0ICQgPSBnZXRqUXVlcnkoKTtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCQpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHBsdWdpbi5OQU1FO1xuICAgICAgICBjb25zdCBKUVVFUllfTk9fQ09ORkxJQ1QgPSAkLmZuW25hbWVdO1xuICAgICAgICAkLmZuW25hbWVdID0gcGx1Z2luLmpRdWVyeUludGVyZmFjZTtcbiAgICAgICAgJC5mbltuYW1lXS5Db25zdHJ1Y3RvciA9IHBsdWdpbjtcbiAgICAgICAgJC5mbltuYW1lXS5ub0NvbmZsaWN0ID0gKCkgPT4ge1xuICAgICAgICAgICQuZm5bbmFtZV0gPSBKUVVFUllfTk9fQ09ORkxJQ1Q7XG4gICAgICAgICAgcmV0dXJuIHBsdWdpbi5qUXVlcnlJbnRlcmZhY2U7XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfSk7XG4gIH07XG4gIGNvbnN0IGV4ZWN1dGUgPSAocG9zc2libGVDYWxsYmFjaywgYXJncyA9IFtdLCBkZWZhdWx0VmFsdWUgPSBwb3NzaWJsZUNhbGxiYWNrKSA9PiB7XG4gICAgcmV0dXJuIHR5cGVvZiBwb3NzaWJsZUNhbGxiYWNrID09PSAnZnVuY3Rpb24nID8gcG9zc2libGVDYWxsYmFjayguLi5hcmdzKSA6IGRlZmF1bHRWYWx1ZTtcbiAgfTtcbiAgY29uc3QgZXhlY3V0ZUFmdGVyVHJhbnNpdGlvbiA9IChjYWxsYmFjaywgdHJhbnNpdGlvbkVsZW1lbnQsIHdhaXRGb3JUcmFuc2l0aW9uID0gdHJ1ZSkgPT4ge1xuICAgIGlmICghd2FpdEZvclRyYW5zaXRpb24pIHtcbiAgICAgIGV4ZWN1dGUoY2FsbGJhY2spO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBkdXJhdGlvblBhZGRpbmcgPSA1O1xuICAgIGNvbnN0IGVtdWxhdGVkRHVyYXRpb24gPSBnZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCh0cmFuc2l0aW9uRWxlbWVudCkgKyBkdXJhdGlvblBhZGRpbmc7XG4gICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGhhbmRsZXIgPSAoe1xuICAgICAgdGFyZ2V0XG4gICAgfSkgPT4ge1xuICAgICAgaWYgKHRhcmdldCAhPT0gdHJhbnNpdGlvbkVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY2FsbGVkID0gdHJ1ZTtcbiAgICAgIHRyYW5zaXRpb25FbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoVFJBTlNJVElPTl9FTkQsIGhhbmRsZXIpO1xuICAgICAgZXhlY3V0ZShjYWxsYmFjayk7XG4gICAgfTtcbiAgICB0cmFuc2l0aW9uRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFRSQU5TSVRJT05fRU5ELCBoYW5kbGVyKTtcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGlmICghY2FsbGVkKSB7XG4gICAgICAgIHRyaWdnZXJUcmFuc2l0aW9uRW5kKHRyYW5zaXRpb25FbGVtZW50KTtcbiAgICAgIH1cbiAgICB9LCBlbXVsYXRlZER1cmF0aW9uKTtcbiAgfTtcblxuICAvKipcbiAgICogUmV0dXJuIHRoZSBwcmV2aW91cy9uZXh0IGVsZW1lbnQgb2YgYSBsaXN0LlxuICAgKlxuICAgKiBAcGFyYW0ge2FycmF5fSBsaXN0ICAgIFRoZSBsaXN0IG9mIGVsZW1lbnRzXG4gICAqIEBwYXJhbSBhY3RpdmVFbGVtZW50ICAgVGhlIGFjdGl2ZSBlbGVtZW50XG4gICAqIEBwYXJhbSBzaG91bGRHZXROZXh0ICAgQ2hvb3NlIHRvIGdldCBuZXh0IG9yIHByZXZpb3VzIGVsZW1lbnRcbiAgICogQHBhcmFtIGlzQ3ljbGVBbGxvd2VkXG4gICAqIEByZXR1cm4ge0VsZW1lbnR8ZWxlbX0gVGhlIHByb3BlciBlbGVtZW50XG4gICAqL1xuICBjb25zdCBnZXROZXh0QWN0aXZlRWxlbWVudCA9IChsaXN0LCBhY3RpdmVFbGVtZW50LCBzaG91bGRHZXROZXh0LCBpc0N5Y2xlQWxsb3dlZCkgPT4ge1xuICAgIGNvbnN0IGxpc3RMZW5ndGggPSBsaXN0Lmxlbmd0aDtcbiAgICBsZXQgaW5kZXggPSBsaXN0LmluZGV4T2YoYWN0aXZlRWxlbWVudCk7XG5cbiAgICAvLyBpZiB0aGUgZWxlbWVudCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgbGlzdCByZXR1cm4gYW4gZWxlbWVudFxuICAgIC8vIGRlcGVuZGluZyBvbiB0aGUgZGlyZWN0aW9uIGFuZCBpZiBjeWNsZSBpcyBhbGxvd2VkXG4gICAgaWYgKGluZGV4ID09PSAtMSkge1xuICAgICAgcmV0dXJuICFzaG91bGRHZXROZXh0ICYmIGlzQ3ljbGVBbGxvd2VkID8gbGlzdFtsaXN0TGVuZ3RoIC0gMV0gOiBsaXN0WzBdO1xuICAgIH1cbiAgICBpbmRleCArPSBzaG91bGRHZXROZXh0ID8gMSA6IC0xO1xuICAgIGlmIChpc0N5Y2xlQWxsb3dlZCkge1xuICAgICAgaW5kZXggPSAoaW5kZXggKyBsaXN0TGVuZ3RoKSAlIGxpc3RMZW5ndGg7XG4gICAgfVxuICAgIHJldHVybiBsaXN0W01hdGgubWF4KDAsIE1hdGgubWluKGluZGV4LCBsaXN0TGVuZ3RoIC0gMSkpXTtcbiAgfTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQm9vdHN0cmFwIGRvbS9ldmVudC1oYW5kbGVyLmpzXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuXG4gIC8qKlxuICAgKiBDb25zdGFudHNcbiAgICovXG5cbiAgY29uc3QgbmFtZXNwYWNlUmVnZXggPSAvW14uXSooPz1cXC4uKilcXC58LiovO1xuICBjb25zdCBzdHJpcE5hbWVSZWdleCA9IC9cXC4uKi87XG4gIGNvbnN0IHN0cmlwVWlkUmVnZXggPSAvOjpcXGQrJC87XG4gIGNvbnN0IGV2ZW50UmVnaXN0cnkgPSB7fTsgLy8gRXZlbnRzIHN0b3JhZ2VcbiAgbGV0IHVpZEV2ZW50ID0gMTtcbiAgY29uc3QgY3VzdG9tRXZlbnRzID0ge1xuICAgIG1vdXNlZW50ZXI6ICdtb3VzZW92ZXInLFxuICAgIG1vdXNlbGVhdmU6ICdtb3VzZW91dCdcbiAgfTtcbiAgY29uc3QgbmF0aXZlRXZlbnRzID0gbmV3IFNldChbJ2NsaWNrJywgJ2RibGNsaWNrJywgJ21vdXNldXAnLCAnbW91c2Vkb3duJywgJ2NvbnRleHRtZW51JywgJ21vdXNld2hlZWwnLCAnRE9NTW91c2VTY3JvbGwnLCAnbW91c2VvdmVyJywgJ21vdXNlb3V0JywgJ21vdXNlbW92ZScsICdzZWxlY3RzdGFydCcsICdzZWxlY3RlbmQnLCAna2V5ZG93bicsICdrZXlwcmVzcycsICdrZXl1cCcsICdvcmllbnRhdGlvbmNoYW5nZScsICd0b3VjaHN0YXJ0JywgJ3RvdWNobW92ZScsICd0b3VjaGVuZCcsICd0b3VjaGNhbmNlbCcsICdwb2ludGVyZG93bicsICdwb2ludGVybW92ZScsICdwb2ludGVydXAnLCAncG9pbnRlcmxlYXZlJywgJ3BvaW50ZXJjYW5jZWwnLCAnZ2VzdHVyZXN0YXJ0JywgJ2dlc3R1cmVjaGFuZ2UnLCAnZ2VzdHVyZWVuZCcsICdmb2N1cycsICdibHVyJywgJ2NoYW5nZScsICdyZXNldCcsICdzZWxlY3QnLCAnc3VibWl0JywgJ2ZvY3VzaW4nLCAnZm9jdXNvdXQnLCAnbG9hZCcsICd1bmxvYWQnLCAnYmVmb3JldW5sb2FkJywgJ3Jlc2l6ZScsICdtb3ZlJywgJ0RPTUNvbnRlbnRMb2FkZWQnLCAncmVhZHlzdGF0ZWNoYW5nZScsICdlcnJvcicsICdhYm9ydCcsICdzY3JvbGwnXSk7XG5cbiAgLyoqXG4gICAqIFByaXZhdGUgbWV0aG9kc1xuICAgKi9cblxuICBmdW5jdGlvbiBtYWtlRXZlbnRVaWQoZWxlbWVudCwgdWlkKSB7XG4gICAgcmV0dXJuIHVpZCAmJiBgJHt1aWR9Ojoke3VpZEV2ZW50Kyt9YCB8fCBlbGVtZW50LnVpZEV2ZW50IHx8IHVpZEV2ZW50Kys7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0RWxlbWVudEV2ZW50cyhlbGVtZW50KSB7XG4gICAgY29uc3QgdWlkID0gbWFrZUV2ZW50VWlkKGVsZW1lbnQpO1xuICAgIGVsZW1lbnQudWlkRXZlbnQgPSB1aWQ7XG4gICAgZXZlbnRSZWdpc3RyeVt1aWRdID0gZXZlbnRSZWdpc3RyeVt1aWRdIHx8IHt9O1xuICAgIHJldHVybiBldmVudFJlZ2lzdHJ5W3VpZF07XG4gIH1cbiAgZnVuY3Rpb24gYm9vdHN0cmFwSGFuZGxlcihlbGVtZW50LCBmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiBoYW5kbGVyKGV2ZW50KSB7XG4gICAgICBoeWRyYXRlT2JqKGV2ZW50LCB7XG4gICAgICAgIGRlbGVnYXRlVGFyZ2V0OiBlbGVtZW50XG4gICAgICB9KTtcbiAgICAgIGlmIChoYW5kbGVyLm9uZU9mZikge1xuICAgICAgICBFdmVudEhhbmRsZXIub2ZmKGVsZW1lbnQsIGV2ZW50LnR5cGUsIGZuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmbi5hcHBseShlbGVtZW50LCBbZXZlbnRdKTtcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGJvb3RzdHJhcERlbGVnYXRpb25IYW5kbGVyKGVsZW1lbnQsIHNlbGVjdG9yLCBmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiBoYW5kbGVyKGV2ZW50KSB7XG4gICAgICBjb25zdCBkb21FbGVtZW50cyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XG4gICAgICBmb3IgKGxldCB7XG4gICAgICAgIHRhcmdldFxuICAgICAgfSA9IGV2ZW50OyB0YXJnZXQgJiYgdGFyZ2V0ICE9PSB0aGlzOyB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGRvbUVsZW1lbnQgb2YgZG9tRWxlbWVudHMpIHtcbiAgICAgICAgICBpZiAoZG9tRWxlbWVudCAhPT0gdGFyZ2V0KSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaHlkcmF0ZU9iaihldmVudCwge1xuICAgICAgICAgICAgZGVsZWdhdGVUYXJnZXQ6IHRhcmdldFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGlmIChoYW5kbGVyLm9uZU9mZikge1xuICAgICAgICAgICAgRXZlbnRIYW5kbGVyLm9mZihlbGVtZW50LCBldmVudC50eXBlLCBzZWxlY3RvciwgZm4pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZm4uYXBwbHkodGFyZ2V0LCBbZXZlbnRdKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gIH1cbiAgZnVuY3Rpb24gZmluZEhhbmRsZXIoZXZlbnRzLCBjYWxsYWJsZSwgZGVsZWdhdGlvblNlbGVjdG9yID0gbnVsbCkge1xuICAgIHJldHVybiBPYmplY3QudmFsdWVzKGV2ZW50cykuZmluZChldmVudCA9PiBldmVudC5jYWxsYWJsZSA9PT0gY2FsbGFibGUgJiYgZXZlbnQuZGVsZWdhdGlvblNlbGVjdG9yID09PSBkZWxlZ2F0aW9uU2VsZWN0b3IpO1xuICB9XG4gIGZ1bmN0aW9uIG5vcm1hbGl6ZVBhcmFtZXRlcnMob3JpZ2luYWxUeXBlRXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25GdW5jdGlvbikge1xuICAgIGNvbnN0IGlzRGVsZWdhdGVkID0gdHlwZW9mIGhhbmRsZXIgPT09ICdzdHJpbmcnO1xuICAgIC8vIFRPRE86IHRvb2x0aXAgcGFzc2VzIGBmYWxzZWAgaW5zdGVhZCBvZiBzZWxlY3Rvciwgc28gd2UgbmVlZCB0byBjaGVja1xuICAgIGNvbnN0IGNhbGxhYmxlID0gaXNEZWxlZ2F0ZWQgPyBkZWxlZ2F0aW9uRnVuY3Rpb24gOiBoYW5kbGVyIHx8IGRlbGVnYXRpb25GdW5jdGlvbjtcbiAgICBsZXQgdHlwZUV2ZW50ID0gZ2V0VHlwZUV2ZW50KG9yaWdpbmFsVHlwZUV2ZW50KTtcbiAgICBpZiAoIW5hdGl2ZUV2ZW50cy5oYXModHlwZUV2ZW50KSkge1xuICAgICAgdHlwZUV2ZW50ID0gb3JpZ2luYWxUeXBlRXZlbnQ7XG4gICAgfVxuICAgIHJldHVybiBbaXNEZWxlZ2F0ZWQsIGNhbGxhYmxlLCB0eXBlRXZlbnRdO1xuICB9XG4gIGZ1bmN0aW9uIGFkZEhhbmRsZXIoZWxlbWVudCwgb3JpZ2luYWxUeXBlRXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25GdW5jdGlvbiwgb25lT2ZmKSB7XG4gICAgaWYgKHR5cGVvZiBvcmlnaW5hbFR5cGVFdmVudCAhPT0gJ3N0cmluZycgfHwgIWVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgbGV0IFtpc0RlbGVnYXRlZCwgY2FsbGFibGUsIHR5cGVFdmVudF0gPSBub3JtYWxpemVQYXJhbWV0ZXJzKG9yaWdpbmFsVHlwZUV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRnVuY3Rpb24pO1xuXG4gICAgLy8gaW4gY2FzZSBvZiBtb3VzZWVudGVyIG9yIG1vdXNlbGVhdmUgd3JhcCB0aGUgaGFuZGxlciB3aXRoaW4gYSBmdW5jdGlvbiB0aGF0IGNoZWNrcyBmb3IgaXRzIERPTSBwb3NpdGlvblxuICAgIC8vIHRoaXMgcHJldmVudHMgdGhlIGhhbmRsZXIgZnJvbSBiZWluZyBkaXNwYXRjaGVkIHRoZSBzYW1lIHdheSBhcyBtb3VzZW92ZXIgb3IgbW91c2VvdXQgZG9lc1xuICAgIGlmIChvcmlnaW5hbFR5cGVFdmVudCBpbiBjdXN0b21FdmVudHMpIHtcbiAgICAgIGNvbnN0IHdyYXBGdW5jdGlvbiA9IGZuID0+IHtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICAgIGlmICghZXZlbnQucmVsYXRlZFRhcmdldCB8fCBldmVudC5yZWxhdGVkVGFyZ2V0ICE9PSBldmVudC5kZWxlZ2F0ZVRhcmdldCAmJiAhZXZlbnQuZGVsZWdhdGVUYXJnZXQuY29udGFpbnMoZXZlbnQucmVsYXRlZFRhcmdldCkpIHtcbiAgICAgICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgY2FsbGFibGUgPSB3cmFwRnVuY3Rpb24oY2FsbGFibGUpO1xuICAgIH1cbiAgICBjb25zdCBldmVudHMgPSBnZXRFbGVtZW50RXZlbnRzKGVsZW1lbnQpO1xuICAgIGNvbnN0IGhhbmRsZXJzID0gZXZlbnRzW3R5cGVFdmVudF0gfHwgKGV2ZW50c1t0eXBlRXZlbnRdID0ge30pO1xuICAgIGNvbnN0IHByZXZpb3VzRnVuY3Rpb24gPSBmaW5kSGFuZGxlcihoYW5kbGVycywgY2FsbGFibGUsIGlzRGVsZWdhdGVkID8gaGFuZGxlciA6IG51bGwpO1xuICAgIGlmIChwcmV2aW91c0Z1bmN0aW9uKSB7XG4gICAgICBwcmV2aW91c0Z1bmN0aW9uLm9uZU9mZiA9IHByZXZpb3VzRnVuY3Rpb24ub25lT2ZmICYmIG9uZU9mZjtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdWlkID0gbWFrZUV2ZW50VWlkKGNhbGxhYmxlLCBvcmlnaW5hbFR5cGVFdmVudC5yZXBsYWNlKG5hbWVzcGFjZVJlZ2V4LCAnJykpO1xuICAgIGNvbnN0IGZuID0gaXNEZWxlZ2F0ZWQgPyBib290c3RyYXBEZWxlZ2F0aW9uSGFuZGxlcihlbGVtZW50LCBoYW5kbGVyLCBjYWxsYWJsZSkgOiBib290c3RyYXBIYW5kbGVyKGVsZW1lbnQsIGNhbGxhYmxlKTtcbiAgICBmbi5kZWxlZ2F0aW9uU2VsZWN0b3IgPSBpc0RlbGVnYXRlZCA/IGhhbmRsZXIgOiBudWxsO1xuICAgIGZuLmNhbGxhYmxlID0gY2FsbGFibGU7XG4gICAgZm4ub25lT2ZmID0gb25lT2ZmO1xuICAgIGZuLnVpZEV2ZW50ID0gdWlkO1xuICAgIGhhbmRsZXJzW3VpZF0gPSBmbjtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIodHlwZUV2ZW50LCBmbiwgaXNEZWxlZ2F0ZWQpO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZUhhbmRsZXIoZWxlbWVudCwgZXZlbnRzLCB0eXBlRXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25TZWxlY3Rvcikge1xuICAgIGNvbnN0IGZuID0gZmluZEhhbmRsZXIoZXZlbnRzW3R5cGVFdmVudF0sIGhhbmRsZXIsIGRlbGVnYXRpb25TZWxlY3Rvcik7XG4gICAgaWYgKCFmbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZUV2ZW50LCBmbiwgQm9vbGVhbihkZWxlZ2F0aW9uU2VsZWN0b3IpKTtcbiAgICBkZWxldGUgZXZlbnRzW3R5cGVFdmVudF1bZm4udWlkRXZlbnRdO1xuICB9XG4gIGZ1bmN0aW9uIHJlbW92ZU5hbWVzcGFjZWRIYW5kbGVycyhlbGVtZW50LCBldmVudHMsIHR5cGVFdmVudCwgbmFtZXNwYWNlKSB7XG4gICAgY29uc3Qgc3RvcmVFbGVtZW50RXZlbnQgPSBldmVudHNbdHlwZUV2ZW50XSB8fCB7fTtcbiAgICBmb3IgKGNvbnN0IFtoYW5kbGVyS2V5LCBldmVudF0gb2YgT2JqZWN0LmVudHJpZXMoc3RvcmVFbGVtZW50RXZlbnQpKSB7XG4gICAgICBpZiAoaGFuZGxlcktleS5pbmNsdWRlcyhuYW1lc3BhY2UpKSB7XG4gICAgICAgIHJlbW92ZUhhbmRsZXIoZWxlbWVudCwgZXZlbnRzLCB0eXBlRXZlbnQsIGV2ZW50LmNhbGxhYmxlLCBldmVudC5kZWxlZ2F0aW9uU2VsZWN0b3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBnZXRUeXBlRXZlbnQoZXZlbnQpIHtcbiAgICAvLyBhbGxvdyB0byBnZXQgdGhlIG5hdGl2ZSBldmVudHMgZnJvbSBuYW1lc3BhY2VkIGV2ZW50cyAoJ2NsaWNrLmJzLmJ1dHRvbicgLS0+ICdjbGljaycpXG4gICAgZXZlbnQgPSBldmVudC5yZXBsYWNlKHN0cmlwTmFtZVJlZ2V4LCAnJyk7XG4gICAgcmV0dXJuIGN1c3RvbUV2ZW50c1tldmVudF0gfHwgZXZlbnQ7XG4gIH1cbiAgY29uc3QgRXZlbnRIYW5kbGVyID0ge1xuICAgIG9uKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRnVuY3Rpb24pIHtcbiAgICAgIGFkZEhhbmRsZXIoZWxlbWVudCwgZXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25GdW5jdGlvbiwgZmFsc2UpO1xuICAgIH0sXG4gICAgb25lKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRnVuY3Rpb24pIHtcbiAgICAgIGFkZEhhbmRsZXIoZWxlbWVudCwgZXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25GdW5jdGlvbiwgdHJ1ZSk7XG4gICAgfSxcbiAgICBvZmYoZWxlbWVudCwgb3JpZ2luYWxUeXBlRXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25GdW5jdGlvbikge1xuICAgICAgaWYgKHR5cGVvZiBvcmlnaW5hbFR5cGVFdmVudCAhPT0gJ3N0cmluZycgfHwgIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgW2lzRGVsZWdhdGVkLCBjYWxsYWJsZSwgdHlwZUV2ZW50XSA9IG5vcm1hbGl6ZVBhcmFtZXRlcnMob3JpZ2luYWxUeXBlRXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25GdW5jdGlvbik7XG4gICAgICBjb25zdCBpbk5hbWVzcGFjZSA9IHR5cGVFdmVudCAhPT0gb3JpZ2luYWxUeXBlRXZlbnQ7XG4gICAgICBjb25zdCBldmVudHMgPSBnZXRFbGVtZW50RXZlbnRzKGVsZW1lbnQpO1xuICAgICAgY29uc3Qgc3RvcmVFbGVtZW50RXZlbnQgPSBldmVudHNbdHlwZUV2ZW50XSB8fCB7fTtcbiAgICAgIGNvbnN0IGlzTmFtZXNwYWNlID0gb3JpZ2luYWxUeXBlRXZlbnQuc3RhcnRzV2l0aCgnLicpO1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYWJsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgLy8gU2ltcGxlc3QgY2FzZTogaGFuZGxlciBpcyBwYXNzZWQsIHJlbW92ZSB0aGF0IGxpc3RlbmVyIE9OTFkuXG4gICAgICAgIGlmICghT2JqZWN0LmtleXMoc3RvcmVFbGVtZW50RXZlbnQpLmxlbmd0aCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICByZW1vdmVIYW5kbGVyKGVsZW1lbnQsIGV2ZW50cywgdHlwZUV2ZW50LCBjYWxsYWJsZSwgaXNEZWxlZ2F0ZWQgPyBoYW5kbGVyIDogbnVsbCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChpc05hbWVzcGFjZSkge1xuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnRFdmVudCBvZiBPYmplY3Qua2V5cyhldmVudHMpKSB7XG4gICAgICAgICAgcmVtb3ZlTmFtZXNwYWNlZEhhbmRsZXJzKGVsZW1lbnQsIGV2ZW50cywgZWxlbWVudEV2ZW50LCBvcmlnaW5hbFR5cGVFdmVudC5zbGljZSgxKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgW2tleUhhbmRsZXJzLCBldmVudF0gb2YgT2JqZWN0LmVudHJpZXMoc3RvcmVFbGVtZW50RXZlbnQpKSB7XG4gICAgICAgIGNvbnN0IGhhbmRsZXJLZXkgPSBrZXlIYW5kbGVycy5yZXBsYWNlKHN0cmlwVWlkUmVnZXgsICcnKTtcbiAgICAgICAgaWYgKCFpbk5hbWVzcGFjZSB8fCBvcmlnaW5hbFR5cGVFdmVudC5pbmNsdWRlcyhoYW5kbGVyS2V5KSkge1xuICAgICAgICAgIHJlbW92ZUhhbmRsZXIoZWxlbWVudCwgZXZlbnRzLCB0eXBlRXZlbnQsIGV2ZW50LmNhbGxhYmxlLCBldmVudC5kZWxlZ2F0aW9uU2VsZWN0b3IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICB0cmlnZ2VyKGVsZW1lbnQsIGV2ZW50LCBhcmdzKSB7XG4gICAgICBpZiAodHlwZW9mIGV2ZW50ICE9PSAnc3RyaW5nJyB8fCAhZWxlbWVudCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0ICQgPSBnZXRqUXVlcnkoKTtcbiAgICAgIGNvbnN0IHR5cGVFdmVudCA9IGdldFR5cGVFdmVudChldmVudCk7XG4gICAgICBjb25zdCBpbk5hbWVzcGFjZSA9IGV2ZW50ICE9PSB0eXBlRXZlbnQ7XG4gICAgICBsZXQgalF1ZXJ5RXZlbnQgPSBudWxsO1xuICAgICAgbGV0IGJ1YmJsZXMgPSB0cnVlO1xuICAgICAgbGV0IG5hdGl2ZURpc3BhdGNoID0gdHJ1ZTtcbiAgICAgIGxldCBkZWZhdWx0UHJldmVudGVkID0gZmFsc2U7XG4gICAgICBpZiAoaW5OYW1lc3BhY2UgJiYgJCkge1xuICAgICAgICBqUXVlcnlFdmVudCA9ICQuRXZlbnQoZXZlbnQsIGFyZ3MpO1xuICAgICAgICAkKGVsZW1lbnQpLnRyaWdnZXIoalF1ZXJ5RXZlbnQpO1xuICAgICAgICBidWJibGVzID0gIWpRdWVyeUV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCk7XG4gICAgICAgIG5hdGl2ZURpc3BhdGNoID0gIWpRdWVyeUV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCk7XG4gICAgICAgIGRlZmF1bHRQcmV2ZW50ZWQgPSBqUXVlcnlFdmVudC5pc0RlZmF1bHRQcmV2ZW50ZWQoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGV2dCA9IGh5ZHJhdGVPYmoobmV3IEV2ZW50KGV2ZW50LCB7XG4gICAgICAgIGJ1YmJsZXMsXG4gICAgICAgIGNhbmNlbGFibGU6IHRydWVcbiAgICAgIH0pLCBhcmdzKTtcbiAgICAgIGlmIChkZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgfVxuICAgICAgaWYgKG5hdGl2ZURpc3BhdGNoKSB7XG4gICAgICAgIGVsZW1lbnQuZGlzcGF0Y2hFdmVudChldnQpO1xuICAgICAgfVxuICAgICAgaWYgKGV2dC5kZWZhdWx0UHJldmVudGVkICYmIGpRdWVyeUV2ZW50KSB7XG4gICAgICAgIGpRdWVyeUV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZXZ0O1xuICAgIH1cbiAgfTtcbiAgZnVuY3Rpb24gaHlkcmF0ZU9iaihvYmosIG1ldGEgPSB7fSkge1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKG1ldGEpKSB7XG4gICAgICB0cnkge1xuICAgICAgICBvYmpba2V5XSA9IHZhbHVlO1xuICAgICAgfSBjYXRjaCAoX3VudXNlZCkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQm9vdHN0cmFwIGRvbS9tYW5pcHVsYXRvci5qc1xuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cbiAgZnVuY3Rpb24gbm9ybWFsaXplRGF0YSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gJ3RydWUnKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSAnZmFsc2UnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gTnVtYmVyKHZhbHVlKS50b1N0cmluZygpKSB7XG4gICAgICByZXR1cm4gTnVtYmVyKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlID09PSAnJyB8fCB2YWx1ZSA9PT0gJ251bGwnKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBKU09OLnBhcnNlKGRlY29kZVVSSUNvbXBvbmVudCh2YWx1ZSkpO1xuICAgIH0gY2F0Y2ggKF91bnVzZWQpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gbm9ybWFsaXplRGF0YUtleShrZXkpIHtcbiAgICByZXR1cm4ga2V5LnJlcGxhY2UoL1tBLVpdL2csIGNociA9PiBgLSR7Y2hyLnRvTG93ZXJDYXNlKCl9YCk7XG4gIH1cbiAgY29uc3QgTWFuaXB1bGF0b3IgPSB7XG4gICAgc2V0RGF0YUF0dHJpYnV0ZShlbGVtZW50LCBrZXksIHZhbHVlKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShgZGF0YS1icy0ke25vcm1hbGl6ZURhdGFLZXkoa2V5KX1gLCB2YWx1ZSk7XG4gICAgfSxcbiAgICByZW1vdmVEYXRhQXR0cmlidXRlKGVsZW1lbnQsIGtleSkge1xuICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYGRhdGEtYnMtJHtub3JtYWxpemVEYXRhS2V5KGtleSl9YCk7XG4gICAgfSxcbiAgICBnZXREYXRhQXR0cmlidXRlcyhlbGVtZW50KSB7XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xuICAgICAgY29uc3QgYnNLZXlzID0gT2JqZWN0LmtleXMoZWxlbWVudC5kYXRhc2V0KS5maWx0ZXIoa2V5ID0+IGtleS5zdGFydHNXaXRoKCdicycpICYmICFrZXkuc3RhcnRzV2l0aCgnYnNDb25maWcnKSk7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBic0tleXMpIHtcbiAgICAgICAgbGV0IHB1cmVLZXkgPSBrZXkucmVwbGFjZSgvXmJzLywgJycpO1xuICAgICAgICBwdXJlS2V5ID0gcHVyZUtleS5jaGFyQXQoMCkudG9Mb3dlckNhc2UoKSArIHB1cmVLZXkuc2xpY2UoMSwgcHVyZUtleS5sZW5ndGgpO1xuICAgICAgICBhdHRyaWJ1dGVzW3B1cmVLZXldID0gbm9ybWFsaXplRGF0YShlbGVtZW50LmRhdGFzZXRba2V5XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgICB9LFxuICAgIGdldERhdGFBdHRyaWJ1dGUoZWxlbWVudCwga2V5KSB7XG4gICAgICByZXR1cm4gbm9ybWFsaXplRGF0YShlbGVtZW50LmdldEF0dHJpYnV0ZShgZGF0YS1icy0ke25vcm1hbGl6ZURhdGFLZXkoa2V5KX1gKSk7XG4gICAgfVxuICB9O1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgdXRpbC9jb25maWcuanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIENsYXNzIGRlZmluaXRpb25cbiAgICovXG5cbiAgY2xhc3MgQ29uZmlnIHtcbiAgICAvLyBHZXR0ZXJzXG4gICAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBoYXZlIHRvIGltcGxlbWVudCB0aGUgc3RhdGljIG1ldGhvZCBcIk5BTUVcIiwgZm9yIGVhY2ggY29tcG9uZW50IScpO1xuICAgIH1cbiAgICBfZ2V0Q29uZmlnKGNvbmZpZykge1xuICAgICAgY29uZmlnID0gdGhpcy5fbWVyZ2VDb25maWdPYmooY29uZmlnKTtcbiAgICAgIGNvbmZpZyA9IHRoaXMuX2NvbmZpZ0FmdGVyTWVyZ2UoY29uZmlnKTtcbiAgICAgIHRoaXMuX3R5cGVDaGVja0NvbmZpZyhjb25maWcpO1xuICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG4gICAgX2NvbmZpZ0FmdGVyTWVyZ2UoY29uZmlnKSB7XG4gICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cbiAgICBfbWVyZ2VDb25maWdPYmooY29uZmlnLCBlbGVtZW50KSB7XG4gICAgICBjb25zdCBqc29uQ29uZmlnID0gaXNFbGVtZW50JDEoZWxlbWVudCkgPyBNYW5pcHVsYXRvci5nZXREYXRhQXR0cmlidXRlKGVsZW1lbnQsICdjb25maWcnKSA6IHt9OyAvLyB0cnkgdG8gcGFyc2VcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4udGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0LFxuICAgICAgICAuLi4odHlwZW9mIGpzb25Db25maWcgPT09ICdvYmplY3QnID8ganNvbkNvbmZpZyA6IHt9KSxcbiAgICAgICAgLi4uKGlzRWxlbWVudCQxKGVsZW1lbnQpID8gTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZXMoZWxlbWVudCkgOiB7fSksXG4gICAgICAgIC4uLih0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyA/IGNvbmZpZyA6IHt9KVxuICAgICAgfTtcbiAgICB9XG4gICAgX3R5cGVDaGVja0NvbmZpZyhjb25maWcsIGNvbmZpZ1R5cGVzID0gdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0VHlwZSkge1xuICAgICAgZm9yIChjb25zdCBbcHJvcGVydHksIGV4cGVjdGVkVHlwZXNdIG9mIE9iamVjdC5lbnRyaWVzKGNvbmZpZ1R5cGVzKSkge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IGNvbmZpZ1twcm9wZXJ0eV07XG4gICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IGlzRWxlbWVudCQxKHZhbHVlKSA/ICdlbGVtZW50JyA6IHRvVHlwZSh2YWx1ZSk7XG4gICAgICAgIGlmICghbmV3IFJlZ0V4cChleHBlY3RlZFR5cGVzKS50ZXN0KHZhbHVlVHlwZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGAke3RoaXMuY29uc3RydWN0b3IuTkFNRS50b1VwcGVyQ2FzZSgpfTogT3B0aW9uIFwiJHtwcm9wZXJ0eX1cIiBwcm92aWRlZCB0eXBlIFwiJHt2YWx1ZVR5cGV9XCIgYnV0IGV4cGVjdGVkIHR5cGUgXCIke2V4cGVjdGVkVHlwZXN9XCIuYCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQm9vdHN0cmFwIGJhc2UtY29tcG9uZW50LmpzXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuXG4gIC8qKlxuICAgKiBDb25zdGFudHNcbiAgICovXG5cbiAgY29uc3QgVkVSU0lPTiA9ICc1LjMuMyc7XG5cbiAgLyoqXG4gICAqIENsYXNzIGRlZmluaXRpb25cbiAgICovXG5cbiAgY2xhc3MgQmFzZUNvbXBvbmVudCBleHRlbmRzIENvbmZpZyB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgICBzdXBlcigpO1xuICAgICAgZWxlbWVudCA9IGdldEVsZW1lbnQoZWxlbWVudCk7XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcbiAgICAgIERhdGEuc2V0KHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVksIHRoaXMpO1xuICAgIH1cblxuICAgIC8vIFB1YmxpY1xuICAgIGRpc3Bvc2UoKSB7XG4gICAgICBEYXRhLnJlbW92ZSh0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZKTtcbiAgICAgIEV2ZW50SGFuZGxlci5vZmYodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5FVkVOVF9LRVkpO1xuICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eU5hbWUgb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykpIHtcbiAgICAgICAgdGhpc1twcm9wZXJ0eU5hbWVdID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgX3F1ZXVlQ2FsbGJhY2soY2FsbGJhY2ssIGVsZW1lbnQsIGlzQW5pbWF0ZWQgPSB0cnVlKSB7XG4gICAgICBleGVjdXRlQWZ0ZXJUcmFuc2l0aW9uKGNhbGxiYWNrLCBlbGVtZW50LCBpc0FuaW1hdGVkKTtcbiAgICB9XG4gICAgX2dldENvbmZpZyhjb25maWcpIHtcbiAgICAgIGNvbmZpZyA9IHRoaXMuX21lcmdlQ29uZmlnT2JqKGNvbmZpZywgdGhpcy5fZWxlbWVudCk7XG4gICAgICBjb25maWcgPSB0aGlzLl9jb25maWdBZnRlck1lcmdlKGNvbmZpZyk7XG4gICAgICB0aGlzLl90eXBlQ2hlY2tDb25maWcoY29uZmlnKTtcbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuXG4gICAgLy8gU3RhdGljXG4gICAgc3RhdGljIGdldEluc3RhbmNlKGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiBEYXRhLmdldChnZXRFbGVtZW50KGVsZW1lbnQpLCB0aGlzLkRBVEFfS0VZKTtcbiAgICB9XG4gICAgc3RhdGljIGdldE9yQ3JlYXRlSW5zdGFuY2UoZWxlbWVudCwgY29uZmlnID0ge30pIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKGVsZW1lbnQpIHx8IG5ldyB0aGlzKGVsZW1lbnQsIHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnID8gY29uZmlnIDogbnVsbCk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgVkVSU0lPTigpIHtcbiAgICAgIHJldHVybiBWRVJTSU9OO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IERBVEFfS0VZKCkge1xuICAgICAgcmV0dXJuIGBicy4ke3RoaXMuTkFNRX1gO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IEVWRU5UX0tFWSgpIHtcbiAgICAgIHJldHVybiBgLiR7dGhpcy5EQVRBX0tFWX1gO1xuICAgIH1cbiAgICBzdGF0aWMgZXZlbnROYW1lKG5hbWUpIHtcbiAgICAgIHJldHVybiBgJHtuYW1lfSR7dGhpcy5FVkVOVF9LRVl9YDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQm9vdHN0cmFwIGRvbS9zZWxlY3Rvci1lbmdpbmUuanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIGNvbnN0IGdldFNlbGVjdG9yID0gZWxlbWVudCA9PiB7XG4gICAgbGV0IHNlbGVjdG9yID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtdGFyZ2V0Jyk7XG4gICAgaWYgKCFzZWxlY3RvciB8fCBzZWxlY3RvciA9PT0gJyMnKSB7XG4gICAgICBsZXQgaHJlZkF0dHJpYnV0ZSA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdocmVmJyk7XG5cbiAgICAgIC8vIFRoZSBvbmx5IHZhbGlkIGNvbnRlbnQgdGhhdCBjb3VsZCBkb3VibGUgYXMgYSBzZWxlY3RvciBhcmUgSURzIG9yIGNsYXNzZXMsXG4gICAgICAvLyBzbyBldmVyeXRoaW5nIHN0YXJ0aW5nIHdpdGggYCNgIG9yIGAuYC4gSWYgYSBcInJlYWxcIiBVUkwgaXMgdXNlZCBhcyB0aGUgc2VsZWN0b3IsXG4gICAgICAvLyBgZG9jdW1lbnQucXVlcnlTZWxlY3RvcmAgd2lsbCByaWdodGZ1bGx5IGNvbXBsYWluIGl0IGlzIGludmFsaWQuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2lzc3Vlcy8zMjI3M1xuICAgICAgaWYgKCFocmVmQXR0cmlidXRlIHx8ICFocmVmQXR0cmlidXRlLmluY2x1ZGVzKCcjJykgJiYgIWhyZWZBdHRyaWJ1dGUuc3RhcnRzV2l0aCgnLicpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBKdXN0IGluIGNhc2Ugc29tZSBDTVMgcHV0cyBvdXQgYSBmdWxsIFVSTCB3aXRoIHRoZSBhbmNob3IgYXBwZW5kZWRcbiAgICAgIGlmIChocmVmQXR0cmlidXRlLmluY2x1ZGVzKCcjJykgJiYgIWhyZWZBdHRyaWJ1dGUuc3RhcnRzV2l0aCgnIycpKSB7XG4gICAgICAgIGhyZWZBdHRyaWJ1dGUgPSBgIyR7aHJlZkF0dHJpYnV0ZS5zcGxpdCgnIycpWzFdfWA7XG4gICAgICB9XG4gICAgICBzZWxlY3RvciA9IGhyZWZBdHRyaWJ1dGUgJiYgaHJlZkF0dHJpYnV0ZSAhPT0gJyMnID8gaHJlZkF0dHJpYnV0ZS50cmltKCkgOiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0b3IgPyBzZWxlY3Rvci5zcGxpdCgnLCcpLm1hcChzZWwgPT4gcGFyc2VTZWxlY3RvcihzZWwpKS5qb2luKCcsJykgOiBudWxsO1xuICB9O1xuICBjb25zdCBTZWxlY3RvckVuZ2luZSA9IHtcbiAgICBmaW5kKHNlbGVjdG9yLCBlbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XG4gICAgICByZXR1cm4gW10uY29uY2F0KC4uLkVsZW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3JBbGwuY2FsbChlbGVtZW50LCBzZWxlY3RvcikpO1xuICAgIH0sXG4gICAgZmluZE9uZShzZWxlY3RvciwgZWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgcmV0dXJuIEVsZW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3IuY2FsbChlbGVtZW50LCBzZWxlY3Rvcik7XG4gICAgfSxcbiAgICBjaGlsZHJlbihlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgICAgcmV0dXJuIFtdLmNvbmNhdCguLi5lbGVtZW50LmNoaWxkcmVuKS5maWx0ZXIoY2hpbGQgPT4gY2hpbGQubWF0Y2hlcyhzZWxlY3RvcikpO1xuICAgIH0sXG4gICAgcGFyZW50cyhlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgICAgY29uc3QgcGFyZW50cyA9IFtdO1xuICAgICAgbGV0IGFuY2VzdG9yID0gZWxlbWVudC5wYXJlbnROb2RlLmNsb3Nlc3Qoc2VsZWN0b3IpO1xuICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XG4gICAgICAgIHBhcmVudHMucHVzaChhbmNlc3Rvcik7XG4gICAgICAgIGFuY2VzdG9yID0gYW5jZXN0b3IucGFyZW50Tm9kZS5jbG9zZXN0KHNlbGVjdG9yKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBwYXJlbnRzO1xuICAgIH0sXG4gICAgcHJldihlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgICAgbGV0IHByZXZpb3VzID0gZWxlbWVudC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nO1xuICAgICAgd2hpbGUgKHByZXZpb3VzKSB7XG4gICAgICAgIGlmIChwcmV2aW91cy5tYXRjaGVzKHNlbGVjdG9yKSkge1xuICAgICAgICAgIHJldHVybiBbcHJldmlvdXNdO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzID0gcHJldmlvdXMucHJldmlvdXNFbGVtZW50U2libGluZztcbiAgICAgIH1cbiAgICAgIHJldHVybiBbXTtcbiAgICB9LFxuICAgIC8vIFRPRE86IHRoaXMgaXMgbm93IHVudXNlZDsgcmVtb3ZlIGxhdGVyIGFsb25nIHdpdGggcHJldigpXG4gICAgbmV4dChlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgICAgbGV0IG5leHQgPSBlbGVtZW50Lm5leHRFbGVtZW50U2libGluZztcbiAgICAgIHdoaWxlIChuZXh0KSB7XG4gICAgICAgIGlmIChuZXh0Lm1hdGNoZXMoc2VsZWN0b3IpKSB7XG4gICAgICAgICAgcmV0dXJuIFtuZXh0XTtcbiAgICAgICAgfVxuICAgICAgICBuZXh0ID0gbmV4dC5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICB9XG4gICAgICByZXR1cm4gW107XG4gICAgfSxcbiAgICBmb2N1c2FibGVDaGlsZHJlbihlbGVtZW50KSB7XG4gICAgICBjb25zdCBmb2N1c2FibGVzID0gWydhJywgJ2J1dHRvbicsICdpbnB1dCcsICd0ZXh0YXJlYScsICdzZWxlY3QnLCAnZGV0YWlscycsICdbdGFiaW5kZXhdJywgJ1tjb250ZW50ZWRpdGFibGU9XCJ0cnVlXCJdJ10ubWFwKHNlbGVjdG9yID0+IGAke3NlbGVjdG9yfTpub3QoW3RhYmluZGV4Xj1cIi1cIl0pYCkuam9pbignLCcpO1xuICAgICAgcmV0dXJuIHRoaXMuZmluZChmb2N1c2FibGVzLCBlbGVtZW50KS5maWx0ZXIoZWwgPT4gIWlzRGlzYWJsZWQoZWwpICYmIGlzVmlzaWJsZShlbCkpO1xuICAgIH0sXG4gICAgZ2V0U2VsZWN0b3JGcm9tRWxlbWVudChlbGVtZW50KSB7XG4gICAgICBjb25zdCBzZWxlY3RvciA9IGdldFNlbGVjdG9yKGVsZW1lbnQpO1xuICAgICAgaWYgKHNlbGVjdG9yKSB7XG4gICAgICAgIHJldHVybiBTZWxlY3RvckVuZ2luZS5maW5kT25lKHNlbGVjdG9yKSA/IHNlbGVjdG9yIDogbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0sXG4gICAgZ2V0RWxlbWVudEZyb21TZWxlY3RvcihlbGVtZW50KSB7XG4gICAgICBjb25zdCBzZWxlY3RvciA9IGdldFNlbGVjdG9yKGVsZW1lbnQpO1xuICAgICAgcmV0dXJuIHNlbGVjdG9yID8gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShzZWxlY3RvcikgOiBudWxsO1xuICAgIH0sXG4gICAgZ2V0TXVsdGlwbGVFbGVtZW50c0Zyb21TZWxlY3RvcihlbGVtZW50KSB7XG4gICAgICBjb25zdCBzZWxlY3RvciA9IGdldFNlbGVjdG9yKGVsZW1lbnQpO1xuICAgICAgcmV0dXJuIHNlbGVjdG9yID8gU2VsZWN0b3JFbmdpbmUuZmluZChzZWxlY3RvcikgOiBbXTtcbiAgICB9XG4gIH07XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEJvb3RzdHJhcCB1dGlsL2NvbXBvbmVudC1mdW5jdGlvbnMuanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIGNvbnN0IGVuYWJsZURpc21pc3NUcmlnZ2VyID0gKGNvbXBvbmVudCwgbWV0aG9kID0gJ2hpZGUnKSA9PiB7XG4gICAgY29uc3QgY2xpY2tFdmVudCA9IGBjbGljay5kaXNtaXNzJHtjb21wb25lbnQuRVZFTlRfS0VZfWA7XG4gICAgY29uc3QgbmFtZSA9IGNvbXBvbmVudC5OQU1FO1xuICAgIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgY2xpY2tFdmVudCwgYFtkYXRhLWJzLWRpc21pc3M9XCIke25hbWV9XCJdYCwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICBpZiAoWydBJywgJ0FSRUEnXS5pbmNsdWRlcyh0aGlzLnRhZ05hbWUpKSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNEaXNhYmxlZCh0aGlzKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB0YXJnZXQgPSBTZWxlY3RvckVuZ2luZS5nZXRFbGVtZW50RnJvbVNlbGVjdG9yKHRoaXMpIHx8IHRoaXMuY2xvc2VzdChgLiR7bmFtZX1gKTtcbiAgICAgIGNvbnN0IGluc3RhbmNlID0gY29tcG9uZW50LmdldE9yQ3JlYXRlSW5zdGFuY2UodGFyZ2V0KTtcblxuICAgICAgLy8gTWV0aG9kIGFyZ3VtZW50IGlzIGxlZnQsIGZvciBBbGVydCBhbmQgb25seSwgYXMgaXQgZG9lc24ndCBpbXBsZW1lbnQgdGhlICdoaWRlJyBtZXRob2RcbiAgICAgIGluc3RhbmNlW21ldGhvZF0oKTtcbiAgICB9KTtcbiAgfTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQm9vdHN0cmFwIGFsZXJ0LmpzXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuXG4gIC8qKlxuICAgKiBDb25zdGFudHNcbiAgICovXG5cbiAgY29uc3QgTkFNRSRmID0gJ2FsZXJ0JztcbiAgY29uc3QgREFUQV9LRVkkYSA9ICdicy5hbGVydCc7XG4gIGNvbnN0IEVWRU5UX0tFWSRiID0gYC4ke0RBVEFfS0VZJGF9YDtcbiAgY29uc3QgRVZFTlRfQ0xPU0UgPSBgY2xvc2Uke0VWRU5UX0tFWSRifWA7XG4gIGNvbnN0IEVWRU5UX0NMT1NFRCA9IGBjbG9zZWQke0VWRU5UX0tFWSRifWA7XG4gIGNvbnN0IENMQVNTX05BTUVfRkFERSQ1ID0gJ2ZhZGUnO1xuICBjb25zdCBDTEFTU19OQU1FX1NIT1ckOCA9ICdzaG93JztcblxuICAvKipcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxuICAgKi9cblxuICBjbGFzcyBBbGVydCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIC8vIEdldHRlcnNcbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgICByZXR1cm4gTkFNRSRmO1xuICAgIH1cblxuICAgIC8vIFB1YmxpY1xuICAgIGNsb3NlKCkge1xuICAgICAgY29uc3QgY2xvc2VFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0NMT1NFKTtcbiAgICAgIGlmIChjbG9zZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQ4KTtcbiAgICAgIGNvbnN0IGlzQW5pbWF0ZWQgPSB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0ZBREUkNSk7XG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKCgpID0+IHRoaXMuX2Rlc3Ryb3lFbGVtZW50KCksIHRoaXMuX2VsZW1lbnQsIGlzQW5pbWF0ZWQpO1xuICAgIH1cblxuICAgIC8vIFByaXZhdGVcbiAgICBfZGVzdHJveUVsZW1lbnQoKSB7XG4gICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZSgpO1xuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfQ0xPU0VEKTtcbiAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgIH1cblxuICAgIC8vIFN0YXRpY1xuICAgIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IEFsZXJ0LmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcyk7XG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YVtjb25maWddID09PSB1bmRlZmluZWQgfHwgY29uZmlnLnN0YXJ0c1dpdGgoJ18nKSB8fCBjb25maWcgPT09ICdjb25zdHJ1Y3RvcicpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xuICAgICAgICB9XG4gICAgICAgIGRhdGFbY29uZmlnXSh0aGlzKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxuICAgKi9cblxuICBlbmFibGVEaXNtaXNzVHJpZ2dlcihBbGVydCwgJ2Nsb3NlJyk7XG5cbiAgLyoqXG4gICAqIGpRdWVyeVxuICAgKi9cblxuICBkZWZpbmVKUXVlcnlQbHVnaW4oQWxlcnQpO1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgYnV0dG9uLmpzXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuXG4gIC8qKlxuICAgKiBDb25zdGFudHNcbiAgICovXG5cbiAgY29uc3QgTkFNRSRlID0gJ2J1dHRvbic7XG4gIGNvbnN0IERBVEFfS0VZJDkgPSAnYnMuYnV0dG9uJztcbiAgY29uc3QgRVZFTlRfS0VZJGEgPSBgLiR7REFUQV9LRVkkOX1gO1xuICBjb25zdCBEQVRBX0FQSV9LRVkkNiA9ICcuZGF0YS1hcGknO1xuICBjb25zdCBDTEFTU19OQU1FX0FDVElWRSQzID0gJ2FjdGl2ZSc7XG4gIGNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFJDUgPSAnW2RhdGEtYnMtdG9nZ2xlPVwiYnV0dG9uXCJdJztcbiAgY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNiA9IGBjbGljayR7RVZFTlRfS0VZJGF9JHtEQVRBX0FQSV9LRVkkNn1gO1xuXG4gIC8qKlxuICAgKiBDbGFzcyBkZWZpbml0aW9uXG4gICAqL1xuXG4gIGNsYXNzIEJ1dHRvbiBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIC8vIEdldHRlcnNcbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgICByZXR1cm4gTkFNRSRlO1xuICAgIH1cblxuICAgIC8vIFB1YmxpY1xuICAgIHRvZ2dsZSgpIHtcbiAgICAgIC8vIFRvZ2dsZSBjbGFzcyBhbmQgc3luYyB0aGUgYGFyaWEtcHJlc3NlZGAgYXR0cmlidXRlIHdpdGggdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgYC50b2dnbGUoKWAgbWV0aG9kXG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1wcmVzc2VkJywgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKENMQVNTX05BTUVfQUNUSVZFJDMpKTtcbiAgICB9XG5cbiAgICAvLyBTdGF0aWNcbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBCdXR0b24uZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzKTtcbiAgICAgICAgaWYgKGNvbmZpZyA9PT0gJ3RvZ2dsZScpIHtcbiAgICAgICAgICBkYXRhW2NvbmZpZ10oKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXG4gICAqL1xuXG4gIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNiwgU0VMRUNUT1JfREFUQV9UT0dHTEUkNSwgZXZlbnQgPT4ge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgY29uc3QgYnV0dG9uID0gZXZlbnQudGFyZ2V0LmNsb3Nlc3QoU0VMRUNUT1JfREFUQV9UT0dHTEUkNSk7XG4gICAgY29uc3QgZGF0YSA9IEJ1dHRvbi5nZXRPckNyZWF0ZUluc3RhbmNlKGJ1dHRvbik7XG4gICAgZGF0YS50b2dnbGUoKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIGpRdWVyeVxuICAgKi9cblxuICBkZWZpbmVKUXVlcnlQbHVnaW4oQnV0dG9uKTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQm9vdHN0cmFwIHV0aWwvc3dpcGUuanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIENvbnN0YW50c1xuICAgKi9cblxuICBjb25zdCBOQU1FJGQgPSAnc3dpcGUnO1xuICBjb25zdCBFVkVOVF9LRVkkOSA9ICcuYnMuc3dpcGUnO1xuICBjb25zdCBFVkVOVF9UT1VDSFNUQVJUID0gYHRvdWNoc3RhcnQke0VWRU5UX0tFWSQ5fWA7XG4gIGNvbnN0IEVWRU5UX1RPVUNITU9WRSA9IGB0b3VjaG1vdmUke0VWRU5UX0tFWSQ5fWA7XG4gIGNvbnN0IEVWRU5UX1RPVUNIRU5EID0gYHRvdWNoZW5kJHtFVkVOVF9LRVkkOX1gO1xuICBjb25zdCBFVkVOVF9QT0lOVEVSRE9XTiA9IGBwb2ludGVyZG93biR7RVZFTlRfS0VZJDl9YDtcbiAgY29uc3QgRVZFTlRfUE9JTlRFUlVQID0gYHBvaW50ZXJ1cCR7RVZFTlRfS0VZJDl9YDtcbiAgY29uc3QgUE9JTlRFUl9UWVBFX1RPVUNIID0gJ3RvdWNoJztcbiAgY29uc3QgUE9JTlRFUl9UWVBFX1BFTiA9ICdwZW4nO1xuICBjb25zdCBDTEFTU19OQU1FX1BPSU5URVJfRVZFTlQgPSAncG9pbnRlci1ldmVudCc7XG4gIGNvbnN0IFNXSVBFX1RIUkVTSE9MRCA9IDQwO1xuICBjb25zdCBEZWZhdWx0JGMgPSB7XG4gICAgZW5kQ2FsbGJhY2s6IG51bGwsXG4gICAgbGVmdENhbGxiYWNrOiBudWxsLFxuICAgIHJpZ2h0Q2FsbGJhY2s6IG51bGxcbiAgfTtcbiAgY29uc3QgRGVmYXVsdFR5cGUkYyA9IHtcbiAgICBlbmRDYWxsYmFjazogJyhmdW5jdGlvbnxudWxsKScsXG4gICAgbGVmdENhbGxiYWNrOiAnKGZ1bmN0aW9ufG51bGwpJyxcbiAgICByaWdodENhbGxiYWNrOiAnKGZ1bmN0aW9ufG51bGwpJ1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGFzcyBkZWZpbml0aW9uXG4gICAqL1xuXG4gIGNsYXNzIFN3aXBlIGV4dGVuZHMgQ29uZmlnIHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICAgIHN1cGVyKCk7XG4gICAgICB0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgIGlmICghZWxlbWVudCB8fCAhU3dpcGUuaXNTdXBwb3J0ZWQoKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9jb25maWcgPSB0aGlzLl9nZXRDb25maWcoY29uZmlnKTtcbiAgICAgIHRoaXMuX2RlbHRhWCA9IDA7XG4gICAgICB0aGlzLl9zdXBwb3J0UG9pbnRlckV2ZW50cyA9IEJvb2xlYW4od2luZG93LlBvaW50ZXJFdmVudCk7XG4gICAgICB0aGlzLl9pbml0RXZlbnRzKCk7XG4gICAgfVxuXG4gICAgLy8gR2V0dGVyc1xuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiBEZWZhdWx0JGM7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdFR5cGUkYztcbiAgICB9XG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgICAgcmV0dXJuIE5BTUUkZDtcbiAgICB9XG5cbiAgICAvLyBQdWJsaWNcbiAgICBkaXNwb3NlKCkge1xuICAgICAgRXZlbnRIYW5kbGVyLm9mZih0aGlzLl9lbGVtZW50LCBFVkVOVF9LRVkkOSk7XG4gICAgfVxuXG4gICAgLy8gUHJpdmF0ZVxuICAgIF9zdGFydChldmVudCkge1xuICAgICAgaWYgKCF0aGlzLl9zdXBwb3J0UG9pbnRlckV2ZW50cykge1xuICAgICAgICB0aGlzLl9kZWx0YVggPSBldmVudC50b3VjaGVzWzBdLmNsaWVudFg7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9ldmVudElzUG9pbnRlclBlblRvdWNoKGV2ZW50KSkge1xuICAgICAgICB0aGlzLl9kZWx0YVggPSBldmVudC5jbGllbnRYO1xuICAgICAgfVxuICAgIH1cbiAgICBfZW5kKGV2ZW50KSB7XG4gICAgICBpZiAodGhpcy5fZXZlbnRJc1BvaW50ZXJQZW5Ub3VjaChldmVudCkpIHtcbiAgICAgICAgdGhpcy5fZGVsdGFYID0gZXZlbnQuY2xpZW50WCAtIHRoaXMuX2RlbHRhWDtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2hhbmRsZVN3aXBlKCk7XG4gICAgICBleGVjdXRlKHRoaXMuX2NvbmZpZy5lbmRDYWxsYmFjayk7XG4gICAgfVxuICAgIF9tb3ZlKGV2ZW50KSB7XG4gICAgICB0aGlzLl9kZWx0YVggPSBldmVudC50b3VjaGVzICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMSA/IDAgOiBldmVudC50b3VjaGVzWzBdLmNsaWVudFggLSB0aGlzLl9kZWx0YVg7XG4gICAgfVxuICAgIF9oYW5kbGVTd2lwZSgpIHtcbiAgICAgIGNvbnN0IGFic0RlbHRhWCA9IE1hdGguYWJzKHRoaXMuX2RlbHRhWCk7XG4gICAgICBpZiAoYWJzRGVsdGFYIDw9IFNXSVBFX1RIUkVTSE9MRCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBkaXJlY3Rpb24gPSBhYnNEZWx0YVggLyB0aGlzLl9kZWx0YVg7XG4gICAgICB0aGlzLl9kZWx0YVggPSAwO1xuICAgICAgaWYgKCFkaXJlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZXhlY3V0ZShkaXJlY3Rpb24gPiAwID8gdGhpcy5fY29uZmlnLnJpZ2h0Q2FsbGJhY2sgOiB0aGlzLl9jb25maWcubGVmdENhbGxiYWNrKTtcbiAgICB9XG4gICAgX2luaXRFdmVudHMoKSB7XG4gICAgICBpZiAodGhpcy5fc3VwcG9ydFBvaW50ZXJFdmVudHMpIHtcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1BPSU5URVJET1dOLCBldmVudCA9PiB0aGlzLl9zdGFydChldmVudCkpO1xuICAgICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfUE9JTlRFUlVQLCBldmVudCA9PiB0aGlzLl9lbmQoZXZlbnQpKTtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfUE9JTlRFUl9FVkVOVCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfVE9VQ0hTVEFSVCwgZXZlbnQgPT4gdGhpcy5fc3RhcnQoZXZlbnQpKTtcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1RPVUNITU9WRSwgZXZlbnQgPT4gdGhpcy5fbW92ZShldmVudCkpO1xuICAgICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfVE9VQ0hFTkQsIGV2ZW50ID0+IHRoaXMuX2VuZChldmVudCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBfZXZlbnRJc1BvaW50ZXJQZW5Ub3VjaChldmVudCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3N1cHBvcnRQb2ludGVyRXZlbnRzICYmIChldmVudC5wb2ludGVyVHlwZSA9PT0gUE9JTlRFUl9UWVBFX1BFTiB8fCBldmVudC5wb2ludGVyVHlwZSA9PT0gUE9JTlRFUl9UWVBFX1RPVUNIKTtcbiAgICB9XG5cbiAgICAvLyBTdGF0aWNcbiAgICBzdGF0aWMgaXNTdXBwb3J0ZWQoKSB7XG4gICAgICByZXR1cm4gJ29udG91Y2hzdGFydCcgaW4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50IHx8IG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDA7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEJvb3RzdHJhcCBjYXJvdXNlbC5qc1xuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cblxuICAvKipcbiAgICogQ29uc3RhbnRzXG4gICAqL1xuXG4gIGNvbnN0IE5BTUUkYyA9ICdjYXJvdXNlbCc7XG4gIGNvbnN0IERBVEFfS0VZJDggPSAnYnMuY2Fyb3VzZWwnO1xuICBjb25zdCBFVkVOVF9LRVkkOCA9IGAuJHtEQVRBX0tFWSQ4fWA7XG4gIGNvbnN0IERBVEFfQVBJX0tFWSQ1ID0gJy5kYXRhLWFwaSc7XG4gIGNvbnN0IEFSUk9XX0xFRlRfS0VZJDEgPSAnQXJyb3dMZWZ0JztcbiAgY29uc3QgQVJST1dfUklHSFRfS0VZJDEgPSAnQXJyb3dSaWdodCc7XG4gIGNvbnN0IFRPVUNIRVZFTlRfQ09NUEFUX1dBSVQgPSA1MDA7IC8vIFRpbWUgZm9yIG1vdXNlIGNvbXBhdCBldmVudHMgdG8gZmlyZSBhZnRlciB0b3VjaFxuXG4gIGNvbnN0IE9SREVSX05FWFQgPSAnbmV4dCc7XG4gIGNvbnN0IE9SREVSX1BSRVYgPSAncHJldic7XG4gIGNvbnN0IERJUkVDVElPTl9MRUZUID0gJ2xlZnQnO1xuICBjb25zdCBESVJFQ1RJT05fUklHSFQgPSAncmlnaHQnO1xuICBjb25zdCBFVkVOVF9TTElERSA9IGBzbGlkZSR7RVZFTlRfS0VZJDh9YDtcbiAgY29uc3QgRVZFTlRfU0xJRCA9IGBzbGlkJHtFVkVOVF9LRVkkOH1gO1xuICBjb25zdCBFVkVOVF9LRVlET1dOJDEgPSBga2V5ZG93biR7RVZFTlRfS0VZJDh9YDtcbiAgY29uc3QgRVZFTlRfTU9VU0VFTlRFUiQxID0gYG1vdXNlZW50ZXIke0VWRU5UX0tFWSQ4fWA7XG4gIGNvbnN0IEVWRU5UX01PVVNFTEVBVkUkMSA9IGBtb3VzZWxlYXZlJHtFVkVOVF9LRVkkOH1gO1xuICBjb25zdCBFVkVOVF9EUkFHX1NUQVJUID0gYGRyYWdzdGFydCR7RVZFTlRfS0VZJDh9YDtcbiAgY29uc3QgRVZFTlRfTE9BRF9EQVRBX0FQSSQzID0gYGxvYWQke0VWRU5UX0tFWSQ4fSR7REFUQV9BUElfS0VZJDV9YDtcbiAgY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNSA9IGBjbGljayR7RVZFTlRfS0VZJDh9JHtEQVRBX0FQSV9LRVkkNX1gO1xuICBjb25zdCBDTEFTU19OQU1FX0NBUk9VU0VMID0gJ2Nhcm91c2VsJztcbiAgY29uc3QgQ0xBU1NfTkFNRV9BQ1RJVkUkMiA9ICdhY3RpdmUnO1xuICBjb25zdCBDTEFTU19OQU1FX1NMSURFID0gJ3NsaWRlJztcbiAgY29uc3QgQ0xBU1NfTkFNRV9FTkQgPSAnY2Fyb3VzZWwtaXRlbS1lbmQnO1xuICBjb25zdCBDTEFTU19OQU1FX1NUQVJUID0gJ2Nhcm91c2VsLWl0ZW0tc3RhcnQnO1xuICBjb25zdCBDTEFTU19OQU1FX05FWFQgPSAnY2Fyb3VzZWwtaXRlbS1uZXh0JztcbiAgY29uc3QgQ0xBU1NfTkFNRV9QUkVWID0gJ2Nhcm91c2VsLWl0ZW0tcHJldic7XG4gIGNvbnN0IFNFTEVDVE9SX0FDVElWRSA9ICcuYWN0aXZlJztcbiAgY29uc3QgU0VMRUNUT1JfSVRFTSA9ICcuY2Fyb3VzZWwtaXRlbSc7XG4gIGNvbnN0IFNFTEVDVE9SX0FDVElWRV9JVEVNID0gU0VMRUNUT1JfQUNUSVZFICsgU0VMRUNUT1JfSVRFTTtcbiAgY29uc3QgU0VMRUNUT1JfSVRFTV9JTUcgPSAnLmNhcm91c2VsLWl0ZW0gaW1nJztcbiAgY29uc3QgU0VMRUNUT1JfSU5ESUNBVE9SUyA9ICcuY2Fyb3VzZWwtaW5kaWNhdG9ycyc7XG4gIGNvbnN0IFNFTEVDVE9SX0RBVEFfU0xJREUgPSAnW2RhdGEtYnMtc2xpZGVdLCBbZGF0YS1icy1zbGlkZS10b10nO1xuICBjb25zdCBTRUxFQ1RPUl9EQVRBX1JJREUgPSAnW2RhdGEtYnMtcmlkZT1cImNhcm91c2VsXCJdJztcbiAgY29uc3QgS0VZX1RPX0RJUkVDVElPTiA9IHtcbiAgICBbQVJST1dfTEVGVF9LRVkkMV06IERJUkVDVElPTl9SSUdIVCxcbiAgICBbQVJST1dfUklHSFRfS0VZJDFdOiBESVJFQ1RJT05fTEVGVFxuICB9O1xuICBjb25zdCBEZWZhdWx0JGIgPSB7XG4gICAgaW50ZXJ2YWw6IDUwMDAsXG4gICAga2V5Ym9hcmQ6IHRydWUsXG4gICAgcGF1c2U6ICdob3ZlcicsXG4gICAgcmlkZTogZmFsc2UsXG4gICAgdG91Y2g6IHRydWUsXG4gICAgd3JhcDogdHJ1ZVxuICB9O1xuICBjb25zdCBEZWZhdWx0VHlwZSRiID0ge1xuICAgIGludGVydmFsOiAnKG51bWJlcnxib29sZWFuKScsXG4gICAgLy8gVE9ETzp2NiByZW1vdmUgYm9vbGVhbiBzdXBwb3J0XG4gICAga2V5Ym9hcmQ6ICdib29sZWFuJyxcbiAgICBwYXVzZTogJyhzdHJpbmd8Ym9vbGVhbiknLFxuICAgIHJpZGU6ICcoYm9vbGVhbnxzdHJpbmcpJyxcbiAgICB0b3VjaDogJ2Jvb2xlYW4nLFxuICAgIHdyYXA6ICdib29sZWFuJ1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGFzcyBkZWZpbml0aW9uXG4gICAqL1xuXG4gIGNsYXNzIENhcm91c2VsIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XG4gICAgICBzdXBlcihlbGVtZW50LCBjb25maWcpO1xuICAgICAgdGhpcy5faW50ZXJ2YWwgPSBudWxsO1xuICAgICAgdGhpcy5fYWN0aXZlRWxlbWVudCA9IG51bGw7XG4gICAgICB0aGlzLl9pc1NsaWRpbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMudG91Y2hUaW1lb3V0ID0gbnVsbDtcbiAgICAgIHRoaXMuX3N3aXBlSGVscGVyID0gbnVsbDtcbiAgICAgIHRoaXMuX2luZGljYXRvcnNFbGVtZW50ID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9JTkRJQ0FUT1JTLCB0aGlzLl9lbGVtZW50KTtcbiAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICBpZiAodGhpcy5fY29uZmlnLnJpZGUgPT09IENMQVNTX05BTUVfQ0FST1VTRUwpIHtcbiAgICAgICAgdGhpcy5jeWNsZSgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEdldHRlcnNcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdCRiO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlJGI7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICAgIHJldHVybiBOQU1FJGM7XG4gICAgfVxuXG4gICAgLy8gUHVibGljXG4gICAgbmV4dCgpIHtcbiAgICAgIHRoaXMuX3NsaWRlKE9SREVSX05FWFQpO1xuICAgIH1cbiAgICBuZXh0V2hlblZpc2libGUoKSB7XG4gICAgICAvLyBGSVhNRSBUT0RPIHVzZSBgZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlYFxuICAgICAgLy8gRG9uJ3QgY2FsbCBuZXh0IHdoZW4gdGhlIHBhZ2UgaXNuJ3QgdmlzaWJsZVxuICAgICAgLy8gb3IgdGhlIGNhcm91c2VsIG9yIGl0cyBwYXJlbnQgaXNuJ3QgdmlzaWJsZVxuICAgICAgaWYgKCFkb2N1bWVudC5oaWRkZW4gJiYgaXNWaXNpYmxlKHRoaXMuX2VsZW1lbnQpKSB7XG4gICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgfVxuICAgIH1cbiAgICBwcmV2KCkge1xuICAgICAgdGhpcy5fc2xpZGUoT1JERVJfUFJFVik7XG4gICAgfVxuICAgIHBhdXNlKCkge1xuICAgICAgaWYgKHRoaXMuX2lzU2xpZGluZykge1xuICAgICAgICB0cmlnZ2VyVHJhbnNpdGlvbkVuZCh0aGlzLl9lbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NsZWFySW50ZXJ2YWwoKTtcbiAgICB9XG4gICAgY3ljbGUoKSB7XG4gICAgICB0aGlzLl9jbGVhckludGVydmFsKCk7XG4gICAgICB0aGlzLl91cGRhdGVJbnRlcnZhbCgpO1xuICAgICAgdGhpcy5faW50ZXJ2YWwgPSBzZXRJbnRlcnZhbCgoKSA9PiB0aGlzLm5leHRXaGVuVmlzaWJsZSgpLCB0aGlzLl9jb25maWcuaW50ZXJ2YWwpO1xuICAgIH1cbiAgICBfbWF5YmVFbmFibGVDeWNsZSgpIHtcbiAgICAgIGlmICghdGhpcy5fY29uZmlnLnJpZGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2lzU2xpZGluZykge1xuICAgICAgICBFdmVudEhhbmRsZXIub25lKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NMSUQsICgpID0+IHRoaXMuY3ljbGUoKSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuY3ljbGUoKTtcbiAgICB9XG4gICAgdG8oaW5kZXgpIHtcbiAgICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5fZ2V0SXRlbXMoKTtcbiAgICAgIGlmIChpbmRleCA+IGl0ZW1zLmxlbmd0aCAtIDEgfHwgaW5kZXggPCAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9pc1NsaWRpbmcpIHtcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uZSh0aGlzLl9lbGVtZW50LCBFVkVOVF9TTElELCAoKSA9PiB0aGlzLnRvKGluZGV4KSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFjdGl2ZUluZGV4ID0gdGhpcy5fZ2V0SXRlbUluZGV4KHRoaXMuX2dldEFjdGl2ZSgpKTtcbiAgICAgIGlmIChhY3RpdmVJbmRleCA9PT0gaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3JkZXIgPSBpbmRleCA+IGFjdGl2ZUluZGV4ID8gT1JERVJfTkVYVCA6IE9SREVSX1BSRVY7XG4gICAgICB0aGlzLl9zbGlkZShvcmRlciwgaXRlbXNbaW5kZXhdKTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgIGlmICh0aGlzLl9zd2lwZUhlbHBlcikge1xuICAgICAgICB0aGlzLl9zd2lwZUhlbHBlci5kaXNwb3NlKCk7XG4gICAgICB9XG4gICAgICBzdXBlci5kaXNwb3NlKCk7XG4gICAgfVxuXG4gICAgLy8gUHJpdmF0ZVxuICAgIF9jb25maWdBZnRlck1lcmdlKGNvbmZpZykge1xuICAgICAgY29uZmlnLmRlZmF1bHRJbnRlcnZhbCA9IGNvbmZpZy5pbnRlcnZhbDtcbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuICAgIF9hZGRFdmVudExpc3RlbmVycygpIHtcbiAgICAgIGlmICh0aGlzLl9jb25maWcua2V5Ym9hcmQpIHtcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0tFWURPV04kMSwgZXZlbnQgPT4gdGhpcy5fa2V5ZG93bihldmVudCkpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5wYXVzZSA9PT0gJ2hvdmVyJykge1xuICAgICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfTU9VU0VFTlRFUiQxLCAoKSA9PiB0aGlzLnBhdXNlKCkpO1xuICAgICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfTU9VU0VMRUFWRSQxLCAoKSA9PiB0aGlzLl9tYXliZUVuYWJsZUN5Y2xlKCkpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy50b3VjaCAmJiBTd2lwZS5pc1N1cHBvcnRlZCgpKSB7XG4gICAgICAgIHRoaXMuX2FkZFRvdWNoRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX2FkZFRvdWNoRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICBmb3IgKGNvbnN0IGltZyBvZiBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0lURU1fSU1HLCB0aGlzLl9lbGVtZW50KSkge1xuICAgICAgICBFdmVudEhhbmRsZXIub24oaW1nLCBFVkVOVF9EUkFHX1NUQVJULCBldmVudCA9PiBldmVudC5wcmV2ZW50RGVmYXVsdCgpKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVuZENhbGxCYWNrID0gKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5fY29uZmlnLnBhdXNlICE9PSAnaG92ZXInKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gSWYgaXQncyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlLCBtb3VzZWVudGVyL2xlYXZlIGFyZSBmaXJlZCBhc1xuICAgICAgICAvLyBwYXJ0IG9mIHRoZSBtb3VzZSBjb21wYXRpYmlsaXR5IGV2ZW50cyBvbiBmaXJzdCB0YXAgLSB0aGUgY2Fyb3VzZWxcbiAgICAgICAgLy8gd291bGQgc3RvcCBjeWNsaW5nIHVudGlsIHVzZXIgdGFwcGVkIG91dCBvZiBpdDtcbiAgICAgICAgLy8gaGVyZSwgd2UgbGlzdGVuIGZvciB0b3VjaGVuZCwgZXhwbGljaXRseSBwYXVzZSB0aGUgY2Fyb3VzZWxcbiAgICAgICAgLy8gKGFzIGlmIGl0J3MgdGhlIHNlY29uZCB0aW1lIHdlIHRhcCBvbiBpdCwgbW91c2VlbnRlciBjb21wYXQgZXZlbnRcbiAgICAgICAgLy8gaXMgTk9UIGZpcmVkKSBhbmQgYWZ0ZXIgYSB0aW1lb3V0ICh0byBhbGxvdyBmb3IgbW91c2UgY29tcGF0aWJpbGl0eVxuICAgICAgICAvLyBldmVudHMgdG8gZmlyZSkgd2UgZXhwbGljaXRseSByZXN0YXJ0IGN5Y2xpbmdcblxuICAgICAgICB0aGlzLnBhdXNlKCk7XG4gICAgICAgIGlmICh0aGlzLnRvdWNoVGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRvdWNoVGltZW91dCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50b3VjaFRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHRoaXMuX21heWJlRW5hYmxlQ3ljbGUoKSwgVE9VQ0hFVkVOVF9DT01QQVRfV0FJVCArIHRoaXMuX2NvbmZpZy5pbnRlcnZhbCk7XG4gICAgICB9O1xuICAgICAgY29uc3Qgc3dpcGVDb25maWcgPSB7XG4gICAgICAgIGxlZnRDYWxsYmFjazogKCkgPT4gdGhpcy5fc2xpZGUodGhpcy5fZGlyZWN0aW9uVG9PcmRlcihESVJFQ1RJT05fTEVGVCkpLFxuICAgICAgICByaWdodENhbGxiYWNrOiAoKSA9PiB0aGlzLl9zbGlkZSh0aGlzLl9kaXJlY3Rpb25Ub09yZGVyKERJUkVDVElPTl9SSUdIVCkpLFxuICAgICAgICBlbmRDYWxsYmFjazogZW5kQ2FsbEJhY2tcbiAgICAgIH07XG4gICAgICB0aGlzLl9zd2lwZUhlbHBlciA9IG5ldyBTd2lwZSh0aGlzLl9lbGVtZW50LCBzd2lwZUNvbmZpZyk7XG4gICAgfVxuICAgIF9rZXlkb3duKGV2ZW50KSB7XG4gICAgICBpZiAoL2lucHV0fHRleHRhcmVhL2kudGVzdChldmVudC50YXJnZXQudGFnTmFtZSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZGlyZWN0aW9uID0gS0VZX1RPX0RJUkVDVElPTltldmVudC5rZXldO1xuICAgICAgaWYgKGRpcmVjdGlvbikge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLl9zbGlkZSh0aGlzLl9kaXJlY3Rpb25Ub09yZGVyKGRpcmVjdGlvbikpO1xuICAgICAgfVxuICAgIH1cbiAgICBfZ2V0SXRlbUluZGV4KGVsZW1lbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRJdGVtcygpLmluZGV4T2YoZWxlbWVudCk7XG4gICAgfVxuICAgIF9zZXRBY3RpdmVJbmRpY2F0b3JFbGVtZW50KGluZGV4KSB7XG4gICAgICBpZiAoIXRoaXMuX2luZGljYXRvcnNFbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFjdGl2ZUluZGljYXRvciA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfQUNUSVZFLCB0aGlzLl9pbmRpY2F0b3JzRWxlbWVudCk7XG4gICAgICBhY3RpdmVJbmRpY2F0b3IuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0FDVElWRSQyKTtcbiAgICAgIGFjdGl2ZUluZGljYXRvci5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtY3VycmVudCcpO1xuICAgICAgY29uc3QgbmV3QWN0aXZlSW5kaWNhdG9yID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShgW2RhdGEtYnMtc2xpZGUtdG89XCIke2luZGV4fVwiXWAsIHRoaXMuX2luZGljYXRvcnNFbGVtZW50KTtcbiAgICAgIGlmIChuZXdBY3RpdmVJbmRpY2F0b3IpIHtcbiAgICAgICAgbmV3QWN0aXZlSW5kaWNhdG9yLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUkMik7XG4gICAgICAgIG5ld0FjdGl2ZUluZGljYXRvci5zZXRBdHRyaWJ1dGUoJ2FyaWEtY3VycmVudCcsICd0cnVlJyk7XG4gICAgICB9XG4gICAgfVxuICAgIF91cGRhdGVJbnRlcnZhbCgpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9hY3RpdmVFbGVtZW50IHx8IHRoaXMuX2dldEFjdGl2ZSgpO1xuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVsZW1lbnRJbnRlcnZhbCA9IE51bWJlci5wYXJzZUludChlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1icy1pbnRlcnZhbCcpLCAxMCk7XG4gICAgICB0aGlzLl9jb25maWcuaW50ZXJ2YWwgPSBlbGVtZW50SW50ZXJ2YWwgfHwgdGhpcy5fY29uZmlnLmRlZmF1bHRJbnRlcnZhbDtcbiAgICB9XG4gICAgX3NsaWRlKG9yZGVyLCBlbGVtZW50ID0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMuX2lzU2xpZGluZykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBhY3RpdmVFbGVtZW50ID0gdGhpcy5fZ2V0QWN0aXZlKCk7XG4gICAgICBjb25zdCBpc05leHQgPSBvcmRlciA9PT0gT1JERVJfTkVYVDtcbiAgICAgIGNvbnN0IG5leHRFbGVtZW50ID0gZWxlbWVudCB8fCBnZXROZXh0QWN0aXZlRWxlbWVudCh0aGlzLl9nZXRJdGVtcygpLCBhY3RpdmVFbGVtZW50LCBpc05leHQsIHRoaXMuX2NvbmZpZy53cmFwKTtcbiAgICAgIGlmIChuZXh0RWxlbWVudCA9PT0gYWN0aXZlRWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBuZXh0RWxlbWVudEluZGV4ID0gdGhpcy5fZ2V0SXRlbUluZGV4KG5leHRFbGVtZW50KTtcbiAgICAgIGNvbnN0IHRyaWdnZXJFdmVudCA9IGV2ZW50TmFtZSA9PiB7XG4gICAgICAgIHJldHVybiBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBldmVudE5hbWUsIHtcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0OiBuZXh0RWxlbWVudCxcbiAgICAgICAgICBkaXJlY3Rpb246IHRoaXMuX29yZGVyVG9EaXJlY3Rpb24ob3JkZXIpLFxuICAgICAgICAgIGZyb206IHRoaXMuX2dldEl0ZW1JbmRleChhY3RpdmVFbGVtZW50KSxcbiAgICAgICAgICB0bzogbmV4dEVsZW1lbnRJbmRleFxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICBjb25zdCBzbGlkZUV2ZW50ID0gdHJpZ2dlckV2ZW50KEVWRU5UX1NMSURFKTtcbiAgICAgIGlmIChzbGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKCFhY3RpdmVFbGVtZW50IHx8ICFuZXh0RWxlbWVudCkge1xuICAgICAgICAvLyBTb21lIHdlaXJkbmVzcyBpcyBoYXBwZW5pbmcsIHNvIHdlIGJhaWxcbiAgICAgICAgLy8gVE9ETzogY2hhbmdlIHRlc3RzIHRoYXQgdXNlIGVtcHR5IGRpdnMgdG8gYXZvaWQgdGhpcyBjaGVja1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBpc0N5Y2xpbmcgPSBCb29sZWFuKHRoaXMuX2ludGVydmFsKTtcbiAgICAgIHRoaXMucGF1c2UoKTtcbiAgICAgIHRoaXMuX2lzU2xpZGluZyA9IHRydWU7XG4gICAgICB0aGlzLl9zZXRBY3RpdmVJbmRpY2F0b3JFbGVtZW50KG5leHRFbGVtZW50SW5kZXgpO1xuICAgICAgdGhpcy5fYWN0aXZlRWxlbWVudCA9IG5leHRFbGVtZW50O1xuICAgICAgY29uc3QgZGlyZWN0aW9uYWxDbGFzc05hbWUgPSBpc05leHQgPyBDTEFTU19OQU1FX1NUQVJUIDogQ0xBU1NfTkFNRV9FTkQ7XG4gICAgICBjb25zdCBvcmRlckNsYXNzTmFtZSA9IGlzTmV4dCA/IENMQVNTX05BTUVfTkVYVCA6IENMQVNTX05BTUVfUFJFVjtcbiAgICAgIG5leHRFbGVtZW50LmNsYXNzTGlzdC5hZGQob3JkZXJDbGFzc05hbWUpO1xuICAgICAgcmVmbG93KG5leHRFbGVtZW50KTtcbiAgICAgIGFjdGl2ZUVsZW1lbnQuY2xhc3NMaXN0LmFkZChkaXJlY3Rpb25hbENsYXNzTmFtZSk7XG4gICAgICBuZXh0RWxlbWVudC5jbGFzc0xpc3QuYWRkKGRpcmVjdGlvbmFsQ2xhc3NOYW1lKTtcbiAgICAgIGNvbnN0IGNvbXBsZXRlQ2FsbEJhY2sgPSAoKSA9PiB7XG4gICAgICAgIG5leHRFbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoZGlyZWN0aW9uYWxDbGFzc05hbWUsIG9yZGVyQ2xhc3NOYW1lKTtcbiAgICAgICAgbmV4dEVsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0FDVElWRSQyKTtcbiAgICAgICAgYWN0aXZlRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFJDIsIG9yZGVyQ2xhc3NOYW1lLCBkaXJlY3Rpb25hbENsYXNzTmFtZSk7XG4gICAgICAgIHRoaXMuX2lzU2xpZGluZyA9IGZhbHNlO1xuICAgICAgICB0cmlnZ2VyRXZlbnQoRVZFTlRfU0xJRCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZUNhbGxCYWNrLCBhY3RpdmVFbGVtZW50LCB0aGlzLl9pc0FuaW1hdGVkKCkpO1xuICAgICAgaWYgKGlzQ3ljbGluZykge1xuICAgICAgICB0aGlzLmN5Y2xlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIF9pc0FuaW1hdGVkKCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0xJREUpO1xuICAgIH1cbiAgICBfZ2V0QWN0aXZlKCkge1xuICAgICAgcmV0dXJuIFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfQUNUSVZFX0lURU0sIHRoaXMuX2VsZW1lbnQpO1xuICAgIH1cbiAgICBfZ2V0SXRlbXMoKSB7XG4gICAgICByZXR1cm4gU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9JVEVNLCB0aGlzLl9lbGVtZW50KTtcbiAgICB9XG4gICAgX2NsZWFySW50ZXJ2YWwoKSB7XG4gICAgICBpZiAodGhpcy5faW50ZXJ2YWwpIHtcbiAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9pbnRlcnZhbCk7XG4gICAgICAgIHRoaXMuX2ludGVydmFsID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gICAgX2RpcmVjdGlvblRvT3JkZXIoZGlyZWN0aW9uKSB7XG4gICAgICBpZiAoaXNSVEwoKSkge1xuICAgICAgICByZXR1cm4gZGlyZWN0aW9uID09PSBESVJFQ1RJT05fTEVGVCA/IE9SREVSX1BSRVYgOiBPUkRFUl9ORVhUO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OX0xFRlQgPyBPUkRFUl9ORVhUIDogT1JERVJfUFJFVjtcbiAgICB9XG4gICAgX29yZGVyVG9EaXJlY3Rpb24ob3JkZXIpIHtcbiAgICAgIGlmIChpc1JUTCgpKSB7XG4gICAgICAgIHJldHVybiBvcmRlciA9PT0gT1JERVJfUFJFViA/IERJUkVDVElPTl9MRUZUIDogRElSRUNUSU9OX1JJR0hUO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9yZGVyID09PSBPUkRFUl9QUkVWID8gRElSRUNUSU9OX1JJR0hUIDogRElSRUNUSU9OX0xFRlQ7XG4gICAgfVxuXG4gICAgLy8gU3RhdGljXG4gICAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gQ2Fyb3VzZWwuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBjb25maWcpO1xuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICBkYXRhLnRvKGNvbmZpZyk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmIChkYXRhW2NvbmZpZ10gPT09IHVuZGVmaW5lZCB8fCBjb25maWcuc3RhcnRzV2l0aCgnXycpIHx8IGNvbmZpZyA9PT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YVtjb25maWddKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxuICAgKi9cblxuICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDUsIFNFTEVDVE9SX0RBVEFfU0xJREUsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIGNvbnN0IHRhcmdldCA9IFNlbGVjdG9yRW5naW5lLmdldEVsZW1lbnRGcm9tU2VsZWN0b3IodGhpcyk7XG4gICAgaWYgKCF0YXJnZXQgfHwgIXRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9DQVJPVVNFTCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCBjYXJvdXNlbCA9IENhcm91c2VsLmdldE9yQ3JlYXRlSW5zdGFuY2UodGFyZ2V0KTtcbiAgICBjb25zdCBzbGlkZUluZGV4ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtc2xpZGUtdG8nKTtcbiAgICBpZiAoc2xpZGVJbmRleCkge1xuICAgICAgY2Fyb3VzZWwudG8oc2xpZGVJbmRleCk7XG4gICAgICBjYXJvdXNlbC5fbWF5YmVFbmFibGVDeWNsZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZSh0aGlzLCAnc2xpZGUnKSA9PT0gJ25leHQnKSB7XG4gICAgICBjYXJvdXNlbC5uZXh0KCk7XG4gICAgICBjYXJvdXNlbC5fbWF5YmVFbmFibGVDeWNsZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYXJvdXNlbC5wcmV2KCk7XG4gICAgY2Fyb3VzZWwuX21heWJlRW5hYmxlQ3ljbGUoKTtcbiAgfSk7XG4gIEV2ZW50SGFuZGxlci5vbih3aW5kb3csIEVWRU5UX0xPQURfREFUQV9BUEkkMywgKCkgPT4ge1xuICAgIGNvbnN0IGNhcm91c2VscyA9IFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfREFUQV9SSURFKTtcbiAgICBmb3IgKGNvbnN0IGNhcm91c2VsIG9mIGNhcm91c2Vscykge1xuICAgICAgQ2Fyb3VzZWwuZ2V0T3JDcmVhdGVJbnN0YW5jZShjYXJvdXNlbCk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogalF1ZXJ5XG4gICAqL1xuXG4gIGRlZmluZUpRdWVyeVBsdWdpbihDYXJvdXNlbCk7XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEJvb3RzdHJhcCBjb2xsYXBzZS5qc1xuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cblxuICAvKipcbiAgICogQ29uc3RhbnRzXG4gICAqL1xuXG4gIGNvbnN0IE5BTUUkYiA9ICdjb2xsYXBzZSc7XG4gIGNvbnN0IERBVEFfS0VZJDcgPSAnYnMuY29sbGFwc2UnO1xuICBjb25zdCBFVkVOVF9LRVkkNyA9IGAuJHtEQVRBX0tFWSQ3fWA7XG4gIGNvbnN0IERBVEFfQVBJX0tFWSQ0ID0gJy5kYXRhLWFwaSc7XG4gIGNvbnN0IEVWRU5UX1NIT1ckNiA9IGBzaG93JHtFVkVOVF9LRVkkN31gO1xuICBjb25zdCBFVkVOVF9TSE9XTiQ2ID0gYHNob3duJHtFVkVOVF9LRVkkN31gO1xuICBjb25zdCBFVkVOVF9ISURFJDYgPSBgaGlkZSR7RVZFTlRfS0VZJDd9YDtcbiAgY29uc3QgRVZFTlRfSElEREVOJDYgPSBgaGlkZGVuJHtFVkVOVF9LRVkkN31gO1xuICBjb25zdCBFVkVOVF9DTElDS19EQVRBX0FQSSQ0ID0gYGNsaWNrJHtFVkVOVF9LRVkkN30ke0RBVEFfQVBJX0tFWSQ0fWA7XG4gIGNvbnN0IENMQVNTX05BTUVfU0hPVyQ3ID0gJ3Nob3cnO1xuICBjb25zdCBDTEFTU19OQU1FX0NPTExBUFNFID0gJ2NvbGxhcHNlJztcbiAgY29uc3QgQ0xBU1NfTkFNRV9DT0xMQVBTSU5HID0gJ2NvbGxhcHNpbmcnO1xuICBjb25zdCBDTEFTU19OQU1FX0NPTExBUFNFRCA9ICdjb2xsYXBzZWQnO1xuICBjb25zdCBDTEFTU19OQU1FX0RFRVBFUl9DSElMRFJFTiA9IGA6c2NvcGUgLiR7Q0xBU1NfTkFNRV9DT0xMQVBTRX0gLiR7Q0xBU1NfTkFNRV9DT0xMQVBTRX1gO1xuICBjb25zdCBDTEFTU19OQU1FX0hPUklaT05UQUwgPSAnY29sbGFwc2UtaG9yaXpvbnRhbCc7XG4gIGNvbnN0IFdJRFRIID0gJ3dpZHRoJztcbiAgY29uc3QgSEVJR0hUID0gJ2hlaWdodCc7XG4gIGNvbnN0IFNFTEVDVE9SX0FDVElWRVMgPSAnLmNvbGxhcHNlLnNob3csIC5jb2xsYXBzZS5jb2xsYXBzaW5nJztcbiAgY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEUkNCA9ICdbZGF0YS1icy10b2dnbGU9XCJjb2xsYXBzZVwiXSc7XG4gIGNvbnN0IERlZmF1bHQkYSA9IHtcbiAgICBwYXJlbnQ6IG51bGwsXG4gICAgdG9nZ2xlOiB0cnVlXG4gIH07XG4gIGNvbnN0IERlZmF1bHRUeXBlJGEgPSB7XG4gICAgcGFyZW50OiAnKG51bGx8ZWxlbWVudCknLFxuICAgIHRvZ2dsZTogJ2Jvb2xlYW4nXG4gIH07XG5cbiAgLyoqXG4gICAqIENsYXNzIGRlZmluaXRpb25cbiAgICovXG5cbiAgY2xhc3MgQ29sbGFwc2UgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICAgIHN1cGVyKGVsZW1lbnQsIGNvbmZpZyk7XG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3RyaWdnZXJBcnJheSA9IFtdO1xuICAgICAgY29uc3QgdG9nZ2xlTGlzdCA9IFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfREFUQV9UT0dHTEUkNCk7XG4gICAgICBmb3IgKGNvbnN0IGVsZW0gb2YgdG9nZ2xlTGlzdCkge1xuICAgICAgICBjb25zdCBzZWxlY3RvciA9IFNlbGVjdG9yRW5naW5lLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQoZWxlbSk7XG4gICAgICAgIGNvbnN0IGZpbHRlckVsZW1lbnQgPSBTZWxlY3RvckVuZ2luZS5maW5kKHNlbGVjdG9yKS5maWx0ZXIoZm91bmRFbGVtZW50ID0+IGZvdW5kRWxlbWVudCA9PT0gdGhpcy5fZWxlbWVudCk7XG4gICAgICAgIGlmIChzZWxlY3RvciAhPT0gbnVsbCAmJiBmaWx0ZXJFbGVtZW50Lmxlbmd0aCkge1xuICAgICAgICAgIHRoaXMuX3RyaWdnZXJBcnJheS5wdXNoKGVsZW0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9pbml0aWFsaXplQ2hpbGRyZW4oKTtcbiAgICAgIGlmICghdGhpcy5fY29uZmlnLnBhcmVudCkge1xuICAgICAgICB0aGlzLl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3ModGhpcy5fdHJpZ2dlckFycmF5LCB0aGlzLl9pc1Nob3duKCkpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy50b2dnbGUpIHtcbiAgICAgICAgdGhpcy50b2dnbGUoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBHZXR0ZXJzXG4gICAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgICAgcmV0dXJuIERlZmF1bHQkYTtcbiAgICB9XG4gICAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICAgIHJldHVybiBEZWZhdWx0VHlwZSRhO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgICByZXR1cm4gTkFNRSRiO1xuICAgIH1cblxuICAgIC8vIFB1YmxpY1xuICAgIHRvZ2dsZSgpIHtcbiAgICAgIGlmICh0aGlzLl9pc1Nob3duKCkpIHtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2hvdygpIHtcbiAgICAgIGlmICh0aGlzLl9pc1RyYW5zaXRpb25pbmcgfHwgdGhpcy5faXNTaG93bigpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBhY3RpdmVDaGlsZHJlbiA9IFtdO1xuXG4gICAgICAvLyBmaW5kIGFjdGl2ZSBjaGlsZHJlblxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5wYXJlbnQpIHtcbiAgICAgICAgYWN0aXZlQ2hpbGRyZW4gPSB0aGlzLl9nZXRGaXJzdExldmVsQ2hpbGRyZW4oU0VMRUNUT1JfQUNUSVZFUykuZmlsdGVyKGVsZW1lbnQgPT4gZWxlbWVudCAhPT0gdGhpcy5fZWxlbWVudCkubWFwKGVsZW1lbnQgPT4gQ29sbGFwc2UuZ2V0T3JDcmVhdGVJbnN0YW5jZShlbGVtZW50LCB7XG4gICAgICAgICAgdG9nZ2xlOiBmYWxzZVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgICBpZiAoYWN0aXZlQ2hpbGRyZW4ubGVuZ3RoICYmIGFjdGl2ZUNoaWxkcmVuWzBdLl9pc1RyYW5zaXRpb25pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3RhcnRFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1ckNik7XG4gICAgICBpZiAoc3RhcnRFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgYWN0aXZlSW5zdGFuY2Ugb2YgYWN0aXZlQ2hpbGRyZW4pIHtcbiAgICAgICAgYWN0aXZlSW5zdGFuY2UuaGlkZSgpO1xuICAgICAgfVxuICAgICAgY29uc3QgZGltZW5zaW9uID0gdGhpcy5fZ2V0RGltZW5zaW9uKCk7XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9DT0xMQVBTRSk7XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9DT0xMQVBTSU5HKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9IDA7XG4gICAgICB0aGlzLl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3ModGhpcy5fdHJpZ2dlckFycmF5LCB0cnVlKTtcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IHRydWU7XG4gICAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0NPTExBUFNJTkcpO1xuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9DT0xMQVBTRSwgQ0xBU1NfTkFNRV9TSE9XJDcpO1xuICAgICAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSAnJztcbiAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPV04kNik7XG4gICAgICB9O1xuICAgICAgY29uc3QgY2FwaXRhbGl6ZWREaW1lbnNpb24gPSBkaW1lbnNpb25bMF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSgxKTtcbiAgICAgIGNvbnN0IHNjcm9sbFNpemUgPSBgc2Nyb2xsJHtjYXBpdGFsaXplZERpbWVuc2lvbn1gO1xuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZSwgdGhpcy5fZWxlbWVudCwgdHJ1ZSk7XG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSBgJHt0aGlzLl9lbGVtZW50W3Njcm9sbFNpemVdfXB4YDtcbiAgICB9XG4gICAgaGlkZSgpIHtcbiAgICAgIGlmICh0aGlzLl9pc1RyYW5zaXRpb25pbmcgfHwgIXRoaXMuX2lzU2hvd24oKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBzdGFydEV2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElERSQ2KTtcbiAgICAgIGlmIChzdGFydEV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZGltZW5zaW9uID0gdGhpcy5fZ2V0RGltZW5zaW9uKCk7XG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSBgJHt0aGlzLl9lbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpW2RpbWVuc2lvbl19cHhgO1xuICAgICAgcmVmbG93KHRoaXMuX2VsZW1lbnQpO1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQ09MTEFQU0lORyk7XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9DT0xMQVBTRSwgQ0xBU1NfTkFNRV9TSE9XJDcpO1xuICAgICAgZm9yIChjb25zdCB0cmlnZ2VyIG9mIHRoaXMuX3RyaWdnZXJBcnJheSkge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gU2VsZWN0b3JFbmdpbmUuZ2V0RWxlbWVudEZyb21TZWxlY3Rvcih0cmlnZ2VyKTtcbiAgICAgICAgaWYgKGVsZW1lbnQgJiYgIXRoaXMuX2lzU2hvd24oZWxlbWVudCkpIHtcbiAgICAgICAgICB0aGlzLl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3MoW3RyaWdnZXJdLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IHRydWU7XG4gICAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0NPTExBUFNJTkcpO1xuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9DT0xMQVBTRSk7XG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJRERFTiQ2KTtcbiAgICAgIH07XG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSAnJztcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIHRoaXMuX2VsZW1lbnQsIHRydWUpO1xuICAgIH1cbiAgICBfaXNTaG93bihlbGVtZW50ID0gdGhpcy5fZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfU0hPVyQ3KTtcbiAgICB9XG5cbiAgICAvLyBQcml2YXRlXG4gICAgX2NvbmZpZ0FmdGVyTWVyZ2UoY29uZmlnKSB7XG4gICAgICBjb25maWcudG9nZ2xlID0gQm9vbGVhbihjb25maWcudG9nZ2xlKTsgLy8gQ29lcmNlIHN0cmluZyB2YWx1ZXNcbiAgICAgIGNvbmZpZy5wYXJlbnQgPSBnZXRFbGVtZW50KGNvbmZpZy5wYXJlbnQpO1xuICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG4gICAgX2dldERpbWVuc2lvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0hPUklaT05UQUwpID8gV0lEVEggOiBIRUlHSFQ7XG4gICAgfVxuICAgIF9pbml0aWFsaXplQ2hpbGRyZW4oKSB7XG4gICAgICBpZiAoIXRoaXMuX2NvbmZpZy5wYXJlbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLl9nZXRGaXJzdExldmVsQ2hpbGRyZW4oU0VMRUNUT1JfREFUQV9UT0dHTEUkNCk7XG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgY2hpbGRyZW4pIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0ZWQgPSBTZWxlY3RvckVuZ2luZS5nZXRFbGVtZW50RnJvbVNlbGVjdG9yKGVsZW1lbnQpO1xuICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcbiAgICAgICAgICB0aGlzLl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3MoW2VsZW1lbnRdLCB0aGlzLl9pc1Nob3duKHNlbGVjdGVkKSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgX2dldEZpcnN0TGV2ZWxDaGlsZHJlbihzZWxlY3Rvcikge1xuICAgICAgY29uc3QgY2hpbGRyZW4gPSBTZWxlY3RvckVuZ2luZS5maW5kKENMQVNTX05BTUVfREVFUEVSX0NISUxEUkVOLCB0aGlzLl9jb25maWcucGFyZW50KTtcbiAgICAgIC8vIHJlbW92ZSBjaGlsZHJlbiBpZiBncmVhdGVyIGRlcHRoXG4gICAgICByZXR1cm4gU2VsZWN0b3JFbmdpbmUuZmluZChzZWxlY3RvciwgdGhpcy5fY29uZmlnLnBhcmVudCkuZmlsdGVyKGVsZW1lbnQgPT4gIWNoaWxkcmVuLmluY2x1ZGVzKGVsZW1lbnQpKTtcbiAgICB9XG4gICAgX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyh0cmlnZ2VyQXJyYXksIGlzT3Blbikge1xuICAgICAgaWYgKCF0cmlnZ2VyQXJyYXkubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0cmlnZ2VyQXJyYXkpIHtcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKENMQVNTX05BTUVfQ09MTEFQU0VELCAhaXNPcGVuKTtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCBpc09wZW4pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFN0YXRpY1xuICAgIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgICBjb25zdCBfY29uZmlnID0ge307XG4gICAgICBpZiAodHlwZW9mIGNvbmZpZyA9PT0gJ3N0cmluZycgJiYgL3Nob3d8aGlkZS8udGVzdChjb25maWcpKSB7XG4gICAgICAgIF9jb25maWcudG9nZ2xlID0gZmFsc2U7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IENvbGxhcHNlLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgX2NvbmZpZyk7XG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZGF0YVtjb25maWddKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxuICAgKi9cblxuICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDQsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDQsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIC8vIHByZXZlbnREZWZhdWx0IG9ubHkgZm9yIDxhPiBlbGVtZW50cyAod2hpY2ggY2hhbmdlIHRoZSBVUkwpIG5vdCBpbnNpZGUgdGhlIGNvbGxhcHNpYmxlIGVsZW1lbnRcbiAgICBpZiAoZXZlbnQudGFyZ2V0LnRhZ05hbWUgPT09ICdBJyB8fCBldmVudC5kZWxlZ2F0ZVRhcmdldCAmJiBldmVudC5kZWxlZ2F0ZVRhcmdldC50YWdOYW1lID09PSAnQScpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBTZWxlY3RvckVuZ2luZS5nZXRNdWx0aXBsZUVsZW1lbnRzRnJvbVNlbGVjdG9yKHRoaXMpKSB7XG4gICAgICBDb2xsYXBzZS5nZXRPckNyZWF0ZUluc3RhbmNlKGVsZW1lbnQsIHtcbiAgICAgICAgdG9nZ2xlOiBmYWxzZVxuICAgICAgfSkudG9nZ2xlKCk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogalF1ZXJ5XG4gICAqL1xuXG4gIGRlZmluZUpRdWVyeVBsdWdpbihDb2xsYXBzZSk7XG5cbiAgdmFyIHRvcCA9ICd0b3AnO1xuICB2YXIgYm90dG9tID0gJ2JvdHRvbSc7XG4gIHZhciByaWdodCA9ICdyaWdodCc7XG4gIHZhciBsZWZ0ID0gJ2xlZnQnO1xuICB2YXIgYXV0byA9ICdhdXRvJztcbiAgdmFyIGJhc2VQbGFjZW1lbnRzID0gW3RvcCwgYm90dG9tLCByaWdodCwgbGVmdF07XG4gIHZhciBzdGFydCA9ICdzdGFydCc7XG4gIHZhciBlbmQgPSAnZW5kJztcbiAgdmFyIGNsaXBwaW5nUGFyZW50cyA9ICdjbGlwcGluZ1BhcmVudHMnO1xuICB2YXIgdmlld3BvcnQgPSAndmlld3BvcnQnO1xuICB2YXIgcG9wcGVyID0gJ3BvcHBlcic7XG4gIHZhciByZWZlcmVuY2UgPSAncmVmZXJlbmNlJztcbiAgdmFyIHZhcmlhdGlvblBsYWNlbWVudHMgPSAvKiNfX1BVUkVfXyovYmFzZVBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICAgIHJldHVybiBhY2MuY29uY2F0KFtwbGFjZW1lbnQgKyBcIi1cIiArIHN0YXJ0LCBwbGFjZW1lbnQgKyBcIi1cIiArIGVuZF0pO1xuICB9LCBbXSk7XG4gIHZhciBwbGFjZW1lbnRzID0gLyojX19QVVJFX18qL1tdLmNvbmNhdChiYXNlUGxhY2VtZW50cywgW2F1dG9dKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIGFjYy5jb25jYXQoW3BsYWNlbWVudCwgcGxhY2VtZW50ICsgXCItXCIgKyBzdGFydCwgcGxhY2VtZW50ICsgXCItXCIgKyBlbmRdKTtcbiAgfSwgW10pOyAvLyBtb2RpZmllcnMgdGhhdCBuZWVkIHRvIHJlYWQgdGhlIERPTVxuXG4gIHZhciBiZWZvcmVSZWFkID0gJ2JlZm9yZVJlYWQnO1xuICB2YXIgcmVhZCA9ICdyZWFkJztcbiAgdmFyIGFmdGVyUmVhZCA9ICdhZnRlclJlYWQnOyAvLyBwdXJlLWxvZ2ljIG1vZGlmaWVyc1xuXG4gIHZhciBiZWZvcmVNYWluID0gJ2JlZm9yZU1haW4nO1xuICB2YXIgbWFpbiA9ICdtYWluJztcbiAgdmFyIGFmdGVyTWFpbiA9ICdhZnRlck1haW4nOyAvLyBtb2RpZmllciB3aXRoIHRoZSBwdXJwb3NlIHRvIHdyaXRlIHRvIHRoZSBET00gKG9yIHdyaXRlIGludG8gYSBmcmFtZXdvcmsgc3RhdGUpXG5cbiAgdmFyIGJlZm9yZVdyaXRlID0gJ2JlZm9yZVdyaXRlJztcbiAgdmFyIHdyaXRlID0gJ3dyaXRlJztcbiAgdmFyIGFmdGVyV3JpdGUgPSAnYWZ0ZXJXcml0ZSc7XG4gIHZhciBtb2RpZmllclBoYXNlcyA9IFtiZWZvcmVSZWFkLCByZWFkLCBhZnRlclJlYWQsIGJlZm9yZU1haW4sIG1haW4sIGFmdGVyTWFpbiwgYmVmb3JlV3JpdGUsIHdyaXRlLCBhZnRlcldyaXRlXTtcblxuICBmdW5jdGlvbiBnZXROb2RlTmFtZShlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQgPyAoZWxlbWVudC5ub2RlTmFtZSB8fCAnJykudG9Mb3dlckNhc2UoKSA6IG51bGw7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRXaW5kb3cobm9kZSkge1xuICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgIHJldHVybiB3aW5kb3c7XG4gICAgfVxuXG4gICAgaWYgKG5vZGUudG9TdHJpbmcoKSAhPT0gJ1tvYmplY3QgV2luZG93XScpIHtcbiAgICAgIHZhciBvd25lckRvY3VtZW50ID0gbm9kZS5vd25lckRvY3VtZW50O1xuICAgICAgcmV0dXJuIG93bmVyRG9jdW1lbnQgPyBvd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IHx8IHdpbmRvdyA6IHdpbmRvdztcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRWxlbWVudChub2RlKSB7XG4gICAgdmFyIE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuRWxlbWVudDtcbiAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQ7XG4gIH1cblxuICBmdW5jdGlvbiBpc0hUTUxFbGVtZW50KG5vZGUpIHtcbiAgICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5IVE1MRWxlbWVudDtcbiAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gaXNTaGFkb3dSb290KG5vZGUpIHtcbiAgICAvLyBJRSAxMSBoYXMgbm8gU2hhZG93Um9vdFxuICAgIGlmICh0eXBlb2YgU2hhZG93Um9vdCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgT3duRWxlbWVudCA9IGdldFdpbmRvdyhub2RlKS5TaGFkb3dSb290O1xuICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgU2hhZG93Um9vdDtcbiAgfVxuXG4gIC8vIGFuZCBhcHBsaWVzIHRoZW0gdG8gdGhlIEhUTUxFbGVtZW50cyBzdWNoIGFzIHBvcHBlciBhbmQgYXJyb3dcblxuICBmdW5jdGlvbiBhcHBseVN0eWxlcyhfcmVmKSB7XG4gICAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZTtcbiAgICBPYmplY3Qua2V5cyhzdGF0ZS5lbGVtZW50cykuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgdmFyIHN0eWxlID0gc3RhdGUuc3R5bGVzW25hbWVdIHx8IHt9O1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBzdGF0ZS5hdHRyaWJ1dGVzW25hbWVdIHx8IHt9O1xuICAgICAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1tuYW1lXTsgLy8gYXJyb3cgaXMgb3B0aW9uYWwgKyB2aXJ0dWFsIGVsZW1lbnRzXG5cbiAgICAgIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAhZ2V0Tm9kZU5hbWUoZWxlbWVudCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBGbG93IGRvZXNuJ3Qgc3VwcG9ydCB0byBleHRlbmQgdGhpcyBwcm9wZXJ0eSwgYnV0IGl0J3MgdGhlIG1vc3RcbiAgICAgIC8vIGVmZmVjdGl2ZSB3YXkgdG8gYXBwbHkgc3R5bGVzIHRvIGFuIEhUTUxFbGVtZW50XG4gICAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cblxuXG4gICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcbiAgICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlc1tuYW1lXTtcblxuICAgICAgICBpZiAodmFsdWUgPT09IGZhbHNlKSB7XG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUgPT09IHRydWUgPyAnJyA6IHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBlZmZlY3QkMihfcmVmMikge1xuICAgIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlO1xuICAgIHZhciBpbml0aWFsU3R5bGVzID0ge1xuICAgICAgcG9wcGVyOiB7XG4gICAgICAgIHBvc2l0aW9uOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5LFxuICAgICAgICBsZWZ0OiAnMCcsXG4gICAgICAgIHRvcDogJzAnLFxuICAgICAgICBtYXJnaW46ICcwJ1xuICAgICAgfSxcbiAgICAgIGFycm93OiB7XG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXG4gICAgICB9LFxuICAgICAgcmVmZXJlbmNlOiB7fVxuICAgIH07XG4gICAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5wb3BwZXIuc3R5bGUsIGluaXRpYWxTdHlsZXMucG9wcGVyKTtcbiAgICBzdGF0ZS5zdHlsZXMgPSBpbml0aWFsU3R5bGVzO1xuXG4gICAgaWYgKHN0YXRlLmVsZW1lbnRzLmFycm93KSB7XG4gICAgICBPYmplY3QuYXNzaWduKHN0YXRlLmVsZW1lbnRzLmFycm93LnN0eWxlLCBpbml0aWFsU3R5bGVzLmFycm93KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgT2JqZWN0LmtleXMoc3RhdGUuZWxlbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgdmFyIGVsZW1lbnQgPSBzdGF0ZS5lbGVtZW50c1tuYW1lXTtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBzdGF0ZS5hdHRyaWJ1dGVzW25hbWVdIHx8IHt9O1xuICAgICAgICB2YXIgc3R5bGVQcm9wZXJ0aWVzID0gT2JqZWN0LmtleXMoc3RhdGUuc3R5bGVzLmhhc093blByb3BlcnR5KG5hbWUpID8gc3RhdGUuc3R5bGVzW25hbWVdIDogaW5pdGlhbFN0eWxlc1tuYW1lXSk7IC8vIFNldCBhbGwgdmFsdWVzIHRvIGFuIGVtcHR5IHN0cmluZyB0byB1bnNldCB0aGVtXG5cbiAgICAgICAgdmFyIHN0eWxlID0gc3R5bGVQcm9wZXJ0aWVzLnJlZHVjZShmdW5jdGlvbiAoc3R5bGUsIHByb3BlcnR5KSB7XG4gICAgICAgICAgc3R5bGVbcHJvcGVydHldID0gJyc7XG4gICAgICAgICAgcmV0dXJuIHN0eWxlO1xuICAgICAgICB9LCB7fSk7IC8vIGFycm93IGlzIG9wdGlvbmFsICsgdmlydHVhbCBlbGVtZW50c1xuXG4gICAgICAgIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAhZ2V0Tm9kZU5hbWUoZWxlbWVudCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBPYmplY3QuYXNzaWduKGVsZW1lbnQuc3R5bGUsIHN0eWxlKTtcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9O1xuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG4gIGNvbnN0IGFwcGx5U3R5bGVzJDEgPSB7XG4gICAgbmFtZTogJ2FwcGx5U3R5bGVzJyxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIHBoYXNlOiAnd3JpdGUnLFxuICAgIGZuOiBhcHBseVN0eWxlcyxcbiAgICBlZmZlY3Q6IGVmZmVjdCQyLFxuICAgIHJlcXVpcmVzOiBbJ2NvbXB1dGVTdHlsZXMnXVxuICB9O1xuXG4gIGZ1bmN0aW9uIGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB9XG5cbiAgdmFyIG1heCA9IE1hdGgubWF4O1xuICB2YXIgbWluID0gTWF0aC5taW47XG4gIHZhciByb3VuZCA9IE1hdGgucm91bmQ7XG5cbiAgZnVuY3Rpb24gZ2V0VUFTdHJpbmcoKSB7XG4gICAgdmFyIHVhRGF0YSA9IG5hdmlnYXRvci51c2VyQWdlbnREYXRhO1xuXG4gICAgaWYgKHVhRGF0YSAhPSBudWxsICYmIHVhRGF0YS5icmFuZHMgJiYgQXJyYXkuaXNBcnJheSh1YURhdGEuYnJhbmRzKSkge1xuICAgICAgcmV0dXJuIHVhRGF0YS5icmFuZHMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIHJldHVybiBpdGVtLmJyYW5kICsgXCIvXCIgKyBpdGVtLnZlcnNpb247XG4gICAgICB9KS5qb2luKCcgJyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5hdmlnYXRvci51c2VyQWdlbnQ7XG4gIH1cblxuICBmdW5jdGlvbiBpc0xheW91dFZpZXdwb3J0KCkge1xuICAgIHJldHVybiAhL14oKD8hY2hyb21lfGFuZHJvaWQpLikqc2FmYXJpL2kudGVzdChnZXRVQVN0cmluZygpKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50LCBpbmNsdWRlU2NhbGUsIGlzRml4ZWRTdHJhdGVneSkge1xuICAgIGlmIChpbmNsdWRlU2NhbGUgPT09IHZvaWQgMCkge1xuICAgICAgaW5jbHVkZVNjYWxlID0gZmFsc2U7XG4gICAgfVxuXG4gICAgaWYgKGlzRml4ZWRTdHJhdGVneSA9PT0gdm9pZCAwKSB7XG4gICAgICBpc0ZpeGVkU3RyYXRlZ3kgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgY2xpZW50UmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgdmFyIHNjYWxlWCA9IDE7XG4gICAgdmFyIHNjYWxlWSA9IDE7XG5cbiAgICBpZiAoaW5jbHVkZVNjYWxlICYmIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgIHNjYWxlWCA9IGVsZW1lbnQub2Zmc2V0V2lkdGggPiAwID8gcm91bmQoY2xpZW50UmVjdC53aWR0aCkgLyBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDEgOiAxO1xuICAgICAgc2NhbGVZID0gZWxlbWVudC5vZmZzZXRIZWlnaHQgPiAwID8gcm91bmQoY2xpZW50UmVjdC5oZWlnaHQpIC8gZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgMSA6IDE7XG4gICAgfVxuXG4gICAgdmFyIF9yZWYgPSBpc0VsZW1lbnQoZWxlbWVudCkgPyBnZXRXaW5kb3coZWxlbWVudCkgOiB3aW5kb3csXG4gICAgICAgIHZpc3VhbFZpZXdwb3J0ID0gX3JlZi52aXN1YWxWaWV3cG9ydDtcblxuICAgIHZhciBhZGRWaXN1YWxPZmZzZXRzID0gIWlzTGF5b3V0Vmlld3BvcnQoKSAmJiBpc0ZpeGVkU3RyYXRlZ3k7XG4gICAgdmFyIHggPSAoY2xpZW50UmVjdC5sZWZ0ICsgKGFkZFZpc3VhbE9mZnNldHMgJiYgdmlzdWFsVmlld3BvcnQgPyB2aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0IDogMCkpIC8gc2NhbGVYO1xuICAgIHZhciB5ID0gKGNsaWVudFJlY3QudG9wICsgKGFkZFZpc3VhbE9mZnNldHMgJiYgdmlzdWFsVmlld3BvcnQgPyB2aXN1YWxWaWV3cG9ydC5vZmZzZXRUb3AgOiAwKSkgLyBzY2FsZVk7XG4gICAgdmFyIHdpZHRoID0gY2xpZW50UmVjdC53aWR0aCAvIHNjYWxlWDtcbiAgICB2YXIgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQgLyBzY2FsZVk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgdG9wOiB5LFxuICAgICAgcmlnaHQ6IHggKyB3aWR0aCxcbiAgICAgIGJvdHRvbTogeSArIGhlaWdodCxcbiAgICAgIGxlZnQ6IHgsXG4gICAgICB4OiB4LFxuICAgICAgeTogeVxuICAgIH07XG4gIH1cblxuICAvLyBtZWFucyBpdCBkb2Vzbid0IHRha2UgaW50byBhY2NvdW50IHRyYW5zZm9ybXMuXG5cbiAgZnVuY3Rpb24gZ2V0TGF5b3V0UmVjdChlbGVtZW50KSB7XG4gICAgdmFyIGNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCk7IC8vIFVzZSB0aGUgY2xpZW50UmVjdCBzaXplcyBpZiBpdCdzIG5vdCBiZWVuIHRyYW5zZm9ybWVkLlxuICAgIC8vIEZpeGVzIGh0dHBzOi8vZ2l0aHViLmNvbS9wb3BwZXJqcy9wb3BwZXItY29yZS9pc3N1ZXMvMTIyM1xuXG4gICAgdmFyIHdpZHRoID0gZWxlbWVudC5vZmZzZXRXaWR0aDtcbiAgICB2YXIgaGVpZ2h0ID0gZWxlbWVudC5vZmZzZXRIZWlnaHQ7XG5cbiAgICBpZiAoTWF0aC5hYnMoY2xpZW50UmVjdC53aWR0aCAtIHdpZHRoKSA8PSAxKSB7XG4gICAgICB3aWR0aCA9IGNsaWVudFJlY3Qud2lkdGg7XG4gICAgfVxuXG4gICAgaWYgKE1hdGguYWJzKGNsaWVudFJlY3QuaGVpZ2h0IC0gaGVpZ2h0KSA8PSAxKSB7XG4gICAgICBoZWlnaHQgPSBjbGllbnRSZWN0LmhlaWdodDtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgeDogZWxlbWVudC5vZmZzZXRMZWZ0LFxuICAgICAgeTogZWxlbWVudC5vZmZzZXRUb3AsXG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBjb250YWlucyhwYXJlbnQsIGNoaWxkKSB7XG4gICAgdmFyIHJvb3ROb2RlID0gY2hpbGQuZ2V0Um9vdE5vZGUgJiYgY2hpbGQuZ2V0Um9vdE5vZGUoKTsgLy8gRmlyc3QsIGF0dGVtcHQgd2l0aCBmYXN0ZXIgbmF0aXZlIG1ldGhvZFxuXG4gICAgaWYgKHBhcmVudC5jb250YWlucyhjaGlsZCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0gLy8gdGhlbiBmYWxsYmFjayB0byBjdXN0b20gaW1wbGVtZW50YXRpb24gd2l0aCBTaGFkb3cgRE9NIHN1cHBvcnRcbiAgICBlbHNlIGlmIChyb290Tm9kZSAmJiBpc1NoYWRvd1Jvb3Qocm9vdE5vZGUpKSB7XG4gICAgICAgIHZhciBuZXh0ID0gY2hpbGQ7XG5cbiAgICAgICAgZG8ge1xuICAgICAgICAgIGlmIChuZXh0ICYmIHBhcmVudC5pc1NhbWVOb2RlKG5leHQpKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXTogbmVlZCBhIGJldHRlciB3YXkgdG8gaGFuZGxlIHRoaXMuLi5cblxuXG4gICAgICAgICAgbmV4dCA9IG5leHQucGFyZW50Tm9kZSB8fCBuZXh0Lmhvc3Q7XG4gICAgICAgIH0gd2hpbGUgKG5leHQpO1xuICAgICAgfSAvLyBHaXZlIHVwLCB0aGUgcmVzdWx0IGlzIGZhbHNlXG5cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENvbXB1dGVkU3R5bGUkMShlbGVtZW50KSB7XG4gICAgcmV0dXJuIGdldFdpbmRvdyhlbGVtZW50KS5nZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpO1xuICB9XG5cbiAgZnVuY3Rpb24gaXNUYWJsZUVsZW1lbnQoZWxlbWVudCkge1xuICAgIHJldHVybiBbJ3RhYmxlJywgJ3RkJywgJ3RoJ10uaW5kZXhPZihnZXROb2RlTmFtZShlbGVtZW50KSkgPj0gMDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXTogYXNzdW1lIGJvZHkgaXMgYWx3YXlzIGF2YWlsYWJsZVxuICAgIHJldHVybiAoKGlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQub3duZXJEb2N1bWVudCA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgIGVsZW1lbnQuZG9jdW1lbnQpIHx8IHdpbmRvdy5kb2N1bWVudCkuZG9jdW1lbnRFbGVtZW50O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0UGFyZW50Tm9kZShlbGVtZW50KSB7XG4gICAgaWYgKGdldE5vZGVOYW1lKGVsZW1lbnQpID09PSAnaHRtbCcpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH1cblxuICAgIHJldHVybiAoLy8gdGhpcyBpcyBhIHF1aWNrZXIgKGJ1dCBsZXNzIHR5cGUgc2FmZSkgd2F5IHRvIHNhdmUgcXVpdGUgc29tZSBieXRlcyBmcm9tIHRoZSBidW5kbGVcbiAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl1cbiAgICAgIC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuICAgICAgZWxlbWVudC5hc3NpZ25lZFNsb3QgfHwgLy8gc3RlcCBpbnRvIHRoZSBzaGFkb3cgRE9NIG9mIHRoZSBwYXJlbnQgb2YgYSBzbG90dGVkIG5vZGVcbiAgICAgIGVsZW1lbnQucGFyZW50Tm9kZSB8fCAoIC8vIERPTSBFbGVtZW50IGRldGVjdGVkXG4gICAgICBpc1NoYWRvd1Jvb3QoZWxlbWVudCkgPyBlbGVtZW50Lmhvc3QgOiBudWxsKSB8fCAvLyBTaGFkb3dSb290IGRldGVjdGVkXG4gICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogSFRNTEVsZW1lbnQgaXMgYSBOb2RlXG4gICAgICBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkgLy8gZmFsbGJhY2tcblxuICAgICk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy84MzdcbiAgICBnZXRDb21wdXRlZFN0eWxlJDEoZWxlbWVudCkucG9zaXRpb24gPT09ICdmaXhlZCcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50Lm9mZnNldFBhcmVudDtcbiAgfSAvLyBgLm9mZnNldFBhcmVudGAgcmVwb3J0cyBgbnVsbGAgZm9yIGZpeGVkIGVsZW1lbnRzLCB3aGlsZSBhYnNvbHV0ZSBlbGVtZW50c1xuICAvLyByZXR1cm4gdGhlIGNvbnRhaW5pbmcgYmxvY2tcblxuXG4gIGZ1bmN0aW9uIGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB7XG4gICAgdmFyIGlzRmlyZWZveCA9IC9maXJlZm94L2kudGVzdChnZXRVQVN0cmluZygpKTtcbiAgICB2YXIgaXNJRSA9IC9UcmlkZW50L2kudGVzdChnZXRVQVN0cmluZygpKTtcblxuICAgIGlmIChpc0lFICYmIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcbiAgICAgIC8vIEluIElFIDksIDEwIGFuZCAxMSBmaXhlZCBlbGVtZW50cyBjb250YWluaW5nIGJsb2NrIGlzIGFsd2F5cyBlc3RhYmxpc2hlZCBieSB0aGUgdmlld3BvcnRcbiAgICAgIHZhciBlbGVtZW50Q3NzID0gZ2V0Q29tcHV0ZWRTdHlsZSQxKGVsZW1lbnQpO1xuXG4gICAgICBpZiAoZWxlbWVudENzcy5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY3VycmVudE5vZGUgPSBnZXRQYXJlbnROb2RlKGVsZW1lbnQpO1xuXG4gICAgaWYgKGlzU2hhZG93Um9vdChjdXJyZW50Tm9kZSkpIHtcbiAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUuaG9zdDtcbiAgICB9XG5cbiAgICB3aGlsZSAoaXNIVE1MRWxlbWVudChjdXJyZW50Tm9kZSkgJiYgWydodG1sJywgJ2JvZHknXS5pbmRleE9mKGdldE5vZGVOYW1lKGN1cnJlbnROb2RlKSkgPCAwKSB7XG4gICAgICB2YXIgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZSQxKGN1cnJlbnROb2RlKTsgLy8gVGhpcyBpcyBub24tZXhoYXVzdGl2ZSBidXQgY292ZXJzIHRoZSBtb3N0IGNvbW1vbiBDU1MgcHJvcGVydGllcyB0aGF0XG4gICAgICAvLyBjcmVhdGUgYSBjb250YWluaW5nIGJsb2NrLlxuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQ1NTL0NvbnRhaW5pbmdfYmxvY2sjaWRlbnRpZnlpbmdfdGhlX2NvbnRhaW5pbmdfYmxvY2tcblxuICAgICAgaWYgKGNzcy50cmFuc2Zvcm0gIT09ICdub25lJyB8fCBjc3MucGVyc3BlY3RpdmUgIT09ICdub25lJyB8fCBjc3MuY29udGFpbiA9PT0gJ3BhaW50JyB8fCBbJ3RyYW5zZm9ybScsICdwZXJzcGVjdGl2ZSddLmluZGV4T2YoY3NzLndpbGxDaGFuZ2UpICE9PSAtMSB8fCBpc0ZpcmVmb3ggJiYgY3NzLndpbGxDaGFuZ2UgPT09ICdmaWx0ZXInIHx8IGlzRmlyZWZveCAmJiBjc3MuZmlsdGVyICYmIGNzcy5maWx0ZXIgIT09ICdub25lJykge1xuICAgICAgICByZXR1cm4gY3VycmVudE5vZGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLnBhcmVudE5vZGU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH0gLy8gR2V0cyB0aGUgY2xvc2VzdCBhbmNlc3RvciBwb3NpdGlvbmVkIGVsZW1lbnQuIEhhbmRsZXMgc29tZSBlZGdlIGNhc2VzLFxuICAvLyBzdWNoIGFzIHRhYmxlIGFuY2VzdG9ycyBhbmQgY3Jvc3MgYnJvd3NlciBidWdzLlxuXG5cbiAgZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgICB2YXIgd2luZG93ID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICAgIHZhciBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQpO1xuXG4gICAgd2hpbGUgKG9mZnNldFBhcmVudCAmJiBpc1RhYmxlRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGdldENvbXB1dGVkU3R5bGUkMShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uID09PSAnc3RhdGljJykge1xuICAgICAgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChvZmZzZXRQYXJlbnQpO1xuICAgIH1cblxuICAgIGlmIChvZmZzZXRQYXJlbnQgJiYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgPT09ICdodG1sJyB8fCBnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnYm9keScgJiYgZ2V0Q29tcHV0ZWRTdHlsZSQxKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnKSkge1xuICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICB9XG5cbiAgICByZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGdldENvbnRhaW5pbmdCbG9jayhlbGVtZW50KSB8fCB3aW5kb3c7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gICAgcmV0dXJuIFsndG9wJywgJ2JvdHRvbSddLmluZGV4T2YocGxhY2VtZW50KSA+PSAwID8gJ3gnIDogJ3knO1xuICB9XG5cbiAgZnVuY3Rpb24gd2l0aGluKG1pbiQxLCB2YWx1ZSwgbWF4JDEpIHtcbiAgICByZXR1cm4gbWF4KG1pbiQxLCBtaW4odmFsdWUsIG1heCQxKSk7XG4gIH1cbiAgZnVuY3Rpb24gd2l0aGluTWF4Q2xhbXAobWluLCB2YWx1ZSwgbWF4KSB7XG4gICAgdmFyIHYgPSB3aXRoaW4obWluLCB2YWx1ZSwgbWF4KTtcbiAgICByZXR1cm4gdiA+IG1heCA/IG1heCA6IHY7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRGcmVzaFNpZGVPYmplY3QoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRvcDogMCxcbiAgICAgIHJpZ2h0OiAwLFxuICAgICAgYm90dG9tOiAwLFxuICAgICAgbGVmdDogMFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBtZXJnZVBhZGRpbmdPYmplY3QocGFkZGluZ09iamVjdCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBnZXRGcmVzaFNpZGVPYmplY3QoKSwgcGFkZGluZ09iamVjdCk7XG4gIH1cblxuICBmdW5jdGlvbiBleHBhbmRUb0hhc2hNYXAodmFsdWUsIGtleXMpIHtcbiAgICByZXR1cm4ga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKGhhc2hNYXAsIGtleSkge1xuICAgICAgaGFzaE1hcFtrZXldID0gdmFsdWU7XG4gICAgICByZXR1cm4gaGFzaE1hcDtcbiAgICB9LCB7fSk7XG4gIH1cblxuICB2YXIgdG9QYWRkaW5nT2JqZWN0ID0gZnVuY3Rpb24gdG9QYWRkaW5nT2JqZWN0KHBhZGRpbmcsIHN0YXRlKSB7XG4gICAgcGFkZGluZyA9IHR5cGVvZiBwYWRkaW5nID09PSAnZnVuY3Rpb24nID8gcGFkZGluZyhPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5yZWN0cywge1xuICAgICAgcGxhY2VtZW50OiBzdGF0ZS5wbGFjZW1lbnRcbiAgICB9KSkgOiBwYWRkaW5nO1xuICAgIHJldHVybiBtZXJnZVBhZGRpbmdPYmplY3QodHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gcGFkZGluZyA6IGV4cGFuZFRvSGFzaE1hcChwYWRkaW5nLCBiYXNlUGxhY2VtZW50cykpO1xuICB9O1xuXG4gIGZ1bmN0aW9uIGFycm93KF9yZWYpIHtcbiAgICB2YXIgX3N0YXRlJG1vZGlmaWVyc0RhdGEkO1xuXG4gICAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgICAgbmFtZSA9IF9yZWYubmFtZSxcbiAgICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcbiAgICB2YXIgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3c7XG4gICAgdmFyIHBvcHBlck9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHM7XG4gICAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHN0YXRlLnBsYWNlbWVudCk7XG4gICAgdmFyIGF4aXMgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCk7XG4gICAgdmFyIGlzVmVydGljYWwgPSBbbGVmdCwgcmlnaHRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMDtcbiAgICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICAgIGlmICghYXJyb3dFbGVtZW50IHx8ICFwb3BwZXJPZmZzZXRzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBhZGRpbmdPYmplY3QgPSB0b1BhZGRpbmdPYmplY3Qob3B0aW9ucy5wYWRkaW5nLCBzdGF0ZSk7XG4gICAgdmFyIGFycm93UmVjdCA9IGdldExheW91dFJlY3QoYXJyb3dFbGVtZW50KTtcbiAgICB2YXIgbWluUHJvcCA9IGF4aXMgPT09ICd5JyA/IHRvcCA6IGxlZnQ7XG4gICAgdmFyIG1heFByb3AgPSBheGlzID09PSAneScgPyBib3R0b20gOiByaWdodDtcbiAgICB2YXIgZW5kRGlmZiA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtsZW5dICsgc3RhdGUucmVjdHMucmVmZXJlbmNlW2F4aXNdIC0gcG9wcGVyT2Zmc2V0c1theGlzXSAtIHN0YXRlLnJlY3RzLnBvcHBlcltsZW5dO1xuICAgIHZhciBzdGFydERpZmYgPSBwb3BwZXJPZmZzZXRzW2F4aXNdIC0gc3RhdGUucmVjdHMucmVmZXJlbmNlW2F4aXNdO1xuICAgIHZhciBhcnJvd09mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChhcnJvd0VsZW1lbnQpO1xuICAgIHZhciBjbGllbnRTaXplID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBheGlzID09PSAneScgPyBhcnJvd09mZnNldFBhcmVudC5jbGllbnRIZWlnaHQgfHwgMCA6IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudFdpZHRoIHx8IDAgOiAwO1xuICAgIHZhciBjZW50ZXJUb1JlZmVyZW5jZSA9IGVuZERpZmYgLyAyIC0gc3RhcnREaWZmIC8gMjsgLy8gTWFrZSBzdXJlIHRoZSBhcnJvdyBkb2Vzbid0IG92ZXJmbG93IHRoZSBwb3BwZXIgaWYgdGhlIGNlbnRlciBwb2ludCBpc1xuICAgIC8vIG91dHNpZGUgb2YgdGhlIHBvcHBlciBib3VuZHNcblxuICAgIHZhciBtaW4gPSBwYWRkaW5nT2JqZWN0W21pblByb3BdO1xuICAgIHZhciBtYXggPSBjbGllbnRTaXplIC0gYXJyb3dSZWN0W2xlbl0gLSBwYWRkaW5nT2JqZWN0W21heFByb3BdO1xuICAgIHZhciBjZW50ZXIgPSBjbGllbnRTaXplIC8gMiAtIGFycm93UmVjdFtsZW5dIC8gMiArIGNlbnRlclRvUmVmZXJlbmNlO1xuICAgIHZhciBvZmZzZXQgPSB3aXRoaW4obWluLCBjZW50ZXIsIG1heCk7IC8vIFByZXZlbnRzIGJyZWFraW5nIHN5bnRheCBoaWdobGlnaHRpbmcuLi5cblxuICAgIHZhciBheGlzUHJvcCA9IGF4aXM7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IChfc3RhdGUkbW9kaWZpZXJzRGF0YSQgPSB7fSwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkW2F4aXNQcm9wXSA9IG9mZnNldCwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkLmNlbnRlck9mZnNldCA9IG9mZnNldCAtIGNlbnRlciwgX3N0YXRlJG1vZGlmaWVyc0RhdGEkKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGVmZmVjdCQxKF9yZWYyKSB7XG4gICAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGUsXG4gICAgICAgIG9wdGlvbnMgPSBfcmVmMi5vcHRpb25zO1xuICAgIHZhciBfb3B0aW9ucyRlbGVtZW50ID0gb3B0aW9ucy5lbGVtZW50LFxuICAgICAgICBhcnJvd0VsZW1lbnQgPSBfb3B0aW9ucyRlbGVtZW50ID09PSB2b2lkIDAgPyAnW2RhdGEtcG9wcGVyLWFycm93XScgOiBfb3B0aW9ucyRlbGVtZW50O1xuXG4gICAgaWYgKGFycm93RWxlbWVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfSAvLyBDU1Mgc2VsZWN0b3JcblxuXG4gICAgaWYgKHR5cGVvZiBhcnJvd0VsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5wb3BwZXIucXVlcnlTZWxlY3RvcihhcnJvd0VsZW1lbnQpO1xuXG4gICAgICBpZiAoIWFycm93RWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFjb250YWlucyhzdGF0ZS5lbGVtZW50cy5wb3BwZXIsIGFycm93RWxlbWVudCkpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBzdGF0ZS5lbGVtZW50cy5hcnJvdyA9IGFycm93RWxlbWVudDtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuICBjb25zdCBhcnJvdyQxID0ge1xuICAgIG5hbWU6ICdhcnJvdycsXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBwaGFzZTogJ21haW4nLFxuICAgIGZuOiBhcnJvdyxcbiAgICBlZmZlY3Q6IGVmZmVjdCQxLFxuICAgIHJlcXVpcmVzOiBbJ3BvcHBlck9mZnNldHMnXSxcbiAgICByZXF1aXJlc0lmRXhpc3RzOiBbJ3ByZXZlbnRPdmVyZmxvdyddXG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkge1xuICAgIHJldHVybiBwbGFjZW1lbnQuc3BsaXQoJy0nKVsxXTtcbiAgfVxuXG4gIHZhciB1bnNldFNpZGVzID0ge1xuICAgIHRvcDogJ2F1dG8nLFxuICAgIHJpZ2h0OiAnYXV0bycsXG4gICAgYm90dG9tOiAnYXV0bycsXG4gICAgbGVmdDogJ2F1dG8nXG4gIH07IC8vIFJvdW5kIHRoZSBvZmZzZXRzIHRvIHRoZSBuZWFyZXN0IHN1aXRhYmxlIHN1YnBpeGVsIGJhc2VkIG9uIHRoZSBEUFIuXG4gIC8vIFpvb21pbmcgY2FuIGNoYW5nZSB0aGUgRFBSLCBidXQgaXQgc2VlbXMgdG8gcmVwb3J0IGEgdmFsdWUgdGhhdCB3aWxsXG4gIC8vIGNsZWFubHkgZGl2aWRlIHRoZSB2YWx1ZXMgaW50byB0aGUgYXBwcm9wcmlhdGUgc3VicGl4ZWxzLlxuXG4gIGZ1bmN0aW9uIHJvdW5kT2Zmc2V0c0J5RFBSKF9yZWYsIHdpbikge1xuICAgIHZhciB4ID0gX3JlZi54LFxuICAgICAgICB5ID0gX3JlZi55O1xuICAgIHZhciBkcHIgPSB3aW4uZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xuICAgIHJldHVybiB7XG4gICAgICB4OiByb3VuZCh4ICogZHByKSAvIGRwciB8fCAwLFxuICAgICAgeTogcm91bmQoeSAqIGRwcikgLyBkcHIgfHwgMFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBtYXBUb1N0eWxlcyhfcmVmMikge1xuICAgIHZhciBfT2JqZWN0JGFzc2lnbjI7XG5cbiAgICB2YXIgcG9wcGVyID0gX3JlZjIucG9wcGVyLFxuICAgICAgICBwb3BwZXJSZWN0ID0gX3JlZjIucG9wcGVyUmVjdCxcbiAgICAgICAgcGxhY2VtZW50ID0gX3JlZjIucGxhY2VtZW50LFxuICAgICAgICB2YXJpYXRpb24gPSBfcmVmMi52YXJpYXRpb24sXG4gICAgICAgIG9mZnNldHMgPSBfcmVmMi5vZmZzZXRzLFxuICAgICAgICBwb3NpdGlvbiA9IF9yZWYyLnBvc2l0aW9uLFxuICAgICAgICBncHVBY2NlbGVyYXRpb24gPSBfcmVmMi5ncHVBY2NlbGVyYXRpb24sXG4gICAgICAgIGFkYXB0aXZlID0gX3JlZjIuYWRhcHRpdmUsXG4gICAgICAgIHJvdW5kT2Zmc2V0cyA9IF9yZWYyLnJvdW5kT2Zmc2V0cyxcbiAgICAgICAgaXNGaXhlZCA9IF9yZWYyLmlzRml4ZWQ7XG4gICAgdmFyIF9vZmZzZXRzJHggPSBvZmZzZXRzLngsXG4gICAgICAgIHggPSBfb2Zmc2V0cyR4ID09PSB2b2lkIDAgPyAwIDogX29mZnNldHMkeCxcbiAgICAgICAgX29mZnNldHMkeSA9IG9mZnNldHMueSxcbiAgICAgICAgeSA9IF9vZmZzZXRzJHkgPT09IHZvaWQgMCA/IDAgOiBfb2Zmc2V0cyR5O1xuXG4gICAgdmFyIF9yZWYzID0gdHlwZW9mIHJvdW5kT2Zmc2V0cyA9PT0gJ2Z1bmN0aW9uJyA/IHJvdW5kT2Zmc2V0cyh7XG4gICAgICB4OiB4LFxuICAgICAgeTogeVxuICAgIH0pIDoge1xuICAgICAgeDogeCxcbiAgICAgIHk6IHlcbiAgICB9O1xuXG4gICAgeCA9IF9yZWYzLng7XG4gICAgeSA9IF9yZWYzLnk7XG4gICAgdmFyIGhhc1ggPSBvZmZzZXRzLmhhc093blByb3BlcnR5KCd4Jyk7XG4gICAgdmFyIGhhc1kgPSBvZmZzZXRzLmhhc093blByb3BlcnR5KCd5Jyk7XG4gICAgdmFyIHNpZGVYID0gbGVmdDtcbiAgICB2YXIgc2lkZVkgPSB0b3A7XG4gICAgdmFyIHdpbiA9IHdpbmRvdztcblxuICAgIGlmIChhZGFwdGl2ZSkge1xuICAgICAgdmFyIG9mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChwb3BwZXIpO1xuICAgICAgdmFyIGhlaWdodFByb3AgPSAnY2xpZW50SGVpZ2h0JztcbiAgICAgIHZhciB3aWR0aFByb3AgPSAnY2xpZW50V2lkdGgnO1xuXG4gICAgICBpZiAob2Zmc2V0UGFyZW50ID09PSBnZXRXaW5kb3cocG9wcGVyKSkge1xuICAgICAgICBvZmZzZXRQYXJlbnQgPSBnZXREb2N1bWVudEVsZW1lbnQocG9wcGVyKTtcblxuICAgICAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZSQxKG9mZnNldFBhcmVudCkucG9zaXRpb24gIT09ICdzdGF0aWMnICYmIHBvc2l0aW9uID09PSAnYWJzb2x1dGUnKSB7XG4gICAgICAgICAgaGVpZ2h0UHJvcCA9ICdzY3JvbGxIZWlnaHQnO1xuICAgICAgICAgIHdpZHRoUHJvcCA9ICdzY3JvbGxXaWR0aCc7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FzdF06IGZvcmNlIHR5cGUgcmVmaW5lbWVudCwgd2UgY29tcGFyZSBvZmZzZXRQYXJlbnQgd2l0aCB3aW5kb3cgYWJvdmUsIGJ1dCBGbG93IGRvZXNuJ3QgZGV0ZWN0IGl0XG5cblxuICAgICAgb2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50O1xuXG4gICAgICBpZiAocGxhY2VtZW50ID09PSB0b3AgfHwgKHBsYWNlbWVudCA9PT0gbGVmdCB8fCBwbGFjZW1lbnQgPT09IHJpZ2h0KSAmJiB2YXJpYXRpb24gPT09IGVuZCkge1xuICAgICAgICBzaWRlWSA9IGJvdHRvbTtcbiAgICAgICAgdmFyIG9mZnNldFkgPSBpc0ZpeGVkICYmIG9mZnNldFBhcmVudCA9PT0gd2luICYmIHdpbi52aXN1YWxWaWV3cG9ydCA/IHdpbi52aXN1YWxWaWV3cG9ydC5oZWlnaHQgOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cbiAgICAgICAgb2Zmc2V0UGFyZW50W2hlaWdodFByb3BdO1xuICAgICAgICB5IC09IG9mZnNldFkgLSBwb3BwZXJSZWN0LmhlaWdodDtcbiAgICAgICAgeSAqPSBncHVBY2NlbGVyYXRpb24gPyAxIDogLTE7XG4gICAgICB9XG5cbiAgICAgIGlmIChwbGFjZW1lbnQgPT09IGxlZnQgfHwgKHBsYWNlbWVudCA9PT0gdG9wIHx8IHBsYWNlbWVudCA9PT0gYm90dG9tKSAmJiB2YXJpYXRpb24gPT09IGVuZCkge1xuICAgICAgICBzaWRlWCA9IHJpZ2h0O1xuICAgICAgICB2YXIgb2Zmc2V0WCA9IGlzRml4ZWQgJiYgb2Zmc2V0UGFyZW50ID09PSB3aW4gJiYgd2luLnZpc3VhbFZpZXdwb3J0ID8gd2luLnZpc3VhbFZpZXdwb3J0LndpZHRoIDogLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG4gICAgICAgIG9mZnNldFBhcmVudFt3aWR0aFByb3BdO1xuICAgICAgICB4IC09IG9mZnNldFggLSBwb3BwZXJSZWN0LndpZHRoO1xuICAgICAgICB4ICo9IGdwdUFjY2VsZXJhdGlvbiA/IDEgOiAtMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgY29tbW9uU3R5bGVzID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICBwb3NpdGlvbjogcG9zaXRpb25cbiAgICB9LCBhZGFwdGl2ZSAmJiB1bnNldFNpZGVzKTtcblxuICAgIHZhciBfcmVmNCA9IHJvdW5kT2Zmc2V0cyA9PT0gdHJ1ZSA/IHJvdW5kT2Zmc2V0c0J5RFBSKHtcbiAgICAgIHg6IHgsXG4gICAgICB5OiB5XG4gICAgfSwgZ2V0V2luZG93KHBvcHBlcikpIDoge1xuICAgICAgeDogeCxcbiAgICAgIHk6IHlcbiAgICB9O1xuXG4gICAgeCA9IF9yZWY0Lng7XG4gICAgeSA9IF9yZWY0Lnk7XG5cbiAgICBpZiAoZ3B1QWNjZWxlcmF0aW9uKSB7XG4gICAgICB2YXIgX09iamVjdCRhc3NpZ247XG5cbiAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIChfT2JqZWN0JGFzc2lnbiA9IHt9LCBfT2JqZWN0JGFzc2lnbltzaWRlWV0gPSBoYXNZID8gJzAnIDogJycsIF9PYmplY3QkYXNzaWduW3NpZGVYXSA9IGhhc1ggPyAnMCcgOiAnJywgX09iamVjdCRhc3NpZ24udHJhbnNmb3JtID0gKHdpbi5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpIDw9IDEgPyBcInRyYW5zbGF0ZShcIiArIHggKyBcInB4LCBcIiArIHkgKyBcInB4KVwiIDogXCJ0cmFuc2xhdGUzZChcIiArIHggKyBcInB4LCBcIiArIHkgKyBcInB4LCAwKVwiLCBfT2JqZWN0JGFzc2lnbikpO1xuICAgIH1cblxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIChfT2JqZWN0JGFzc2lnbjIgPSB7fSwgX09iamVjdCRhc3NpZ24yW3NpZGVZXSA9IGhhc1kgPyB5ICsgXCJweFwiIDogJycsIF9PYmplY3QkYXNzaWduMltzaWRlWF0gPSBoYXNYID8geCArIFwicHhcIiA6ICcnLCBfT2JqZWN0JGFzc2lnbjIudHJhbnNmb3JtID0gJycsIF9PYmplY3QkYXNzaWduMikpO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcHV0ZVN0eWxlcyhfcmVmNSkge1xuICAgIHZhciBzdGF0ZSA9IF9yZWY1LnN0YXRlLFxuICAgICAgICBvcHRpb25zID0gX3JlZjUub3B0aW9ucztcbiAgICB2YXIgX29wdGlvbnMkZ3B1QWNjZWxlcmF0ID0gb3B0aW9ucy5ncHVBY2NlbGVyYXRpb24sXG4gICAgICAgIGdwdUFjY2VsZXJhdGlvbiA9IF9vcHRpb25zJGdwdUFjY2VsZXJhdCA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGdwdUFjY2VsZXJhdCxcbiAgICAgICAgX29wdGlvbnMkYWRhcHRpdmUgPSBvcHRpb25zLmFkYXB0aXZlLFxuICAgICAgICBhZGFwdGl2ZSA9IF9vcHRpb25zJGFkYXB0aXZlID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkYWRhcHRpdmUsXG4gICAgICAgIF9vcHRpb25zJHJvdW5kT2Zmc2V0cyA9IG9wdGlvbnMucm91bmRPZmZzZXRzLFxuICAgICAgICByb3VuZE9mZnNldHMgPSBfb3B0aW9ucyRyb3VuZE9mZnNldHMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRyb3VuZE9mZnNldHM7XG4gICAgdmFyIGNvbW1vblN0eWxlcyA9IHtcbiAgICAgIHBsYWNlbWVudDogZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpLFxuICAgICAgdmFyaWF0aW9uOiBnZXRWYXJpYXRpb24oc3RhdGUucGxhY2VtZW50KSxcbiAgICAgIHBvcHBlcjogc3RhdGUuZWxlbWVudHMucG9wcGVyLFxuICAgICAgcG9wcGVyUmVjdDogc3RhdGUucmVjdHMucG9wcGVyLFxuICAgICAgZ3B1QWNjZWxlcmF0aW9uOiBncHVBY2NlbGVyYXRpb24sXG4gICAgICBpc0ZpeGVkOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5ID09PSAnZml4ZWQnXG4gICAgfTtcblxuICAgIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCkge1xuICAgICAgc3RhdGUuc3R5bGVzLnBvcHBlciA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnN0eWxlcy5wb3BwZXIsIG1hcFRvU3R5bGVzKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywge1xuICAgICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMsXG4gICAgICAgIHBvc2l0aW9uOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5LFxuICAgICAgICBhZGFwdGl2ZTogYWRhcHRpdmUsXG4gICAgICAgIHJvdW5kT2Zmc2V0czogcm91bmRPZmZzZXRzXG4gICAgICB9KSkpO1xuICAgIH1cblxuICAgIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLmFycm93ICE9IG51bGwpIHtcbiAgICAgIHN0YXRlLnN0eWxlcy5hcnJvdyA9IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnN0eWxlcy5hcnJvdywgbWFwVG9TdHlsZXMoT2JqZWN0LmFzc2lnbih7fSwgY29tbW9uU3R5bGVzLCB7XG4gICAgICAgIG9mZnNldHM6IHN0YXRlLm1vZGlmaWVyc0RhdGEuYXJyb3csXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnLFxuICAgICAgICBhZGFwdGl2ZTogZmFsc2UsXG4gICAgICAgIHJvdW5kT2Zmc2V0czogcm91bmRPZmZzZXRzXG4gICAgICB9KSkpO1xuICAgIH1cblxuICAgIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIsIHtcbiAgICAgICdkYXRhLXBvcHBlci1wbGFjZW1lbnQnOiBzdGF0ZS5wbGFjZW1lbnRcbiAgICB9KTtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuICBjb25zdCBjb21wdXRlU3R5bGVzJDEgPSB7XG4gICAgbmFtZTogJ2NvbXB1dGVTdHlsZXMnLFxuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgcGhhc2U6ICdiZWZvcmVXcml0ZScsXG4gICAgZm46IGNvbXB1dGVTdHlsZXMsXG4gICAgZGF0YToge31cbiAgfTtcblxuICB2YXIgcGFzc2l2ZSA9IHtcbiAgICBwYXNzaXZlOiB0cnVlXG4gIH07XG5cbiAgZnVuY3Rpb24gZWZmZWN0KF9yZWYpIHtcbiAgICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgICBpbnN0YW5jZSA9IF9yZWYuaW5zdGFuY2UsXG4gICAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnM7XG4gICAgdmFyIF9vcHRpb25zJHNjcm9sbCA9IG9wdGlvbnMuc2Nyb2xsLFxuICAgICAgICBzY3JvbGwgPSBfb3B0aW9ucyRzY3JvbGwgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRzY3JvbGwsXG4gICAgICAgIF9vcHRpb25zJHJlc2l6ZSA9IG9wdGlvbnMucmVzaXplLFxuICAgICAgICByZXNpemUgPSBfb3B0aW9ucyRyZXNpemUgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRyZXNpemU7XG4gICAgdmFyIHdpbmRvdyA9IGdldFdpbmRvdyhzdGF0ZS5lbGVtZW50cy5wb3BwZXIpO1xuICAgIHZhciBzY3JvbGxQYXJlbnRzID0gW10uY29uY2F0KHN0YXRlLnNjcm9sbFBhcmVudHMucmVmZXJlbmNlLCBzdGF0ZS5zY3JvbGxQYXJlbnRzLnBvcHBlcik7XG5cbiAgICBpZiAoc2Nyb2xsKSB7XG4gICAgICBzY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHNjcm9sbFBhcmVudCkge1xuICAgICAgICBzY3JvbGxQYXJlbnQuYWRkRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmIChyZXNpemUpIHtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoc2Nyb2xsKSB7XG4gICAgICAgIHNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAoc2Nyb2xsUGFyZW50KSB7XG4gICAgICAgICAgc2Nyb2xsUGFyZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVzaXplKSB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xuICAgICAgfVxuICAgIH07XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbiAgY29uc3QgZXZlbnRMaXN0ZW5lcnMgPSB7XG4gICAgbmFtZTogJ2V2ZW50TGlzdGVuZXJzJyxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIHBoYXNlOiAnd3JpdGUnLFxuICAgIGZuOiBmdW5jdGlvbiBmbigpIHt9LFxuICAgIGVmZmVjdDogZWZmZWN0LFxuICAgIGRhdGE6IHt9XG4gIH07XG5cbiAgdmFyIGhhc2gkMSA9IHtcbiAgICBsZWZ0OiAncmlnaHQnLFxuICAgIHJpZ2h0OiAnbGVmdCcsXG4gICAgYm90dG9tOiAndG9wJyxcbiAgICB0b3A6ICdib3R0b20nXG4gIH07XG4gIGZ1bmN0aW9uIGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCkge1xuICAgIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvbGVmdHxyaWdodHxib3R0b218dG9wL2csIGZ1bmN0aW9uIChtYXRjaGVkKSB7XG4gICAgICByZXR1cm4gaGFzaCQxW21hdGNoZWRdO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIGhhc2ggPSB7XG4gICAgc3RhcnQ6ICdlbmQnLFxuICAgIGVuZDogJ3N0YXJ0J1xuICB9O1xuICBmdW5jdGlvbiBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgICByZXR1cm4gcGxhY2VtZW50LnJlcGxhY2UoL3N0YXJ0fGVuZC9nLCBmdW5jdGlvbiAobWF0Y2hlZCkge1xuICAgICAgcmV0dXJuIGhhc2hbbWF0Y2hlZF07XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGwobm9kZSkge1xuICAgIHZhciB3aW4gPSBnZXRXaW5kb3cobm9kZSk7XG4gICAgdmFyIHNjcm9sbExlZnQgPSB3aW4ucGFnZVhPZmZzZXQ7XG4gICAgdmFyIHNjcm9sbFRvcCA9IHdpbi5wYWdlWU9mZnNldDtcbiAgICByZXR1cm4ge1xuICAgICAgc2Nyb2xsTGVmdDogc2Nyb2xsTGVmdCxcbiAgICAgIHNjcm9sbFRvcDogc2Nyb2xsVG9wXG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCkge1xuICAgIC8vIElmIDxodG1sPiBoYXMgYSBDU1Mgd2lkdGggZ3JlYXRlciB0aGFuIHRoZSB2aWV3cG9ydCwgdGhlbiB0aGlzIHdpbGwgYmVcbiAgICAvLyBpbmNvcnJlY3QgZm9yIFJUTC5cbiAgICAvLyBQb3BwZXIgMSBpcyBicm9rZW4gaW4gdGhpcyBjYXNlIGFuZCBuZXZlciBoYWQgYSBidWcgcmVwb3J0IHNvIGxldCdzIGFzc3VtZVxuICAgIC8vIGl0J3Mgbm90IGFuIGlzc3VlLiBJIGRvbid0IHRoaW5rIGFueW9uZSBldmVyIHNwZWNpZmllcyB3aWR0aCBvbiA8aHRtbD5cbiAgICAvLyBhbnl3YXkuXG4gICAgLy8gQnJvd3NlcnMgd2hlcmUgdGhlIGxlZnQgc2Nyb2xsYmFyIGRvZXNuJ3QgY2F1c2UgYW4gaXNzdWUgcmVwb3J0IGAwYCBmb3JcbiAgICAvLyB0aGlzIChlLmcuIEVkZ2UgMjAxOSwgSUUxMSwgU2FmYXJpKVxuICAgIHJldHVybiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpKS5sZWZ0ICsgZ2V0V2luZG93U2Nyb2xsKGVsZW1lbnQpLnNjcm9sbExlZnQ7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRWaWV3cG9ydFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpIHtcbiAgICB2YXIgd2luID0gZ2V0V2luZG93KGVsZW1lbnQpO1xuICAgIHZhciBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xuICAgIHZhciB2aXN1YWxWaWV3cG9ydCA9IHdpbi52aXN1YWxWaWV3cG9ydDtcbiAgICB2YXIgd2lkdGggPSBodG1sLmNsaWVudFdpZHRoO1xuICAgIHZhciBoZWlnaHQgPSBodG1sLmNsaWVudEhlaWdodDtcbiAgICB2YXIgeCA9IDA7XG4gICAgdmFyIHkgPSAwO1xuXG4gICAgaWYgKHZpc3VhbFZpZXdwb3J0KSB7XG4gICAgICB3aWR0aCA9IHZpc3VhbFZpZXdwb3J0LndpZHRoO1xuICAgICAgaGVpZ2h0ID0gdmlzdWFsVmlld3BvcnQuaGVpZ2h0O1xuICAgICAgdmFyIGxheW91dFZpZXdwb3J0ID0gaXNMYXlvdXRWaWV3cG9ydCgpO1xuXG4gICAgICBpZiAobGF5b3V0Vmlld3BvcnQgfHwgIWxheW91dFZpZXdwb3J0ICYmIHN0cmF0ZWd5ID09PSAnZml4ZWQnKSB7XG4gICAgICAgIHggPSB2aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0O1xuICAgICAgICB5ID0gdmlzdWFsVmlld3BvcnQub2Zmc2V0VG9wO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogd2lkdGgsXG4gICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgIHg6IHggKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpLFxuICAgICAgeTogeVxuICAgIH07XG4gIH1cblxuICAvLyBvZiB0aGUgYDxodG1sPmAgYW5kIGA8Ym9keT5gIHJlY3QgYm91bmRzIGlmIGhvcml6b250YWxseSBzY3JvbGxhYmxlXG5cbiAgZnVuY3Rpb24gZ2V0RG9jdW1lbnRSZWN0KGVsZW1lbnQpIHtcbiAgICB2YXIgX2VsZW1lbnQkb3duZXJEb2N1bWVuO1xuXG4gICAgdmFyIGh0bWwgPSBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCk7XG4gICAgdmFyIHdpblNjcm9sbCA9IGdldFdpbmRvd1Njcm9sbChlbGVtZW50KTtcbiAgICB2YXIgYm9keSA9IChfZWxlbWVudCRvd25lckRvY3VtZW4gPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZWxlbWVudCRvd25lckRvY3VtZW4uYm9keTtcbiAgICB2YXIgd2lkdGggPSBtYXgoaHRtbC5zY3JvbGxXaWR0aCwgaHRtbC5jbGllbnRXaWR0aCwgYm9keSA/IGJvZHkuc2Nyb2xsV2lkdGggOiAwLCBib2R5ID8gYm9keS5jbGllbnRXaWR0aCA6IDApO1xuICAgIHZhciBoZWlnaHQgPSBtYXgoaHRtbC5zY3JvbGxIZWlnaHQsIGh0bWwuY2xpZW50SGVpZ2h0LCBib2R5ID8gYm9keS5zY3JvbGxIZWlnaHQgOiAwLCBib2R5ID8gYm9keS5jbGllbnRIZWlnaHQgOiAwKTtcbiAgICB2YXIgeCA9IC13aW5TY3JvbGwuc2Nyb2xsTGVmdCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCk7XG4gICAgdmFyIHkgPSAtd2luU2Nyb2xsLnNjcm9sbFRvcDtcblxuICAgIGlmIChnZXRDb21wdXRlZFN0eWxlJDEoYm9keSB8fCBodG1sKS5kaXJlY3Rpb24gPT09ICdydGwnKSB7XG4gICAgICB4ICs9IG1heChodG1sLmNsaWVudFdpZHRoLCBib2R5ID8gYm9keS5jbGllbnRXaWR0aCA6IDApIC0gd2lkdGg7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgeDogeCxcbiAgICAgIHk6IHlcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gaXNTY3JvbGxQYXJlbnQoZWxlbWVudCkge1xuICAgIC8vIEZpcmVmb3ggd2FudHMgdXMgdG8gY2hlY2sgYC14YCBhbmQgYC15YCB2YXJpYXRpb25zIGFzIHdlbGxcbiAgICB2YXIgX2dldENvbXB1dGVkU3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlJDEoZWxlbWVudCksXG4gICAgICAgIG92ZXJmbG93ID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3csXG4gICAgICAgIG92ZXJmbG93WCA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93WCxcbiAgICAgICAgb3ZlcmZsb3dZID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dZO1xuXG4gICAgcmV0dXJuIC9hdXRvfHNjcm9sbHxvdmVybGF5fGhpZGRlbi8udGVzdChvdmVyZmxvdyArIG92ZXJmbG93WSArIG92ZXJmbG93WCk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRTY3JvbGxQYXJlbnQobm9kZSkge1xuICAgIGlmIChbJ2h0bWwnLCAnYm9keScsICcjZG9jdW1lbnQnXS5pbmRleE9mKGdldE5vZGVOYW1lKG5vZGUpKSA+PSAwKSB7XG4gICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBhc3N1bWUgYm9keSBpcyBhbHdheXMgYXZhaWxhYmxlXG4gICAgICByZXR1cm4gbm9kZS5vd25lckRvY3VtZW50LmJvZHk7XG4gICAgfVxuXG4gICAgaWYgKGlzSFRNTEVsZW1lbnQobm9kZSkgJiYgaXNTY3JvbGxQYXJlbnQobm9kZSkpIHtcbiAgICAgIHJldHVybiBub2RlO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRTY3JvbGxQYXJlbnQoZ2V0UGFyZW50Tm9kZShub2RlKSk7XG4gIH1cblxuICAvKlxuICBnaXZlbiBhIERPTSBlbGVtZW50LCByZXR1cm4gdGhlIGxpc3Qgb2YgYWxsIHNjcm9sbCBwYXJlbnRzLCB1cCB0aGUgbGlzdCBvZiBhbmNlc29yc1xuICB1bnRpbCB3ZSBnZXQgdG8gdGhlIHRvcCB3aW5kb3cgb2JqZWN0LiBUaGlzIGxpc3QgaXMgd2hhdCB3ZSBhdHRhY2ggc2Nyb2xsIGxpc3RlbmVyc1xuICB0bywgYmVjYXVzZSBpZiBhbnkgb2YgdGhlc2UgcGFyZW50IGVsZW1lbnRzIHNjcm9sbCwgd2UnbGwgbmVlZCB0byByZS1jYWxjdWxhdGUgdGhlXG4gIHJlZmVyZW5jZSBlbGVtZW50J3MgcG9zaXRpb24uXG4gICovXG5cbiAgZnVuY3Rpb24gbGlzdFNjcm9sbFBhcmVudHMoZWxlbWVudCwgbGlzdCkge1xuICAgIHZhciBfZWxlbWVudCRvd25lckRvY3VtZW47XG5cbiAgICBpZiAobGlzdCA9PT0gdm9pZCAwKSB7XG4gICAgICBsaXN0ID0gW107XG4gICAgfVxuXG4gICAgdmFyIHNjcm9sbFBhcmVudCA9IGdldFNjcm9sbFBhcmVudChlbGVtZW50KTtcbiAgICB2YXIgaXNCb2R5ID0gc2Nyb2xsUGFyZW50ID09PSAoKF9lbGVtZW50JG93bmVyRG9jdW1lbiA9IGVsZW1lbnQub3duZXJEb2N1bWVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lbGVtZW50JG93bmVyRG9jdW1lbi5ib2R5KTtcbiAgICB2YXIgd2luID0gZ2V0V2luZG93KHNjcm9sbFBhcmVudCk7XG4gICAgdmFyIHRhcmdldCA9IGlzQm9keSA/IFt3aW5dLmNvbmNhdCh3aW4udmlzdWFsVmlld3BvcnQgfHwgW10sIGlzU2Nyb2xsUGFyZW50KHNjcm9sbFBhcmVudCkgPyBzY3JvbGxQYXJlbnQgOiBbXSkgOiBzY3JvbGxQYXJlbnQ7XG4gICAgdmFyIHVwZGF0ZWRMaXN0ID0gbGlzdC5jb25jYXQodGFyZ2V0KTtcbiAgICByZXR1cm4gaXNCb2R5ID8gdXBkYXRlZExpc3QgOiAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogaXNCb2R5IHRlbGxzIHVzIHRhcmdldCB3aWxsIGJlIGFuIEhUTUxFbGVtZW50IGhlcmVcbiAgICB1cGRhdGVkTGlzdC5jb25jYXQobGlzdFNjcm9sbFBhcmVudHMoZ2V0UGFyZW50Tm9kZSh0YXJnZXQpKSk7XG4gIH1cblxuICBmdW5jdGlvbiByZWN0VG9DbGllbnRSZWN0KHJlY3QpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgcmVjdCwge1xuICAgICAgbGVmdDogcmVjdC54LFxuICAgICAgdG9wOiByZWN0LnksXG4gICAgICByaWdodDogcmVjdC54ICsgcmVjdC53aWR0aCxcbiAgICAgIGJvdHRvbTogcmVjdC55ICsgcmVjdC5oZWlnaHRcbiAgICB9KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIHN0cmF0ZWd5KSB7XG4gICAgdmFyIHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgZmFsc2UsIHN0cmF0ZWd5ID09PSAnZml4ZWQnKTtcbiAgICByZWN0LnRvcCA9IHJlY3QudG9wICsgZWxlbWVudC5jbGllbnRUb3A7XG4gICAgcmVjdC5sZWZ0ID0gcmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRMZWZ0O1xuICAgIHJlY3QuYm90dG9tID0gcmVjdC50b3AgKyBlbGVtZW50LmNsaWVudEhlaWdodDtcbiAgICByZWN0LnJpZ2h0ID0gcmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICByZWN0LndpZHRoID0gZWxlbWVudC5jbGllbnRXaWR0aDtcbiAgICByZWN0LmhlaWdodCA9IGVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgIHJlY3QueCA9IHJlY3QubGVmdDtcbiAgICByZWN0LnkgPSByZWN0LnRvcDtcbiAgICByZXR1cm4gcmVjdDtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGNsaXBwaW5nUGFyZW50LCBzdHJhdGVneSkge1xuICAgIHJldHVybiBjbGlwcGluZ1BhcmVudCA9PT0gdmlld3BvcnQgPyByZWN0VG9DbGllbnRSZWN0KGdldFZpZXdwb3J0UmVjdChlbGVtZW50LCBzdHJhdGVneSkpIDogaXNFbGVtZW50KGNsaXBwaW5nUGFyZW50KSA/IGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGNsaXBwaW5nUGFyZW50LCBzdHJhdGVneSkgOiByZWN0VG9DbGllbnRSZWN0KGdldERvY3VtZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpKTtcbiAgfSAvLyBBIFwiY2xpcHBpbmcgcGFyZW50XCIgaXMgYW4gb3ZlcmZsb3dhYmxlIGNvbnRhaW5lciB3aXRoIHRoZSBjaGFyYWN0ZXJpc3RpYyBvZlxuICAvLyBjbGlwcGluZyAob3IgaGlkaW5nKSBvdmVyZmxvd2luZyBlbGVtZW50cyB3aXRoIGEgcG9zaXRpb24gZGlmZmVyZW50IGZyb21cbiAgLy8gYGluaXRpYWxgXG5cblxuICBmdW5jdGlvbiBnZXRDbGlwcGluZ1BhcmVudHMoZWxlbWVudCkge1xuICAgIHZhciBjbGlwcGluZ1BhcmVudHMgPSBsaXN0U2Nyb2xsUGFyZW50cyhnZXRQYXJlbnROb2RlKGVsZW1lbnQpKTtcbiAgICB2YXIgY2FuRXNjYXBlQ2xpcHBpbmcgPSBbJ2Fic29sdXRlJywgJ2ZpeGVkJ10uaW5kZXhPZihnZXRDb21wdXRlZFN0eWxlJDEoZWxlbWVudCkucG9zaXRpb24pID49IDA7XG4gICAgdmFyIGNsaXBwZXJFbGVtZW50ID0gY2FuRXNjYXBlQ2xpcHBpbmcgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSA/IGdldE9mZnNldFBhcmVudChlbGVtZW50KSA6IGVsZW1lbnQ7XG5cbiAgICBpZiAoIWlzRWxlbWVudChjbGlwcGVyRWxlbWVudCkpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl06IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9mbG93L2lzc3Vlcy8xNDE0XG5cblxuICAgIHJldHVybiBjbGlwcGluZ1BhcmVudHMuZmlsdGVyKGZ1bmN0aW9uIChjbGlwcGluZ1BhcmVudCkge1xuICAgICAgcmV0dXJuIGlzRWxlbWVudChjbGlwcGluZ1BhcmVudCkgJiYgY29udGFpbnMoY2xpcHBpbmdQYXJlbnQsIGNsaXBwZXJFbGVtZW50KSAmJiBnZXROb2RlTmFtZShjbGlwcGluZ1BhcmVudCkgIT09ICdib2R5JztcbiAgICB9KTtcbiAgfSAvLyBHZXRzIHRoZSBtYXhpbXVtIGFyZWEgdGhhdCB0aGUgZWxlbWVudCBpcyB2aXNpYmxlIGluIGR1ZSB0byBhbnkgbnVtYmVyIG9mXG4gIC8vIGNsaXBwaW5nIHBhcmVudHNcblxuXG4gIGZ1bmN0aW9uIGdldENsaXBwaW5nUmVjdChlbGVtZW50LCBib3VuZGFyeSwgcm9vdEJvdW5kYXJ5LCBzdHJhdGVneSkge1xuICAgIHZhciBtYWluQ2xpcHBpbmdQYXJlbnRzID0gYm91bmRhcnkgPT09ICdjbGlwcGluZ1BhcmVudHMnID8gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsZW1lbnQpIDogW10uY29uY2F0KGJvdW5kYXJ5KTtcbiAgICB2YXIgY2xpcHBpbmdQYXJlbnRzID0gW10uY29uY2F0KG1haW5DbGlwcGluZ1BhcmVudHMsIFtyb290Qm91bmRhcnldKTtcbiAgICB2YXIgZmlyc3RDbGlwcGluZ1BhcmVudCA9IGNsaXBwaW5nUGFyZW50c1swXTtcbiAgICB2YXIgY2xpcHBpbmdSZWN0ID0gY2xpcHBpbmdQYXJlbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjUmVjdCwgY2xpcHBpbmdQYXJlbnQpIHtcbiAgICAgIHZhciByZWN0ID0gZ2V0Q2xpZW50UmVjdEZyb21NaXhlZFR5cGUoZWxlbWVudCwgY2xpcHBpbmdQYXJlbnQsIHN0cmF0ZWd5KTtcbiAgICAgIGFjY1JlY3QudG9wID0gbWF4KHJlY3QudG9wLCBhY2NSZWN0LnRvcCk7XG4gICAgICBhY2NSZWN0LnJpZ2h0ID0gbWluKHJlY3QucmlnaHQsIGFjY1JlY3QucmlnaHQpO1xuICAgICAgYWNjUmVjdC5ib3R0b20gPSBtaW4ocmVjdC5ib3R0b20sIGFjY1JlY3QuYm90dG9tKTtcbiAgICAgIGFjY1JlY3QubGVmdCA9IG1heChyZWN0LmxlZnQsIGFjY1JlY3QubGVmdCk7XG4gICAgICByZXR1cm4gYWNjUmVjdDtcbiAgICB9LCBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBmaXJzdENsaXBwaW5nUGFyZW50LCBzdHJhdGVneSkpO1xuICAgIGNsaXBwaW5nUmVjdC53aWR0aCA9IGNsaXBwaW5nUmVjdC5yaWdodCAtIGNsaXBwaW5nUmVjdC5sZWZ0O1xuICAgIGNsaXBwaW5nUmVjdC5oZWlnaHQgPSBjbGlwcGluZ1JlY3QuYm90dG9tIC0gY2xpcHBpbmdSZWN0LnRvcDtcbiAgICBjbGlwcGluZ1JlY3QueCA9IGNsaXBwaW5nUmVjdC5sZWZ0O1xuICAgIGNsaXBwaW5nUmVjdC55ID0gY2xpcHBpbmdSZWN0LnRvcDtcbiAgICByZXR1cm4gY2xpcHBpbmdSZWN0O1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcHV0ZU9mZnNldHMoX3JlZikge1xuICAgIHZhciByZWZlcmVuY2UgPSBfcmVmLnJlZmVyZW5jZSxcbiAgICAgICAgZWxlbWVudCA9IF9yZWYuZWxlbWVudCxcbiAgICAgICAgcGxhY2VtZW50ID0gX3JlZi5wbGFjZW1lbnQ7XG4gICAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQgPyBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgOiBudWxsO1xuICAgIHZhciB2YXJpYXRpb24gPSBwbGFjZW1lbnQgPyBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA6IG51bGw7XG4gICAgdmFyIGNvbW1vblggPSByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCAvIDIgLSBlbGVtZW50LndpZHRoIC8gMjtcbiAgICB2YXIgY29tbW9uWSA9IHJlZmVyZW5jZS55ICsgcmVmZXJlbmNlLmhlaWdodCAvIDIgLSBlbGVtZW50LmhlaWdodCAvIDI7XG4gICAgdmFyIG9mZnNldHM7XG5cbiAgICBzd2l0Y2ggKGJhc2VQbGFjZW1lbnQpIHtcbiAgICAgIGNhc2UgdG9wOlxuICAgICAgICBvZmZzZXRzID0ge1xuICAgICAgICAgIHg6IGNvbW1vblgsXG4gICAgICAgICAgeTogcmVmZXJlbmNlLnkgLSBlbGVtZW50LmhlaWdodFxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBib3R0b206XG4gICAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgICAgeDogY29tbW9uWCxcbiAgICAgICAgICB5OiByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHRcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgcmlnaHQ6XG4gICAgICAgIG9mZnNldHMgPSB7XG4gICAgICAgICAgeDogcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGgsXG4gICAgICAgICAgeTogY29tbW9uWVxuICAgICAgICB9O1xuICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSBsZWZ0OlxuICAgICAgICBvZmZzZXRzID0ge1xuICAgICAgICAgIHg6IHJlZmVyZW5jZS54IC0gZWxlbWVudC53aWR0aCxcbiAgICAgICAgICB5OiBjb21tb25ZXG4gICAgICAgIH07XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBvZmZzZXRzID0ge1xuICAgICAgICAgIHg6IHJlZmVyZW5jZS54LFxuICAgICAgICAgIHk6IHJlZmVyZW5jZS55XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIG1haW5BeGlzID0gYmFzZVBsYWNlbWVudCA/IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KSA6IG51bGw7XG5cbiAgICBpZiAobWFpbkF4aXMgIT0gbnVsbCkge1xuICAgICAgdmFyIGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG5cbiAgICAgIHN3aXRjaCAodmFyaWF0aW9uKSB7XG4gICAgICAgIGNhc2Ugc3RhcnQ6XG4gICAgICAgICAgb2Zmc2V0c1ttYWluQXhpc10gPSBvZmZzZXRzW21haW5BeGlzXSAtIChyZWZlcmVuY2VbbGVuXSAvIDIgLSBlbGVtZW50W2xlbl0gLyAyKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIGVuZDpcbiAgICAgICAgICBvZmZzZXRzW21haW5BeGlzXSA9IG9mZnNldHNbbWFpbkF4aXNdICsgKHJlZmVyZW5jZVtsZW5dIC8gMiAtIGVsZW1lbnRbbGVuXSAvIDIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBvZmZzZXRzO1xuICB9XG5cbiAgZnVuY3Rpb24gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgICAgX29wdGlvbnMkcGxhY2VtZW50ID0gX29wdGlvbnMucGxhY2VtZW50LFxuICAgICAgICBwbGFjZW1lbnQgPSBfb3B0aW9ucyRwbGFjZW1lbnQgPT09IHZvaWQgMCA/IHN0YXRlLnBsYWNlbWVudCA6IF9vcHRpb25zJHBsYWNlbWVudCxcbiAgICAgICAgX29wdGlvbnMkc3RyYXRlZ3kgPSBfb3B0aW9ucy5zdHJhdGVneSxcbiAgICAgICAgc3RyYXRlZ3kgPSBfb3B0aW9ucyRzdHJhdGVneSA9PT0gdm9pZCAwID8gc3RhdGUuc3RyYXRlZ3kgOiBfb3B0aW9ucyRzdHJhdGVneSxcbiAgICAgICAgX29wdGlvbnMkYm91bmRhcnkgPSBfb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgICAgYm91bmRhcnkgPSBfb3B0aW9ucyRib3VuZGFyeSA9PT0gdm9pZCAwID8gY2xpcHBpbmdQYXJlbnRzIDogX29wdGlvbnMkYm91bmRhcnksXG4gICAgICAgIF9vcHRpb25zJHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgICAgcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMkcm9vdEJvdW5kYXJ5ID09PSB2b2lkIDAgPyB2aWV3cG9ydCA6IF9vcHRpb25zJHJvb3RCb3VuZGFyeSxcbiAgICAgICAgX29wdGlvbnMkZWxlbWVudENvbnRlID0gX29wdGlvbnMuZWxlbWVudENvbnRleHQsXG4gICAgICAgIGVsZW1lbnRDb250ZXh0ID0gX29wdGlvbnMkZWxlbWVudENvbnRlID09PSB2b2lkIDAgPyBwb3BwZXIgOiBfb3B0aW9ucyRlbGVtZW50Q29udGUsXG4gICAgICAgIF9vcHRpb25zJGFsdEJvdW5kYXJ5ID0gX29wdGlvbnMuYWx0Qm91bmRhcnksXG4gICAgICAgIGFsdEJvdW5kYXJ5ID0gX29wdGlvbnMkYWx0Qm91bmRhcnkgPT09IHZvaWQgMCA/IGZhbHNlIDogX29wdGlvbnMkYWx0Qm91bmRhcnksXG4gICAgICAgIF9vcHRpb25zJHBhZGRpbmcgPSBfb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgICBwYWRkaW5nID0gX29wdGlvbnMkcGFkZGluZyA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJHBhZGRpbmc7XG4gICAgdmFyIHBhZGRpbmdPYmplY3QgPSBtZXJnZVBhZGRpbmdPYmplY3QodHlwZW9mIHBhZGRpbmcgIT09ICdudW1iZXInID8gcGFkZGluZyA6IGV4cGFuZFRvSGFzaE1hcChwYWRkaW5nLCBiYXNlUGxhY2VtZW50cykpO1xuICAgIHZhciBhbHRDb250ZXh0ID0gZWxlbWVudENvbnRleHQgPT09IHBvcHBlciA/IHJlZmVyZW5jZSA6IHBvcHBlcjtcbiAgICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcbiAgICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW2FsdEJvdW5kYXJ5ID8gYWx0Q29udGV4dCA6IGVsZW1lbnRDb250ZXh0XTtcbiAgICB2YXIgY2xpcHBpbmdDbGllbnRSZWN0ID0gZ2V0Q2xpcHBpbmdSZWN0KGlzRWxlbWVudChlbGVtZW50KSA/IGVsZW1lbnQgOiBlbGVtZW50LmNvbnRleHRFbGVtZW50IHx8IGdldERvY3VtZW50RWxlbWVudChzdGF0ZS5lbGVtZW50cy5wb3BwZXIpLCBib3VuZGFyeSwgcm9vdEJvdW5kYXJ5LCBzdHJhdGVneSk7XG4gICAgdmFyIHJlZmVyZW5jZUNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qoc3RhdGUuZWxlbWVudHMucmVmZXJlbmNlKTtcbiAgICB2YXIgcG9wcGVyT2Zmc2V0cyA9IGNvbXB1dGVPZmZzZXRzKHtcbiAgICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlQ2xpZW50UmVjdCxcbiAgICAgIGVsZW1lbnQ6IHBvcHBlclJlY3QsXG4gICAgICBzdHJhdGVneTogJ2Fic29sdXRlJyxcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50XG4gICAgfSk7XG4gICAgdmFyIHBvcHBlckNsaWVudFJlY3QgPSByZWN0VG9DbGllbnRSZWN0KE9iamVjdC5hc3NpZ24oe30sIHBvcHBlclJlY3QsIHBvcHBlck9mZnNldHMpKTtcbiAgICB2YXIgZWxlbWVudENsaWVudFJlY3QgPSBlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyID8gcG9wcGVyQ2xpZW50UmVjdCA6IHJlZmVyZW5jZUNsaWVudFJlY3Q7IC8vIHBvc2l0aXZlID0gb3ZlcmZsb3dpbmcgdGhlIGNsaXBwaW5nIHJlY3RcbiAgICAvLyAwIG9yIG5lZ2F0aXZlID0gd2l0aGluIHRoZSBjbGlwcGluZyByZWN0XG5cbiAgICB2YXIgb3ZlcmZsb3dPZmZzZXRzID0ge1xuICAgICAgdG9wOiBjbGlwcGluZ0NsaWVudFJlY3QudG9wIC0gZWxlbWVudENsaWVudFJlY3QudG9wICsgcGFkZGluZ09iamVjdC50b3AsXG4gICAgICBib3R0b206IGVsZW1lbnRDbGllbnRSZWN0LmJvdHRvbSAtIGNsaXBwaW5nQ2xpZW50UmVjdC5ib3R0b20gKyBwYWRkaW5nT2JqZWN0LmJvdHRvbSxcbiAgICAgIGxlZnQ6IGNsaXBwaW5nQ2xpZW50UmVjdC5sZWZ0IC0gZWxlbWVudENsaWVudFJlY3QubGVmdCArIHBhZGRpbmdPYmplY3QubGVmdCxcbiAgICAgIHJpZ2h0OiBlbGVtZW50Q2xpZW50UmVjdC5yaWdodCAtIGNsaXBwaW5nQ2xpZW50UmVjdC5yaWdodCArIHBhZGRpbmdPYmplY3QucmlnaHRcbiAgICB9O1xuICAgIHZhciBvZmZzZXREYXRhID0gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXQ7IC8vIE9mZnNldHMgY2FuIGJlIGFwcGxpZWQgb25seSB0byB0aGUgcG9wcGVyIGVsZW1lbnRcblxuICAgIGlmIChlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyICYmIG9mZnNldERhdGEpIHtcbiAgICAgIHZhciBvZmZzZXQgPSBvZmZzZXREYXRhW3BsYWNlbWVudF07XG4gICAgICBPYmplY3Qua2V5cyhvdmVyZmxvd09mZnNldHMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICB2YXIgbXVsdGlwbHkgPSBbcmlnaHQsIGJvdHRvbV0uaW5kZXhPZihrZXkpID49IDAgPyAxIDogLTE7XG4gICAgICAgIHZhciBheGlzID0gW3RvcCwgYm90dG9tXS5pbmRleE9mKGtleSkgPj0gMCA/ICd5JyA6ICd4JztcbiAgICAgICAgb3ZlcmZsb3dPZmZzZXRzW2tleV0gKz0gb2Zmc2V0W2F4aXNdICogbXVsdGlwbHk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3ZlcmZsb3dPZmZzZXRzO1xuICB9XG5cbiAgZnVuY3Rpb24gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBvcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdmFyIF9vcHRpb25zID0gb3B0aW9ucyxcbiAgICAgICAgcGxhY2VtZW50ID0gX29wdGlvbnMucGxhY2VtZW50LFxuICAgICAgICBib3VuZGFyeSA9IF9vcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgICByb290Qm91bmRhcnkgPSBfb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICAgIHBhZGRpbmcgPSBfb3B0aW9ucy5wYWRkaW5nLFxuICAgICAgICBmbGlwVmFyaWF0aW9ucyA9IF9vcHRpb25zLmZsaXBWYXJpYXRpb25zLFxuICAgICAgICBfb3B0aW9ucyRhbGxvd2VkQXV0b1AgPSBfb3B0aW9ucy5hbGxvd2VkQXV0b1BsYWNlbWVudHMsXG4gICAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50cyA9IF9vcHRpb25zJGFsbG93ZWRBdXRvUCA9PT0gdm9pZCAwID8gcGxhY2VtZW50cyA6IF9vcHRpb25zJGFsbG93ZWRBdXRvUDtcbiAgICB2YXIgdmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCk7XG4gICAgdmFyIHBsYWNlbWVudHMkMSA9IHZhcmlhdGlvbiA/IGZsaXBWYXJpYXRpb25zID8gdmFyaWF0aW9uUGxhY2VtZW50cyA6IHZhcmlhdGlvblBsYWNlbWVudHMuZmlsdGVyKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcbiAgICAgIHJldHVybiBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA9PT0gdmFyaWF0aW9uO1xuICAgIH0pIDogYmFzZVBsYWNlbWVudHM7XG4gICAgdmFyIGFsbG93ZWRQbGFjZW1lbnRzID0gcGxhY2VtZW50cyQxLmZpbHRlcihmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgICByZXR1cm4gYWxsb3dlZEF1dG9QbGFjZW1lbnRzLmluZGV4T2YocGxhY2VtZW50KSA+PSAwO1xuICAgIH0pO1xuXG4gICAgaWYgKGFsbG93ZWRQbGFjZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgYWxsb3dlZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzJDE7XG4gICAgfSAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXTogRmxvdyBzZWVtcyB0byBoYXZlIHByb2JsZW1zIHdpdGggdHdvIGFycmF5IHVuaW9ucy4uLlxuXG5cbiAgICB2YXIgb3ZlcmZsb3dzID0gYWxsb3dlZFBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICAgICAgYWNjW3BsYWNlbWVudF0gPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcbiAgICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcbiAgICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgICAgfSlbZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpXTtcbiAgICAgIHJldHVybiBhY2M7XG4gICAgfSwge30pO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvdmVyZmxvd3MpLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHJldHVybiBvdmVyZmxvd3NbYV0gLSBvdmVyZmxvd3NbYl07XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBnZXRFeHBhbmRlZEZhbGxiYWNrUGxhY2VtZW50cyhwbGFjZW1lbnQpIHtcbiAgICBpZiAoZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpID09PSBhdXRvKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgdmFyIG9wcG9zaXRlUGxhY2VtZW50ID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgICByZXR1cm4gW2dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KHBsYWNlbWVudCksIG9wcG9zaXRlUGxhY2VtZW50LCBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChvcHBvc2l0ZVBsYWNlbWVudCldO1xuICB9XG5cbiAgZnVuY3Rpb24gZmxpcChfcmVmKSB7XG4gICAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucyxcbiAgICAgICAgbmFtZSA9IF9yZWYubmFtZTtcblxuICAgIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdLl9za2lwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIF9vcHRpb25zJG1haW5BeGlzID0gb3B0aW9ucy5tYWluQXhpcyxcbiAgICAgICAgY2hlY2tNYWluQXhpcyA9IF9vcHRpb25zJG1haW5BeGlzID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkbWFpbkF4aXMsXG4gICAgICAgIF9vcHRpb25zJGFsdEF4aXMgPSBvcHRpb25zLmFsdEF4aXMsXG4gICAgICAgIGNoZWNrQWx0QXhpcyA9IF9vcHRpb25zJGFsdEF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRhbHRBeGlzLFxuICAgICAgICBzcGVjaWZpZWRGYWxsYmFja1BsYWNlbWVudHMgPSBvcHRpb25zLmZhbGxiYWNrUGxhY2VtZW50cyxcbiAgICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcbiAgICAgICAgYm91bmRhcnkgPSBvcHRpb25zLmJvdW5kYXJ5LFxuICAgICAgICByb290Qm91bmRhcnkgPSBvcHRpb25zLnJvb3RCb3VuZGFyeSxcbiAgICAgICAgYWx0Qm91bmRhcnkgPSBvcHRpb25zLmFsdEJvdW5kYXJ5LFxuICAgICAgICBfb3B0aW9ucyRmbGlwVmFyaWF0aW8gPSBvcHRpb25zLmZsaXBWYXJpYXRpb25zLFxuICAgICAgICBmbGlwVmFyaWF0aW9ucyA9IF9vcHRpb25zJGZsaXBWYXJpYXRpbyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJGZsaXBWYXJpYXRpbyxcbiAgICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzID0gb3B0aW9ucy5hbGxvd2VkQXV0b1BsYWNlbWVudHM7XG4gICAgdmFyIHByZWZlcnJlZFBsYWNlbWVudCA9IHN0YXRlLm9wdGlvbnMucGxhY2VtZW50O1xuICAgIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwcmVmZXJyZWRQbGFjZW1lbnQpO1xuICAgIHZhciBpc0Jhc2VQbGFjZW1lbnQgPSBiYXNlUGxhY2VtZW50ID09PSBwcmVmZXJyZWRQbGFjZW1lbnQ7XG4gICAgdmFyIGZhbGxiYWNrUGxhY2VtZW50cyA9IHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyB8fCAoaXNCYXNlUGxhY2VtZW50IHx8ICFmbGlwVmFyaWF0aW9ucyA/IFtnZXRPcHBvc2l0ZVBsYWNlbWVudChwcmVmZXJyZWRQbGFjZW1lbnQpXSA6IGdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzKHByZWZlcnJlZFBsYWNlbWVudCkpO1xuICAgIHZhciBwbGFjZW1lbnRzID0gW3ByZWZlcnJlZFBsYWNlbWVudF0uY29uY2F0KGZhbGxiYWNrUGxhY2VtZW50cykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xuICAgICAgcmV0dXJuIGFjYy5jb25jYXQoZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpID09PSBhdXRvID8gY29tcHV0ZUF1dG9QbGFjZW1lbnQoc3RhdGUsIHtcbiAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICAgIHBhZGRpbmc6IHBhZGRpbmcsXG4gICAgICAgIGZsaXBWYXJpYXRpb25zOiBmbGlwVmFyaWF0aW9ucyxcbiAgICAgICAgYWxsb3dlZEF1dG9QbGFjZW1lbnRzOiBhbGxvd2VkQXV0b1BsYWNlbWVudHNcbiAgICAgIH0pIDogcGxhY2VtZW50KTtcbiAgICB9LCBbXSk7XG4gICAgdmFyIHJlZmVyZW5jZVJlY3QgPSBzdGF0ZS5yZWN0cy5yZWZlcmVuY2U7XG4gICAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XG4gICAgdmFyIGNoZWNrc01hcCA9IG5ldyBNYXAoKTtcbiAgICB2YXIgbWFrZUZhbGxiYWNrQ2hlY2tzID0gdHJ1ZTtcbiAgICB2YXIgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50c1swXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGxhY2VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHBsYWNlbWVudCA9IHBsYWNlbWVudHNbaV07XG5cbiAgICAgIHZhciBfYmFzZVBsYWNlbWVudCA9IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KTtcblxuICAgICAgdmFyIGlzU3RhcnRWYXJpYXRpb24gPSBnZXRWYXJpYXRpb24ocGxhY2VtZW50KSA9PT0gc3RhcnQ7XG4gICAgICB2YXIgaXNWZXJ0aWNhbCA9IFt0b3AsIGJvdHRvbV0uaW5kZXhPZihfYmFzZVBsYWNlbWVudCkgPj0gMDtcbiAgICAgIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuICAgICAgdmFyIG92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXG4gICAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcbiAgICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICAgIGFsdEJvdW5kYXJ5OiBhbHRCb3VuZGFyeSxcbiAgICAgICAgcGFkZGluZzogcGFkZGluZ1xuICAgICAgfSk7XG4gICAgICB2YXIgbWFpblZhcmlhdGlvblNpZGUgPSBpc1ZlcnRpY2FsID8gaXNTdGFydFZhcmlhdGlvbiA/IHJpZ2h0IDogbGVmdCA6IGlzU3RhcnRWYXJpYXRpb24gPyBib3R0b20gOiB0b3A7XG5cbiAgICAgIGlmIChyZWZlcmVuY2VSZWN0W2xlbl0gPiBwb3BwZXJSZWN0W2xlbl0pIHtcbiAgICAgICAgbWFpblZhcmlhdGlvblNpZGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChtYWluVmFyaWF0aW9uU2lkZSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBhbHRWYXJpYXRpb25TaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpblZhcmlhdGlvblNpZGUpO1xuICAgICAgdmFyIGNoZWNrcyA9IFtdO1xuXG4gICAgICBpZiAoY2hlY2tNYWluQXhpcykge1xuICAgICAgICBjaGVja3MucHVzaChvdmVyZmxvd1tfYmFzZVBsYWNlbWVudF0gPD0gMCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChjaGVja0FsdEF4aXMpIHtcbiAgICAgICAgY2hlY2tzLnB1c2gob3ZlcmZsb3dbbWFpblZhcmlhdGlvblNpZGVdIDw9IDAsIG92ZXJmbG93W2FsdFZhcmlhdGlvblNpZGVdIDw9IDApO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hlY2tzLmV2ZXJ5KGZ1bmN0aW9uIChjaGVjaykge1xuICAgICAgICByZXR1cm4gY2hlY2s7XG4gICAgICB9KSkge1xuICAgICAgICBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnQ7XG4gICAgICAgIG1ha2VGYWxsYmFja0NoZWNrcyA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY2hlY2tzTWFwLnNldChwbGFjZW1lbnQsIGNoZWNrcyk7XG4gICAgfVxuXG4gICAgaWYgKG1ha2VGYWxsYmFja0NoZWNrcykge1xuICAgICAgLy8gYDJgIG1heSBiZSBkZXNpcmVkIGluIHNvbWUgY2FzZXMg4oCTIHJlc2VhcmNoIGxhdGVyXG4gICAgICB2YXIgbnVtYmVyT2ZDaGVja3MgPSBmbGlwVmFyaWF0aW9ucyA/IDMgOiAxO1xuXG4gICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChfaSkge1xuICAgICAgICB2YXIgZml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudHMuZmluZChmdW5jdGlvbiAocGxhY2VtZW50KSB7XG4gICAgICAgICAgdmFyIGNoZWNrcyA9IGNoZWNrc01hcC5nZXQocGxhY2VtZW50KTtcblxuICAgICAgICAgIGlmIChjaGVja3MpIHtcbiAgICAgICAgICAgIHJldHVybiBjaGVja3Muc2xpY2UoMCwgX2kpLmV2ZXJ5KGZ1bmN0aW9uIChjaGVjaykge1xuICAgICAgICAgICAgICByZXR1cm4gY2hlY2s7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChmaXR0aW5nUGxhY2VtZW50KSB7XG4gICAgICAgICAgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gZml0dGluZ1BsYWNlbWVudDtcbiAgICAgICAgICByZXR1cm4gXCJicmVha1wiO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBfaSA9IG51bWJlck9mQ2hlY2tzOyBfaSA+IDA7IF9pLS0pIHtcbiAgICAgICAgdmFyIF9yZXQgPSBfbG9vcChfaSk7XG5cbiAgICAgICAgaWYgKF9yZXQgPT09IFwiYnJlYWtcIikgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHN0YXRlLnBsYWNlbWVudCAhPT0gZmlyc3RGaXR0aW5nUGxhY2VtZW50KSB7XG4gICAgICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdLl9za2lwID0gdHJ1ZTtcbiAgICAgIHN0YXRlLnBsYWNlbWVudCA9IGZpcnN0Rml0dGluZ1BsYWNlbWVudDtcbiAgICAgIHN0YXRlLnJlc2V0ID0gdHJ1ZTtcbiAgICB9XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbiAgY29uc3QgZmxpcCQxID0ge1xuICAgIG5hbWU6ICdmbGlwJyxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIHBoYXNlOiAnbWFpbicsXG4gICAgZm46IGZsaXAsXG4gICAgcmVxdWlyZXNJZkV4aXN0czogWydvZmZzZXQnXSxcbiAgICBkYXRhOiB7XG4gICAgICBfc2tpcDogZmFsc2VcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gZ2V0U2lkZU9mZnNldHMob3ZlcmZsb3csIHJlY3QsIHByZXZlbnRlZE9mZnNldHMpIHtcbiAgICBpZiAocHJldmVudGVkT2Zmc2V0cyA9PT0gdm9pZCAwKSB7XG4gICAgICBwcmV2ZW50ZWRPZmZzZXRzID0ge1xuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICB0b3A6IG92ZXJmbG93LnRvcCAtIHJlY3QuaGVpZ2h0IC0gcHJldmVudGVkT2Zmc2V0cy55LFxuICAgICAgcmlnaHQ6IG92ZXJmbG93LnJpZ2h0IC0gcmVjdC53aWR0aCArIHByZXZlbnRlZE9mZnNldHMueCxcbiAgICAgIGJvdHRvbTogb3ZlcmZsb3cuYm90dG9tIC0gcmVjdC5oZWlnaHQgKyBwcmV2ZW50ZWRPZmZzZXRzLnksXG4gICAgICBsZWZ0OiBvdmVyZmxvdy5sZWZ0IC0gcmVjdC53aWR0aCAtIHByZXZlbnRlZE9mZnNldHMueFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBpc0FueVNpZGVGdWxseUNsaXBwZWQob3ZlcmZsb3cpIHtcbiAgICByZXR1cm4gW3RvcCwgcmlnaHQsIGJvdHRvbSwgbGVmdF0uc29tZShmdW5jdGlvbiAoc2lkZSkge1xuICAgICAgcmV0dXJuIG92ZXJmbG93W3NpZGVdID49IDA7XG4gICAgfSk7XG4gIH1cblxuICBmdW5jdGlvbiBoaWRlKF9yZWYpIHtcbiAgICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICAgIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xuICAgIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICAgIHZhciBwcmV2ZW50ZWRPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wcmV2ZW50T3ZlcmZsb3c7XG4gICAgdmFyIHJlZmVyZW5jZU92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcbiAgICAgIGVsZW1lbnRDb250ZXh0OiAncmVmZXJlbmNlJ1xuICAgIH0pO1xuICAgIHZhciBwb3BwZXJBbHRPdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XG4gICAgICBhbHRCb3VuZGFyeTogdHJ1ZVxuICAgIH0pO1xuICAgIHZhciByZWZlcmVuY2VDbGlwcGluZ09mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhyZWZlcmVuY2VPdmVyZmxvdywgcmVmZXJlbmNlUmVjdCk7XG4gICAgdmFyIHBvcHBlckVzY2FwZU9mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhwb3BwZXJBbHRPdmVyZmxvdywgcG9wcGVyUmVjdCwgcHJldmVudGVkT2Zmc2V0cyk7XG4gICAgdmFyIGlzUmVmZXJlbmNlSGlkZGVuID0gaXNBbnlTaWRlRnVsbHlDbGlwcGVkKHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyk7XG4gICAgdmFyIGhhc1BvcHBlckVzY2FwZWQgPSBpc0FueVNpZGVGdWxseUNsaXBwZWQocG9wcGVyRXNjYXBlT2Zmc2V0cyk7XG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IHtcbiAgICAgIHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0czogcmVmZXJlbmNlQ2xpcHBpbmdPZmZzZXRzLFxuICAgICAgcG9wcGVyRXNjYXBlT2Zmc2V0czogcG9wcGVyRXNjYXBlT2Zmc2V0cyxcbiAgICAgIGlzUmVmZXJlbmNlSGlkZGVuOiBpc1JlZmVyZW5jZUhpZGRlbixcbiAgICAgIGhhc1BvcHBlckVzY2FwZWQ6IGhhc1BvcHBlckVzY2FwZWRcbiAgICB9O1xuICAgIHN0YXRlLmF0dHJpYnV0ZXMucG9wcGVyID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIsIHtcbiAgICAgICdkYXRhLXBvcHBlci1yZWZlcmVuY2UtaGlkZGVuJzogaXNSZWZlcmVuY2VIaWRkZW4sXG4gICAgICAnZGF0YS1wb3BwZXItZXNjYXBlZCc6IGhhc1BvcHBlckVzY2FwZWRcbiAgICB9KTtcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cblxuICBjb25zdCBoaWRlJDEgPSB7XG4gICAgbmFtZTogJ2hpZGUnLFxuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgcGhhc2U6ICdtYWluJyxcbiAgICByZXF1aXJlc0lmRXhpc3RzOiBbJ3ByZXZlbnRPdmVyZmxvdyddLFxuICAgIGZuOiBoaWRlXG4gIH07XG5cbiAgZnVuY3Rpb24gZGlzdGFuY2VBbmRTa2lkZGluZ1RvWFkocGxhY2VtZW50LCByZWN0cywgb2Zmc2V0KSB7XG4gICAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gICAgdmFyIGludmVydERpc3RhbmNlID0gW2xlZnQsIHRvcF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwID8gLTEgOiAxO1xuXG4gICAgdmFyIF9yZWYgPSB0eXBlb2Ygb2Zmc2V0ID09PSAnZnVuY3Rpb24nID8gb2Zmc2V0KE9iamVjdC5hc3NpZ24oe30sIHJlY3RzLCB7XG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudFxuICAgIH0pKSA6IG9mZnNldCxcbiAgICAgICAgc2tpZGRpbmcgPSBfcmVmWzBdLFxuICAgICAgICBkaXN0YW5jZSA9IF9yZWZbMV07XG5cbiAgICBza2lkZGluZyA9IHNraWRkaW5nIHx8IDA7XG4gICAgZGlzdGFuY2UgPSAoZGlzdGFuY2UgfHwgMCkgKiBpbnZlcnREaXN0YW5jZTtcbiAgICByZXR1cm4gW2xlZnQsIHJpZ2h0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDAgPyB7XG4gICAgICB4OiBkaXN0YW5jZSxcbiAgICAgIHk6IHNraWRkaW5nXG4gICAgfSA6IHtcbiAgICAgIHg6IHNraWRkaW5nLFxuICAgICAgeTogZGlzdGFuY2VcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gb2Zmc2V0KF9yZWYyKSB7XG4gICAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGUsXG4gICAgICAgIG9wdGlvbnMgPSBfcmVmMi5vcHRpb25zLFxuICAgICAgICBuYW1lID0gX3JlZjIubmFtZTtcbiAgICB2YXIgX29wdGlvbnMkb2Zmc2V0ID0gb3B0aW9ucy5vZmZzZXQsXG4gICAgICAgIG9mZnNldCA9IF9vcHRpb25zJG9mZnNldCA9PT0gdm9pZCAwID8gWzAsIDBdIDogX29wdGlvbnMkb2Zmc2V0O1xuICAgIHZhciBkYXRhID0gcGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XG4gICAgICBhY2NbcGxhY2VtZW50XSA9IGRpc3RhbmNlQW5kU2tpZGRpbmdUb1hZKHBsYWNlbWVudCwgc3RhdGUucmVjdHMsIG9mZnNldCk7XG4gICAgICByZXR1cm4gYWNjO1xuICAgIH0sIHt9KTtcbiAgICB2YXIgX2RhdGEkc3RhdGUkcGxhY2VtZW50ID0gZGF0YVtzdGF0ZS5wbGFjZW1lbnRdLFxuICAgICAgICB4ID0gX2RhdGEkc3RhdGUkcGxhY2VtZW50LngsXG4gICAgICAgIHkgPSBfZGF0YSRzdGF0ZSRwbGFjZW1lbnQueTtcblxuICAgIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCkge1xuICAgICAgc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzLnggKz0geDtcbiAgICAgIHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cy55ICs9IHk7XG4gICAgfVxuXG4gICAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXSA9IGRhdGE7XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbiAgY29uc3Qgb2Zmc2V0JDEgPSB7XG4gICAgbmFtZTogJ29mZnNldCcsXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICBwaGFzZTogJ21haW4nLFxuICAgIHJlcXVpcmVzOiBbJ3BvcHBlck9mZnNldHMnXSxcbiAgICBmbjogb2Zmc2V0XG4gIH07XG5cbiAgZnVuY3Rpb24gcG9wcGVyT2Zmc2V0cyhfcmVmKSB7XG4gICAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcbiAgICAgICAgbmFtZSA9IF9yZWYubmFtZTtcbiAgICAvLyBPZmZzZXRzIGFyZSB0aGUgYWN0dWFsIHBvc2l0aW9uIHRoZSBwb3BwZXIgbmVlZHMgdG8gaGF2ZSB0byBiZVxuICAgIC8vIHByb3Blcmx5IHBvc2l0aW9uZWQgbmVhciBpdHMgcmVmZXJlbmNlIGVsZW1lbnRcbiAgICAvLyBUaGlzIGlzIHRoZSBtb3N0IGJhc2ljIHBsYWNlbWVudCwgYW5kIHdpbGwgYmUgYWRqdXN0ZWQgYnlcbiAgICAvLyB0aGUgbW9kaWZpZXJzIGluIHRoZSBuZXh0IHN0ZXBcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gY29tcHV0ZU9mZnNldHMoe1xuICAgICAgcmVmZXJlbmNlOiBzdGF0ZS5yZWN0cy5yZWZlcmVuY2UsXG4gICAgICBlbGVtZW50OiBzdGF0ZS5yZWN0cy5wb3BwZXIsXG4gICAgICBzdHJhdGVneTogJ2Fic29sdXRlJyxcbiAgICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XG4gICAgfSk7XG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG5cbiAgY29uc3QgcG9wcGVyT2Zmc2V0cyQxID0ge1xuICAgIG5hbWU6ICdwb3BwZXJPZmZzZXRzJyxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIHBoYXNlOiAncmVhZCcsXG4gICAgZm46IHBvcHBlck9mZnNldHMsXG4gICAgZGF0YToge31cbiAgfTtcblxuICBmdW5jdGlvbiBnZXRBbHRBeGlzKGF4aXMpIHtcbiAgICByZXR1cm4gYXhpcyA9PT0gJ3gnID8gJ3knIDogJ3gnO1xuICB9XG5cbiAgZnVuY3Rpb24gcHJldmVudE92ZXJmbG93KF9yZWYpIHtcbiAgICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxuICAgICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxuICAgICAgICBuYW1lID0gX3JlZi5uYW1lO1xuICAgIHZhciBfb3B0aW9ucyRtYWluQXhpcyA9IG9wdGlvbnMubWFpbkF4aXMsXG4gICAgICAgIGNoZWNrTWFpbkF4aXMgPSBfb3B0aW9ucyRtYWluQXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJG1haW5BeGlzLFxuICAgICAgICBfb3B0aW9ucyRhbHRBeGlzID0gb3B0aW9ucy5hbHRBeGlzLFxuICAgICAgICBjaGVja0FsdEF4aXMgPSBfb3B0aW9ucyRhbHRBeGlzID09PSB2b2lkIDAgPyBmYWxzZSA6IF9vcHRpb25zJGFsdEF4aXMsXG4gICAgICAgIGJvdW5kYXJ5ID0gb3B0aW9ucy5ib3VuZGFyeSxcbiAgICAgICAgcm9vdEJvdW5kYXJ5ID0gb3B0aW9ucy5yb290Qm91bmRhcnksXG4gICAgICAgIGFsdEJvdW5kYXJ5ID0gb3B0aW9ucy5hbHRCb3VuZGFyeSxcbiAgICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcbiAgICAgICAgX29wdGlvbnMkdGV0aGVyID0gb3B0aW9ucy50ZXRoZXIsXG4gICAgICAgIHRldGhlciA9IF9vcHRpb25zJHRldGhlciA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJHRldGhlcixcbiAgICAgICAgX29wdGlvbnMkdGV0aGVyT2Zmc2V0ID0gb3B0aW9ucy50ZXRoZXJPZmZzZXQsXG4gICAgICAgIHRldGhlck9mZnNldCA9IF9vcHRpb25zJHRldGhlck9mZnNldCA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJHRldGhlck9mZnNldDtcbiAgICB2YXIgb3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxuICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXG4gICAgICBwYWRkaW5nOiBwYWRkaW5nLFxuICAgICAgYWx0Qm91bmRhcnk6IGFsdEJvdW5kYXJ5XG4gICAgfSk7XG4gICAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHN0YXRlLnBsYWNlbWVudCk7XG4gICAgdmFyIHZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihzdGF0ZS5wbGFjZW1lbnQpO1xuICAgIHZhciBpc0Jhc2VQbGFjZW1lbnQgPSAhdmFyaWF0aW9uO1xuICAgIHZhciBtYWluQXhpcyA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KTtcbiAgICB2YXIgYWx0QXhpcyA9IGdldEFsdEF4aXMobWFpbkF4aXMpO1xuICAgIHZhciBwb3BwZXJPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzO1xuICAgIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xuICAgIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xuICAgIHZhciB0ZXRoZXJPZmZzZXRWYWx1ZSA9IHR5cGVvZiB0ZXRoZXJPZmZzZXQgPT09ICdmdW5jdGlvbicgPyB0ZXRoZXJPZmZzZXQoT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUucmVjdHMsIHtcbiAgICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XG4gICAgfSkpIDogdGV0aGVyT2Zmc2V0O1xuICAgIHZhciBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUgPSB0eXBlb2YgdGV0aGVyT2Zmc2V0VmFsdWUgPT09ICdudW1iZXInID8ge1xuICAgICAgbWFpbkF4aXM6IHRldGhlck9mZnNldFZhbHVlLFxuICAgICAgYWx0QXhpczogdGV0aGVyT2Zmc2V0VmFsdWVcbiAgICB9IDogT2JqZWN0LmFzc2lnbih7XG4gICAgICBtYWluQXhpczogMCxcbiAgICAgIGFsdEF4aXM6IDBcbiAgICB9LCB0ZXRoZXJPZmZzZXRWYWx1ZSk7XG4gICAgdmFyIG9mZnNldE1vZGlmaWVyU3RhdGUgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldCA/IHN0YXRlLm1vZGlmaWVyc0RhdGEub2Zmc2V0W3N0YXRlLnBsYWNlbWVudF0gOiBudWxsO1xuICAgIHZhciBkYXRhID0ge1xuICAgICAgeDogMCxcbiAgICAgIHk6IDBcbiAgICB9O1xuXG4gICAgaWYgKCFwb3BwZXJPZmZzZXRzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcbiAgICAgIHZhciBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQ7XG5cbiAgICAgIHZhciBtYWluU2lkZSA9IG1haW5BeGlzID09PSAneScgPyB0b3AgOiBsZWZ0O1xuICAgICAgdmFyIGFsdFNpZGUgPSBtYWluQXhpcyA9PT0gJ3knID8gYm90dG9tIDogcmlnaHQ7XG4gICAgICB2YXIgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcbiAgICAgIHZhciBvZmZzZXQgPSBwb3BwZXJPZmZzZXRzW21haW5BeGlzXTtcbiAgICAgIHZhciBtaW4kMSA9IG9mZnNldCArIG92ZXJmbG93W21haW5TaWRlXTtcbiAgICAgIHZhciBtYXgkMSA9IG9mZnNldCAtIG92ZXJmbG93W2FsdFNpZGVdO1xuICAgICAgdmFyIGFkZGl0aXZlID0gdGV0aGVyID8gLXBvcHBlclJlY3RbbGVuXSAvIDIgOiAwO1xuICAgICAgdmFyIG1pbkxlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyByZWZlcmVuY2VSZWN0W2xlbl0gOiBwb3BwZXJSZWN0W2xlbl07XG4gICAgICB2YXIgbWF4TGVuID0gdmFyaWF0aW9uID09PSBzdGFydCA/IC1wb3BwZXJSZWN0W2xlbl0gOiAtcmVmZXJlbmNlUmVjdFtsZW5dOyAvLyBXZSBuZWVkIHRvIGluY2x1ZGUgdGhlIGFycm93IGluIHRoZSBjYWxjdWxhdGlvbiBzbyB0aGUgYXJyb3cgZG9lc24ndCBnb1xuICAgICAgLy8gb3V0c2lkZSB0aGUgcmVmZXJlbmNlIGJvdW5kc1xuXG4gICAgICB2YXIgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMuYXJyb3c7XG4gICAgICB2YXIgYXJyb3dSZWN0ID0gdGV0aGVyICYmIGFycm93RWxlbWVudCA/IGdldExheW91dFJlY3QoYXJyb3dFbGVtZW50KSA6IHtcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMFxuICAgICAgfTtcbiAgICAgIHZhciBhcnJvd1BhZGRpbmdPYmplY3QgPSBzdGF0ZS5tb2RpZmllcnNEYXRhWydhcnJvdyNwZXJzaXN0ZW50J10gPyBzdGF0ZS5tb2RpZmllcnNEYXRhWydhcnJvdyNwZXJzaXN0ZW50J10ucGFkZGluZyA6IGdldEZyZXNoU2lkZU9iamVjdCgpO1xuICAgICAgdmFyIGFycm93UGFkZGluZ01pbiA9IGFycm93UGFkZGluZ09iamVjdFttYWluU2lkZV07XG4gICAgICB2YXIgYXJyb3dQYWRkaW5nTWF4ID0gYXJyb3dQYWRkaW5nT2JqZWN0W2FsdFNpZGVdOyAvLyBJZiB0aGUgcmVmZXJlbmNlIGxlbmd0aCBpcyBzbWFsbGVyIHRoYW4gdGhlIGFycm93IGxlbmd0aCwgd2UgZG9uJ3Qgd2FudFxuICAgICAgLy8gdG8gaW5jbHVkZSBpdHMgZnVsbCBzaXplIGluIHRoZSBjYWxjdWxhdGlvbi4gSWYgdGhlIHJlZmVyZW5jZSBpcyBzbWFsbFxuICAgICAgLy8gYW5kIG5lYXIgdGhlIGVkZ2Ugb2YgYSBib3VuZGFyeSwgdGhlIHBvcHBlciBjYW4gb3ZlcmZsb3cgZXZlbiBpZiB0aGVcbiAgICAgIC8vIHJlZmVyZW5jZSBpcyBub3Qgb3ZlcmZsb3dpbmcgYXMgd2VsbCAoZS5nLiB2aXJ0dWFsIGVsZW1lbnRzIHdpdGggbm9cbiAgICAgIC8vIHdpZHRoIG9yIGhlaWdodClcblxuICAgICAgdmFyIGFycm93TGVuID0gd2l0aGluKDAsIHJlZmVyZW5jZVJlY3RbbGVuXSwgYXJyb3dSZWN0W2xlbl0pO1xuICAgICAgdmFyIG1pbk9mZnNldCA9IGlzQmFzZVBsYWNlbWVudCA/IHJlZmVyZW5jZVJlY3RbbGVuXSAvIDIgLSBhZGRpdGl2ZSAtIGFycm93TGVuIC0gYXJyb3dQYWRkaW5nTWluIC0gbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzIDogbWluTGVuIC0gYXJyb3dMZW4gLSBhcnJvd1BhZGRpbmdNaW4gLSBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXM7XG4gICAgICB2YXIgbWF4T2Zmc2V0ID0gaXNCYXNlUGxhY2VtZW50ID8gLXJlZmVyZW5jZVJlY3RbbGVuXSAvIDIgKyBhZGRpdGl2ZSArIGFycm93TGVuICsgYXJyb3dQYWRkaW5nTWF4ICsgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzIDogbWF4TGVuICsgYXJyb3dMZW4gKyBhcnJvd1BhZGRpbmdNYXggKyBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXM7XG4gICAgICB2YXIgYXJyb3dPZmZzZXRQYXJlbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdyAmJiBnZXRPZmZzZXRQYXJlbnQoc3RhdGUuZWxlbWVudHMuYXJyb3cpO1xuICAgICAgdmFyIGNsaWVudE9mZnNldCA9IGFycm93T2Zmc2V0UGFyZW50ID8gbWFpbkF4aXMgPT09ICd5JyA/IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudFRvcCB8fCAwIDogYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50TGVmdCB8fCAwIDogMDtcbiAgICAgIHZhciBvZmZzZXRNb2RpZmllclZhbHVlID0gKF9vZmZzZXRNb2RpZmllclN0YXRlJCA9IG9mZnNldE1vZGlmaWVyU3RhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IG9mZnNldE1vZGlmaWVyU3RhdGVbbWFpbkF4aXNdKSAhPSBudWxsID8gX29mZnNldE1vZGlmaWVyU3RhdGUkIDogMDtcbiAgICAgIHZhciB0ZXRoZXJNaW4gPSBvZmZzZXQgKyBtaW5PZmZzZXQgLSBvZmZzZXRNb2RpZmllclZhbHVlIC0gY2xpZW50T2Zmc2V0O1xuICAgICAgdmFyIHRldGhlck1heCA9IG9mZnNldCArIG1heE9mZnNldCAtIG9mZnNldE1vZGlmaWVyVmFsdWU7XG4gICAgICB2YXIgcHJldmVudGVkT2Zmc2V0ID0gd2l0aGluKHRldGhlciA/IG1pbihtaW4kMSwgdGV0aGVyTWluKSA6IG1pbiQxLCBvZmZzZXQsIHRldGhlciA/IG1heChtYXgkMSwgdGV0aGVyTWF4KSA6IG1heCQxKTtcbiAgICAgIHBvcHBlck9mZnNldHNbbWFpbkF4aXNdID0gcHJldmVudGVkT2Zmc2V0O1xuICAgICAgZGF0YVttYWluQXhpc10gPSBwcmV2ZW50ZWRPZmZzZXQgLSBvZmZzZXQ7XG4gICAgfVxuXG4gICAgaWYgKGNoZWNrQWx0QXhpcykge1xuICAgICAgdmFyIF9vZmZzZXRNb2RpZmllclN0YXRlJDI7XG5cbiAgICAgIHZhciBfbWFpblNpZGUgPSBtYWluQXhpcyA9PT0gJ3gnID8gdG9wIDogbGVmdDtcblxuICAgICAgdmFyIF9hbHRTaWRlID0gbWFpbkF4aXMgPT09ICd4JyA/IGJvdHRvbSA6IHJpZ2h0O1xuXG4gICAgICB2YXIgX29mZnNldCA9IHBvcHBlck9mZnNldHNbYWx0QXhpc107XG5cbiAgICAgIHZhciBfbGVuID0gYWx0QXhpcyA9PT0gJ3knID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuXG4gICAgICB2YXIgX21pbiA9IF9vZmZzZXQgKyBvdmVyZmxvd1tfbWFpblNpZGVdO1xuXG4gICAgICB2YXIgX21heCA9IF9vZmZzZXQgLSBvdmVyZmxvd1tfYWx0U2lkZV07XG5cbiAgICAgIHZhciBpc09yaWdpblNpZGUgPSBbdG9wLCBsZWZ0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcblxuICAgICAgdmFyIF9vZmZzZXRNb2RpZmllclZhbHVlID0gKF9vZmZzZXRNb2RpZmllclN0YXRlJDIgPSBvZmZzZXRNb2RpZmllclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBvZmZzZXRNb2RpZmllclN0YXRlW2FsdEF4aXNdKSAhPSBudWxsID8gX29mZnNldE1vZGlmaWVyU3RhdGUkMiA6IDA7XG5cbiAgICAgIHZhciBfdGV0aGVyTWluID0gaXNPcmlnaW5TaWRlID8gX21pbiA6IF9vZmZzZXQgLSByZWZlcmVuY2VSZWN0W19sZW5dIC0gcG9wcGVyUmVjdFtfbGVuXSAtIF9vZmZzZXRNb2RpZmllclZhbHVlICsgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLmFsdEF4aXM7XG5cbiAgICAgIHZhciBfdGV0aGVyTWF4ID0gaXNPcmlnaW5TaWRlID8gX29mZnNldCArIHJlZmVyZW5jZVJlY3RbX2xlbl0gKyBwb3BwZXJSZWN0W19sZW5dIC0gX29mZnNldE1vZGlmaWVyVmFsdWUgLSBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUuYWx0QXhpcyA6IF9tYXg7XG5cbiAgICAgIHZhciBfcHJldmVudGVkT2Zmc2V0ID0gdGV0aGVyICYmIGlzT3JpZ2luU2lkZSA/IHdpdGhpbk1heENsYW1wKF90ZXRoZXJNaW4sIF9vZmZzZXQsIF90ZXRoZXJNYXgpIDogd2l0aGluKHRldGhlciA/IF90ZXRoZXJNaW4gOiBfbWluLCBfb2Zmc2V0LCB0ZXRoZXIgPyBfdGV0aGVyTWF4IDogX21heCk7XG5cbiAgICAgIHBvcHBlck9mZnNldHNbYWx0QXhpc10gPSBfcHJldmVudGVkT2Zmc2V0O1xuICAgICAgZGF0YVthbHRBeGlzXSA9IF9wcmV2ZW50ZWRPZmZzZXQgLSBfb2Zmc2V0O1xuICAgIH1cblxuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBkYXRhO1xuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuXG4gIGNvbnN0IHByZXZlbnRPdmVyZmxvdyQxID0ge1xuICAgIG5hbWU6ICdwcmV2ZW50T3ZlcmZsb3cnLFxuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgcGhhc2U6ICdtYWluJyxcbiAgICBmbjogcHJldmVudE92ZXJmbG93LFxuICAgIHJlcXVpcmVzSWZFeGlzdHM6IFsnb2Zmc2V0J11cbiAgfTtcblxuICBmdW5jdGlvbiBnZXRIVE1MRWxlbWVudFNjcm9sbChlbGVtZW50KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjcm9sbExlZnQ6IGVsZW1lbnQuc2Nyb2xsTGVmdCxcbiAgICAgIHNjcm9sbFRvcDogZWxlbWVudC5zY3JvbGxUb3BcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gZ2V0Tm9kZVNjcm9sbChub2RlKSB7XG4gICAgaWYgKG5vZGUgPT09IGdldFdpbmRvdyhub2RlKSB8fCAhaXNIVE1MRWxlbWVudChub2RlKSkge1xuICAgICAgcmV0dXJuIGdldFdpbmRvd1Njcm9sbChub2RlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdldEhUTUxFbGVtZW50U2Nyb2xsKG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzRWxlbWVudFNjYWxlZChlbGVtZW50KSB7XG4gICAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHZhciBzY2FsZVggPSByb3VuZChyZWN0LndpZHRoKSAvIGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgMTtcbiAgICB2YXIgc2NhbGVZID0gcm91bmQocmVjdC5oZWlnaHQpIC8gZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgMTtcbiAgICByZXR1cm4gc2NhbGVYICE9PSAxIHx8IHNjYWxlWSAhPT0gMTtcbiAgfSAvLyBSZXR1cm5zIHRoZSBjb21wb3NpdGUgcmVjdCBvZiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIGl0cyBvZmZzZXRQYXJlbnQuXG4gIC8vIENvbXBvc2l0ZSBtZWFucyBpdCB0YWtlcyBpbnRvIGFjY291bnQgdHJhbnNmb3JtcyBhcyB3ZWxsIGFzIGxheW91dC5cblxuXG4gIGZ1bmN0aW9uIGdldENvbXBvc2l0ZVJlY3QoZWxlbWVudE9yVmlydHVhbEVsZW1lbnQsIG9mZnNldFBhcmVudCwgaXNGaXhlZCkge1xuICAgIGlmIChpc0ZpeGVkID09PSB2b2lkIDApIHtcbiAgICAgIGlzRml4ZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgPSBpc0hUTUxFbGVtZW50KG9mZnNldFBhcmVudCk7XG4gICAgdmFyIG9mZnNldFBhcmVudElzU2NhbGVkID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGlzRWxlbWVudFNjYWxlZChvZmZzZXRQYXJlbnQpO1xuICAgIHZhciBkb2N1bWVudEVsZW1lbnQgPSBnZXREb2N1bWVudEVsZW1lbnQob2Zmc2V0UGFyZW50KTtcbiAgICB2YXIgcmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50T3JWaXJ0dWFsRWxlbWVudCwgb2Zmc2V0UGFyZW50SXNTY2FsZWQsIGlzRml4ZWQpO1xuICAgIHZhciBzY3JvbGwgPSB7XG4gICAgICBzY3JvbGxMZWZ0OiAwLFxuICAgICAgc2Nyb2xsVG9wOiAwXG4gICAgfTtcbiAgICB2YXIgb2Zmc2V0cyA9IHtcbiAgICAgIHg6IDAsXG4gICAgICB5OiAwXG4gICAgfTtcblxuICAgIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCB8fCAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgIWlzRml4ZWQpIHtcbiAgICAgIGlmIChnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpICE9PSAnYm9keScgfHwgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy8xMDc4XG4gICAgICBpc1Njcm9sbFBhcmVudChkb2N1bWVudEVsZW1lbnQpKSB7XG4gICAgICAgIHNjcm9sbCA9IGdldE5vZGVTY3JvbGwob2Zmc2V0UGFyZW50KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSkge1xuICAgICAgICBvZmZzZXRzID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KG9mZnNldFBhcmVudCwgdHJ1ZSk7XG4gICAgICAgIG9mZnNldHMueCArPSBvZmZzZXRQYXJlbnQuY2xpZW50TGVmdDtcbiAgICAgICAgb2Zmc2V0cy55ICs9IG9mZnNldFBhcmVudC5jbGllbnRUb3A7XG4gICAgICB9IGVsc2UgaWYgKGRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICBvZmZzZXRzLnggPSBnZXRXaW5kb3dTY3JvbGxCYXJYKGRvY3VtZW50RWxlbWVudCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IHJlY3QubGVmdCArIHNjcm9sbC5zY3JvbGxMZWZ0IC0gb2Zmc2V0cy54LFxuICAgICAgeTogcmVjdC50b3AgKyBzY3JvbGwuc2Nyb2xsVG9wIC0gb2Zmc2V0cy55LFxuICAgICAgd2lkdGg6IHJlY3Qud2lkdGgsXG4gICAgICBoZWlnaHQ6IHJlY3QuaGVpZ2h0XG4gICAgfTtcbiAgfVxuXG4gIGZ1bmN0aW9uIG9yZGVyKG1vZGlmaWVycykge1xuICAgIHZhciBtYXAgPSBuZXcgTWFwKCk7XG4gICAgdmFyIHZpc2l0ZWQgPSBuZXcgU2V0KCk7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgICAgbWFwLnNldChtb2RpZmllci5uYW1lLCBtb2RpZmllcik7XG4gICAgfSk7IC8vIE9uIHZpc2l0aW5nIG9iamVjdCwgY2hlY2sgZm9yIGl0cyBkZXBlbmRlbmNpZXMgYW5kIHZpc2l0IHRoZW0gcmVjdXJzaXZlbHlcblxuICAgIGZ1bmN0aW9uIHNvcnQobW9kaWZpZXIpIHtcbiAgICAgIHZpc2l0ZWQuYWRkKG1vZGlmaWVyLm5hbWUpO1xuICAgICAgdmFyIHJlcXVpcmVzID0gW10uY29uY2F0KG1vZGlmaWVyLnJlcXVpcmVzIHx8IFtdLCBtb2RpZmllci5yZXF1aXJlc0lmRXhpc3RzIHx8IFtdKTtcbiAgICAgIHJlcXVpcmVzLmZvckVhY2goZnVuY3Rpb24gKGRlcCkge1xuICAgICAgICBpZiAoIXZpc2l0ZWQuaGFzKGRlcCkpIHtcbiAgICAgICAgICB2YXIgZGVwTW9kaWZpZXIgPSBtYXAuZ2V0KGRlcCk7XG5cbiAgICAgICAgICBpZiAoZGVwTW9kaWZpZXIpIHtcbiAgICAgICAgICAgIHNvcnQoZGVwTW9kaWZpZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXN1bHQucHVzaChtb2RpZmllcik7XG4gICAgfVxuXG4gICAgbW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgICBpZiAoIXZpc2l0ZWQuaGFzKG1vZGlmaWVyLm5hbWUpKSB7XG4gICAgICAgIC8vIGNoZWNrIGZvciB2aXNpdGVkIG9iamVjdFxuICAgICAgICBzb3J0KG1vZGlmaWVyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZnVuY3Rpb24gb3JkZXJNb2RpZmllcnMobW9kaWZpZXJzKSB7XG4gICAgLy8gb3JkZXIgYmFzZWQgb24gZGVwZW5kZW5jaWVzXG4gICAgdmFyIG9yZGVyZWRNb2RpZmllcnMgPSBvcmRlcihtb2RpZmllcnMpOyAvLyBvcmRlciBiYXNlZCBvbiBwaGFzZVxuXG4gICAgcmV0dXJuIG1vZGlmaWVyUGhhc2VzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwaGFzZSkge1xuICAgICAgcmV0dXJuIGFjYy5jb25jYXQob3JkZXJlZE1vZGlmaWVycy5maWx0ZXIoZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgICAgIHJldHVybiBtb2RpZmllci5waGFzZSA9PT0gcGhhc2U7XG4gICAgICB9KSk7XG4gICAgfSwgW10pO1xuICB9XG5cbiAgZnVuY3Rpb24gZGVib3VuY2UoZm4pIHtcbiAgICB2YXIgcGVuZGluZztcbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFwZW5kaW5nKSB7XG4gICAgICAgIHBlbmRpbmcgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcGVuZGluZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHJlc29sdmUoZm4oKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcGVuZGluZztcbiAgICB9O1xuICB9XG5cbiAgZnVuY3Rpb24gbWVyZ2VCeU5hbWUobW9kaWZpZXJzKSB7XG4gICAgdmFyIG1lcmdlZCA9IG1vZGlmaWVycy5yZWR1Y2UoZnVuY3Rpb24gKG1lcmdlZCwgY3VycmVudCkge1xuICAgICAgdmFyIGV4aXN0aW5nID0gbWVyZ2VkW2N1cnJlbnQubmFtZV07XG4gICAgICBtZXJnZWRbY3VycmVudC5uYW1lXSA9IGV4aXN0aW5nID8gT2JqZWN0LmFzc2lnbih7fSwgZXhpc3RpbmcsIGN1cnJlbnQsIHtcbiAgICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgZXhpc3Rpbmcub3B0aW9ucywgY3VycmVudC5vcHRpb25zKSxcbiAgICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7fSwgZXhpc3RpbmcuZGF0YSwgY3VycmVudC5kYXRhKVxuICAgICAgfSkgOiBjdXJyZW50O1xuICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICB9LCB7fSk7IC8vIElFMTEgZG9lcyBub3Qgc3VwcG9ydCBPYmplY3QudmFsdWVzXG5cbiAgICByZXR1cm4gT2JqZWN0LmtleXMobWVyZ2VkKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIG1lcmdlZFtrZXldO1xuICAgIH0pO1xuICB9XG5cbiAgdmFyIERFRkFVTFRfT1BUSU9OUyA9IHtcbiAgICBwbGFjZW1lbnQ6ICdib3R0b20nLFxuICAgIG1vZGlmaWVyczogW10sXG4gICAgc3RyYXRlZ3k6ICdhYnNvbHV0ZSdcbiAgfTtcblxuICBmdW5jdGlvbiBhcmVWYWxpZEVsZW1lbnRzKCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gbmV3IEFycmF5KF9sZW4pLCBfa2V5ID0gMDsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcbiAgICB9XG5cbiAgICByZXR1cm4gIWFyZ3Muc29tZShmdW5jdGlvbiAoZWxlbWVudCkge1xuICAgICAgcmV0dXJuICEoZWxlbWVudCAmJiB0eXBlb2YgZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QgPT09ICdmdW5jdGlvbicpO1xuICAgIH0pO1xuICB9XG5cbiAgZnVuY3Rpb24gcG9wcGVyR2VuZXJhdG9yKGdlbmVyYXRvck9wdGlvbnMpIHtcbiAgICBpZiAoZ2VuZXJhdG9yT3B0aW9ucyA9PT0gdm9pZCAwKSB7XG4gICAgICBnZW5lcmF0b3JPcHRpb25zID0ge307XG4gICAgfVxuXG4gICAgdmFyIF9nZW5lcmF0b3JPcHRpb25zID0gZ2VuZXJhdG9yT3B0aW9ucyxcbiAgICAgICAgX2dlbmVyYXRvck9wdGlvbnMkZGVmID0gX2dlbmVyYXRvck9wdGlvbnMuZGVmYXVsdE1vZGlmaWVycyxcbiAgICAgICAgZGVmYXVsdE1vZGlmaWVycyA9IF9nZW5lcmF0b3JPcHRpb25zJGRlZiA9PT0gdm9pZCAwID8gW10gOiBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYsXG4gICAgICAgIF9nZW5lcmF0b3JPcHRpb25zJGRlZjIgPSBfZ2VuZXJhdG9yT3B0aW9ucy5kZWZhdWx0T3B0aW9ucyxcbiAgICAgICAgZGVmYXVsdE9wdGlvbnMgPSBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyID09PSB2b2lkIDAgPyBERUZBVUxUX09QVElPTlMgOiBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYyO1xuICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVQb3BwZXIocmVmZXJlbmNlLCBwb3BwZXIsIG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHtcbiAgICAgICAgb3B0aW9ucyA9IGRlZmF1bHRPcHRpb25zO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgIHBsYWNlbWVudDogJ2JvdHRvbScsXG4gICAgICAgIG9yZGVyZWRNb2RpZmllcnM6IFtdLFxuICAgICAgICBvcHRpb25zOiBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX09QVElPTlMsIGRlZmF1bHRPcHRpb25zKSxcbiAgICAgICAgbW9kaWZpZXJzRGF0YToge30sXG4gICAgICAgIGVsZW1lbnRzOiB7XG4gICAgICAgICAgcmVmZXJlbmNlOiByZWZlcmVuY2UsXG4gICAgICAgICAgcG9wcGVyOiBwb3BwZXJcbiAgICAgICAgfSxcbiAgICAgICAgYXR0cmlidXRlczoge30sXG4gICAgICAgIHN0eWxlczoge31cbiAgICAgIH07XG4gICAgICB2YXIgZWZmZWN0Q2xlYW51cEZucyA9IFtdO1xuICAgICAgdmFyIGlzRGVzdHJveWVkID0gZmFsc2U7XG4gICAgICB2YXIgaW5zdGFuY2UgPSB7XG4gICAgICAgIHN0YXRlOiBzdGF0ZSxcbiAgICAgICAgc2V0T3B0aW9uczogZnVuY3Rpb24gc2V0T3B0aW9ucyhzZXRPcHRpb25zQWN0aW9uKSB7XG4gICAgICAgICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2V0T3B0aW9uc0FjdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/IHNldE9wdGlvbnNBY3Rpb24oc3RhdGUub3B0aW9ucykgOiBzZXRPcHRpb25zQWN0aW9uO1xuICAgICAgICAgIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKTtcbiAgICAgICAgICBzdGF0ZS5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIHN0YXRlLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgICAgIHN0YXRlLnNjcm9sbFBhcmVudHMgPSB7XG4gICAgICAgICAgICByZWZlcmVuY2U6IGlzRWxlbWVudChyZWZlcmVuY2UpID8gbGlzdFNjcm9sbFBhcmVudHMocmVmZXJlbmNlKSA6IHJlZmVyZW5jZS5jb250ZXh0RWxlbWVudCA/IGxpc3RTY3JvbGxQYXJlbnRzKHJlZmVyZW5jZS5jb250ZXh0RWxlbWVudCkgOiBbXSxcbiAgICAgICAgICAgIHBvcHBlcjogbGlzdFNjcm9sbFBhcmVudHMocG9wcGVyKVxuICAgICAgICAgIH07IC8vIE9yZGVycyB0aGUgbW9kaWZpZXJzIGJhc2VkIG9uIHRoZWlyIGRlcGVuZGVuY2llcyBhbmQgYHBoYXNlYFxuICAgICAgICAgIC8vIHByb3BlcnRpZXNcblxuICAgICAgICAgIHZhciBvcmRlcmVkTW9kaWZpZXJzID0gb3JkZXJNb2RpZmllcnMobWVyZ2VCeU5hbWUoW10uY29uY2F0KGRlZmF1bHRNb2RpZmllcnMsIHN0YXRlLm9wdGlvbnMubW9kaWZpZXJzKSkpOyAvLyBTdHJpcCBvdXQgZGlzYWJsZWQgbW9kaWZpZXJzXG5cbiAgICAgICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzID0gb3JkZXJlZE1vZGlmaWVycy5maWx0ZXIoZnVuY3Rpb24gKG0pIHtcbiAgICAgICAgICAgIHJldHVybiBtLmVuYWJsZWQ7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcnVuTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgICAgcmV0dXJuIGluc3RhbmNlLnVwZGF0ZSgpO1xuICAgICAgICB9LFxuICAgICAgICAvLyBTeW5jIHVwZGF0ZSDigJMgaXQgd2lsbCBhbHdheXMgYmUgZXhlY3V0ZWQsIGV2ZW4gaWYgbm90IG5lY2Vzc2FyeS4gVGhpc1xuICAgICAgICAvLyBpcyB1c2VmdWwgZm9yIGxvdyBmcmVxdWVuY3kgdXBkYXRlcyB3aGVyZSBzeW5jIGJlaGF2aW9yIHNpbXBsaWZpZXMgdGhlXG4gICAgICAgIC8vIGxvZ2ljLlxuICAgICAgICAvLyBGb3IgaGlnaCBmcmVxdWVuY3kgdXBkYXRlcyAoZS5nLiBgcmVzaXplYCBhbmQgYHNjcm9sbGAgZXZlbnRzKSwgYWx3YXlzXG4gICAgICAgIC8vIHByZWZlciB0aGUgYXN5bmMgUG9wcGVyI3VwZGF0ZSBtZXRob2RcbiAgICAgICAgZm9yY2VVcGRhdGU6IGZ1bmN0aW9uIGZvcmNlVXBkYXRlKCkge1xuICAgICAgICAgIGlmIChpc0Rlc3Ryb3llZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHZhciBfc3RhdGUkZWxlbWVudHMgPSBzdGF0ZS5lbGVtZW50cyxcbiAgICAgICAgICAgICAgcmVmZXJlbmNlID0gX3N0YXRlJGVsZW1lbnRzLnJlZmVyZW5jZSxcbiAgICAgICAgICAgICAgcG9wcGVyID0gX3N0YXRlJGVsZW1lbnRzLnBvcHBlcjsgLy8gRG9uJ3QgcHJvY2VlZCBpZiBgcmVmZXJlbmNlYCBvciBgcG9wcGVyYCBhcmUgbm90IHZhbGlkIGVsZW1lbnRzXG4gICAgICAgICAgLy8gYW55bW9yZVxuXG4gICAgICAgICAgaWYgKCFhcmVWYWxpZEVsZW1lbnRzKHJlZmVyZW5jZSwgcG9wcGVyKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH0gLy8gU3RvcmUgdGhlIHJlZmVyZW5jZSBhbmQgcG9wcGVyIHJlY3RzIHRvIGJlIHJlYWQgYnkgbW9kaWZpZXJzXG5cblxuICAgICAgICAgIHN0YXRlLnJlY3RzID0ge1xuICAgICAgICAgICAgcmVmZXJlbmNlOiBnZXRDb21wb3NpdGVSZWN0KHJlZmVyZW5jZSwgZ2V0T2Zmc2V0UGFyZW50KHBvcHBlciksIHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3kgPT09ICdmaXhlZCcpLFxuICAgICAgICAgICAgcG9wcGVyOiBnZXRMYXlvdXRSZWN0KHBvcHBlcilcbiAgICAgICAgICB9OyAvLyBNb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byByZXNldCB0aGUgY3VycmVudCB1cGRhdGUgY3ljbGUuIFRoZVxuICAgICAgICAgIC8vIG1vc3QgY29tbW9uIHVzZSBjYXNlIGZvciB0aGlzIGlzIHRoZSBgZmxpcGAgbW9kaWZpZXIgY2hhbmdpbmcgdGhlXG4gICAgICAgICAgLy8gcGxhY2VtZW50LCB3aGljaCB0aGVuIG5lZWRzIHRvIHJlLXJ1biBhbGwgdGhlIG1vZGlmaWVycywgYmVjYXVzZSB0aGVcbiAgICAgICAgICAvLyBsb2dpYyB3YXMgcHJldmlvdXNseSByYW4gZm9yIHRoZSBwcmV2aW91cyBwbGFjZW1lbnQgYW5kIGlzIHRoZXJlZm9yZVxuICAgICAgICAgIC8vIHN0YWxlL2luY29ycmVjdFxuXG4gICAgICAgICAgc3RhdGUucmVzZXQgPSBmYWxzZTtcbiAgICAgICAgICBzdGF0ZS5wbGFjZW1lbnQgPSBzdGF0ZS5vcHRpb25zLnBsYWNlbWVudDsgLy8gT24gZWFjaCB1cGRhdGUgY3ljbGUsIHRoZSBgbW9kaWZpZXJzRGF0YWAgcHJvcGVydHkgZm9yIGVhY2ggbW9kaWZpZXJcbiAgICAgICAgICAvLyBpcyBmaWxsZWQgd2l0aCB0aGUgaW5pdGlhbCBkYXRhIHNwZWNpZmllZCBieSB0aGUgbW9kaWZpZXIuIFRoaXMgbWVhbnNcbiAgICAgICAgICAvLyBpdCBkb2Vzbid0IHBlcnNpc3QgYW5kIGlzIGZyZXNoIG9uIGVhY2ggdXBkYXRlLlxuICAgICAgICAgIC8vIFRvIGVuc3VyZSBwZXJzaXN0ZW50IGRhdGEsIHVzZSBgJHtuYW1lfSNwZXJzaXN0ZW50YFxuXG4gICAgICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLm1vZGlmaWVyc0RhdGFbbW9kaWZpZXIubmFtZV0gPSBPYmplY3QuYXNzaWduKHt9LCBtb2RpZmllci5kYXRhKTtcbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICAgICAgaWYgKHN0YXRlLnJlc2V0ID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgIHN0YXRlLnJlc2V0ID0gZmFsc2U7XG4gICAgICAgICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgX3N0YXRlJG9yZGVyZWRNb2RpZmllID0gc3RhdGUub3JkZXJlZE1vZGlmaWVyc1tpbmRleF0sXG4gICAgICAgICAgICAgICAgZm4gPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUuZm4sXG4gICAgICAgICAgICAgICAgX3N0YXRlJG9yZGVyZWRNb2RpZmllMiA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5vcHRpb25zLFxuICAgICAgICAgICAgICAgIF9vcHRpb25zID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllMiA9PT0gdm9pZCAwID8ge30gOiBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyLFxuICAgICAgICAgICAgICAgIG5hbWUgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUubmFtZTtcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICBzdGF0ZSA9IGZuKHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogc3RhdGUsXG4gICAgICAgICAgICAgICAgb3B0aW9uczogX29wdGlvbnMsXG4gICAgICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2VcbiAgICAgICAgICAgICAgfSkgfHwgc3RhdGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBBc3luYyBhbmQgb3B0aW1pc3RpY2FsbHkgb3B0aW1pemVkIHVwZGF0ZSDigJMgaXQgd2lsbCBub3QgYmUgZXhlY3V0ZWQgaWZcbiAgICAgICAgLy8gbm90IG5lY2Vzc2FyeSAoZGVib3VuY2VkIHRvIHJ1biBhdCBtb3N0IG9uY2UtcGVyLXRpY2spXG4gICAgICAgIHVwZGF0ZTogZGVib3VuY2UoZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgICAgaW5zdGFuY2UuZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgICAgIHJlc29sdmUoc3RhdGUpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSxcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgICBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCk7XG4gICAgICAgICAgaXNEZXN0cm95ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBpZiAoIWFyZVZhbGlkRWxlbWVudHMocmVmZXJlbmNlLCBwb3BwZXIpKSB7XG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICAgIH1cblxuICAgICAgaW5zdGFuY2Uuc2V0T3B0aW9ucyhvcHRpb25zKS50aGVuKGZ1bmN0aW9uIChzdGF0ZSkge1xuICAgICAgICBpZiAoIWlzRGVzdHJveWVkICYmIG9wdGlvbnMub25GaXJzdFVwZGF0ZSkge1xuICAgICAgICAgIG9wdGlvbnMub25GaXJzdFVwZGF0ZShzdGF0ZSk7XG4gICAgICAgIH1cbiAgICAgIH0pOyAvLyBNb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byBleGVjdXRlIGFyYml0cmFyeSBjb2RlIGJlZm9yZSB0aGUgZmlyc3RcbiAgICAgIC8vIHVwZGF0ZSBjeWNsZSBydW5zLiBUaGV5IHdpbGwgYmUgZXhlY3V0ZWQgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlIHVwZGF0ZVxuICAgICAgLy8gY3ljbGUuIFRoaXMgaXMgdXNlZnVsIHdoZW4gYSBtb2RpZmllciBhZGRzIHNvbWUgcGVyc2lzdGVudCBkYXRhIHRoYXRcbiAgICAgIC8vIG90aGVyIG1vZGlmaWVycyBuZWVkIHRvIHVzZSwgYnV0IHRoZSBtb2RpZmllciBpcyBydW4gYWZ0ZXIgdGhlIGRlcGVuZGVudFxuICAgICAgLy8gb25lLlxuXG4gICAgICBmdW5jdGlvbiBydW5Nb2RpZmllckVmZmVjdHMoKSB7XG4gICAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAoX3JlZikge1xuICAgICAgICAgIHZhciBuYW1lID0gX3JlZi5uYW1lLFxuICAgICAgICAgICAgICBfcmVmJG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXG4gICAgICAgICAgICAgIG9wdGlvbnMgPSBfcmVmJG9wdGlvbnMgPT09IHZvaWQgMCA/IHt9IDogX3JlZiRvcHRpb25zLFxuICAgICAgICAgICAgICBlZmZlY3QgPSBfcmVmLmVmZmVjdDtcblxuICAgICAgICAgIGlmICh0eXBlb2YgZWZmZWN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICB2YXIgY2xlYW51cEZuID0gZWZmZWN0KHtcbiAgICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxuICAgICAgICAgICAgICBuYW1lOiBuYW1lLFxuICAgICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2UsXG4gICAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICB2YXIgbm9vcEZuID0gZnVuY3Rpb24gbm9vcEZuKCkge307XG5cbiAgICAgICAgICAgIGVmZmVjdENsZWFudXBGbnMucHVzaChjbGVhbnVwRm4gfHwgbm9vcEZuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCkge1xuICAgICAgICBlZmZlY3RDbGVhbnVwRm5zLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XG4gICAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBlZmZlY3RDbGVhbnVwRm5zID0gW107XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBpbnN0YW5jZTtcbiAgICB9O1xuICB9XG4gIHZhciBjcmVhdGVQb3BwZXIkMiA9IC8qI19fUFVSRV9fKi9wb3BwZXJHZW5lcmF0b3IoKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xuXG4gIHZhciBkZWZhdWx0TW9kaWZpZXJzJDEgPSBbZXZlbnRMaXN0ZW5lcnMsIHBvcHBlck9mZnNldHMkMSwgY29tcHV0ZVN0eWxlcyQxLCBhcHBseVN0eWxlcyQxXTtcbiAgdmFyIGNyZWF0ZVBvcHBlciQxID0gLyojX19QVVJFX18qL3BvcHBlckdlbmVyYXRvcih7XG4gICAgZGVmYXVsdE1vZGlmaWVyczogZGVmYXVsdE1vZGlmaWVycyQxXG4gIH0pOyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXG5cbiAgdmFyIGRlZmF1bHRNb2RpZmllcnMgPSBbZXZlbnRMaXN0ZW5lcnMsIHBvcHBlck9mZnNldHMkMSwgY29tcHV0ZVN0eWxlcyQxLCBhcHBseVN0eWxlcyQxLCBvZmZzZXQkMSwgZmxpcCQxLCBwcmV2ZW50T3ZlcmZsb3ckMSwgYXJyb3ckMSwgaGlkZSQxXTtcbiAgdmFyIGNyZWF0ZVBvcHBlciA9IC8qI19fUFVSRV9fKi9wb3BwZXJHZW5lcmF0b3Ioe1xuICAgIGRlZmF1bHRNb2RpZmllcnM6IGRlZmF1bHRNb2RpZmllcnNcbiAgfSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcblxuICBjb25zdCBQb3BwZXIgPSAvKiNfX1BVUkVfXyovT2JqZWN0LmZyZWV6ZSgvKiNfX1BVUkVfXyovT2JqZWN0LmRlZmluZVByb3BlcnR5KHtcbiAgICBfX3Byb3RvX186IG51bGwsXG4gICAgYWZ0ZXJNYWluLFxuICAgIGFmdGVyUmVhZCxcbiAgICBhZnRlcldyaXRlLFxuICAgIGFwcGx5U3R5bGVzOiBhcHBseVN0eWxlcyQxLFxuICAgIGFycm93OiBhcnJvdyQxLFxuICAgIGF1dG8sXG4gICAgYmFzZVBsYWNlbWVudHMsXG4gICAgYmVmb3JlTWFpbixcbiAgICBiZWZvcmVSZWFkLFxuICAgIGJlZm9yZVdyaXRlLFxuICAgIGJvdHRvbSxcbiAgICBjbGlwcGluZ1BhcmVudHMsXG4gICAgY29tcHV0ZVN0eWxlczogY29tcHV0ZVN0eWxlcyQxLFxuICAgIGNyZWF0ZVBvcHBlcixcbiAgICBjcmVhdGVQb3BwZXJCYXNlOiBjcmVhdGVQb3BwZXIkMixcbiAgICBjcmVhdGVQb3BwZXJMaXRlOiBjcmVhdGVQb3BwZXIkMSxcbiAgICBkZXRlY3RPdmVyZmxvdyxcbiAgICBlbmQsXG4gICAgZXZlbnRMaXN0ZW5lcnMsXG4gICAgZmxpcDogZmxpcCQxLFxuICAgIGhpZGU6IGhpZGUkMSxcbiAgICBsZWZ0LFxuICAgIG1haW4sXG4gICAgbW9kaWZpZXJQaGFzZXMsXG4gICAgb2Zmc2V0OiBvZmZzZXQkMSxcbiAgICBwbGFjZW1lbnRzLFxuICAgIHBvcHBlcixcbiAgICBwb3BwZXJHZW5lcmF0b3IsXG4gICAgcG9wcGVyT2Zmc2V0czogcG9wcGVyT2Zmc2V0cyQxLFxuICAgIHByZXZlbnRPdmVyZmxvdzogcHJldmVudE92ZXJmbG93JDEsXG4gICAgcmVhZCxcbiAgICByZWZlcmVuY2UsXG4gICAgcmlnaHQsXG4gICAgc3RhcnQsXG4gICAgdG9wLFxuICAgIHZhcmlhdGlvblBsYWNlbWVudHMsXG4gICAgdmlld3BvcnQsXG4gICAgd3JpdGVcbiAgfSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KSk7XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEJvb3RzdHJhcCBkcm9wZG93bi5qc1xuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cblxuICAvKipcbiAgICogQ29uc3RhbnRzXG4gICAqL1xuXG4gIGNvbnN0IE5BTUUkYSA9ICdkcm9wZG93bic7XG4gIGNvbnN0IERBVEFfS0VZJDYgPSAnYnMuZHJvcGRvd24nO1xuICBjb25zdCBFVkVOVF9LRVkkNiA9IGAuJHtEQVRBX0tFWSQ2fWA7XG4gIGNvbnN0IERBVEFfQVBJX0tFWSQzID0gJy5kYXRhLWFwaSc7XG4gIGNvbnN0IEVTQ0FQRV9LRVkkMiA9ICdFc2NhcGUnO1xuICBjb25zdCBUQUJfS0VZJDEgPSAnVGFiJztcbiAgY29uc3QgQVJST1dfVVBfS0VZJDEgPSAnQXJyb3dVcCc7XG4gIGNvbnN0IEFSUk9XX0RPV05fS0VZJDEgPSAnQXJyb3dEb3duJztcbiAgY29uc3QgUklHSFRfTU9VU0VfQlVUVE9OID0gMjsgLy8gTW91c2VFdmVudC5idXR0b24gdmFsdWUgZm9yIHRoZSBzZWNvbmRhcnkgYnV0dG9uLCB1c3VhbGx5IHRoZSByaWdodCBidXR0b25cblxuICBjb25zdCBFVkVOVF9ISURFJDUgPSBgaGlkZSR7RVZFTlRfS0VZJDZ9YDtcbiAgY29uc3QgRVZFTlRfSElEREVOJDUgPSBgaGlkZGVuJHtFVkVOVF9LRVkkNn1gO1xuICBjb25zdCBFVkVOVF9TSE9XJDUgPSBgc2hvdyR7RVZFTlRfS0VZJDZ9YDtcbiAgY29uc3QgRVZFTlRfU0hPV04kNSA9IGBzaG93biR7RVZFTlRfS0VZJDZ9YDtcbiAgY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMyA9IGBjbGljayR7RVZFTlRfS0VZJDZ9JHtEQVRBX0FQSV9LRVkkM31gO1xuICBjb25zdCBFVkVOVF9LRVlET1dOX0RBVEFfQVBJID0gYGtleWRvd24ke0VWRU5UX0tFWSQ2fSR7REFUQV9BUElfS0VZJDN9YDtcbiAgY29uc3QgRVZFTlRfS0VZVVBfREFUQV9BUEkgPSBga2V5dXAke0VWRU5UX0tFWSQ2fSR7REFUQV9BUElfS0VZJDN9YDtcbiAgY29uc3QgQ0xBU1NfTkFNRV9TSE9XJDYgPSAnc2hvdyc7XG4gIGNvbnN0IENMQVNTX05BTUVfRFJPUFVQID0gJ2Ryb3B1cCc7XG4gIGNvbnN0IENMQVNTX05BTUVfRFJPUEVORCA9ICdkcm9wZW5kJztcbiAgY29uc3QgQ0xBU1NfTkFNRV9EUk9QU1RBUlQgPSAnZHJvcHN0YXJ0JztcbiAgY29uc3QgQ0xBU1NfTkFNRV9EUk9QVVBfQ0VOVEVSID0gJ2Ryb3B1cC1jZW50ZXInO1xuICBjb25zdCBDTEFTU19OQU1FX0RST1BET1dOX0NFTlRFUiA9ICdkcm9wZG93bi1jZW50ZXInO1xuICBjb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQzID0gJ1tkYXRhLWJzLXRvZ2dsZT1cImRyb3Bkb3duXCJdOm5vdCguZGlzYWJsZWQpOm5vdCg6ZGlzYWJsZWQpJztcbiAgY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEVfU0hPV04gPSBgJHtTRUxFQ1RPUl9EQVRBX1RPR0dMRSQzfS4ke0NMQVNTX05BTUVfU0hPVyQ2fWA7XG4gIGNvbnN0IFNFTEVDVE9SX01FTlUgPSAnLmRyb3Bkb3duLW1lbnUnO1xuICBjb25zdCBTRUxFQ1RPUl9OQVZCQVIgPSAnLm5hdmJhcic7XG4gIGNvbnN0IFNFTEVDVE9SX05BVkJBUl9OQVYgPSAnLm5hdmJhci1uYXYnO1xuICBjb25zdCBTRUxFQ1RPUl9WSVNJQkxFX0lURU1TID0gJy5kcm9wZG93bi1tZW51IC5kcm9wZG93bi1pdGVtOm5vdCguZGlzYWJsZWQpOm5vdCg6ZGlzYWJsZWQpJztcbiAgY29uc3QgUExBQ0VNRU5UX1RPUCA9IGlzUlRMKCkgPyAndG9wLWVuZCcgOiAndG9wLXN0YXJ0JztcbiAgY29uc3QgUExBQ0VNRU5UX1RPUEVORCA9IGlzUlRMKCkgPyAndG9wLXN0YXJ0JyA6ICd0b3AtZW5kJztcbiAgY29uc3QgUExBQ0VNRU5UX0JPVFRPTSA9IGlzUlRMKCkgPyAnYm90dG9tLWVuZCcgOiAnYm90dG9tLXN0YXJ0JztcbiAgY29uc3QgUExBQ0VNRU5UX0JPVFRPTUVORCA9IGlzUlRMKCkgPyAnYm90dG9tLXN0YXJ0JyA6ICdib3R0b20tZW5kJztcbiAgY29uc3QgUExBQ0VNRU5UX1JJR0hUID0gaXNSVEwoKSA/ICdsZWZ0LXN0YXJ0JyA6ICdyaWdodC1zdGFydCc7XG4gIGNvbnN0IFBMQUNFTUVOVF9MRUZUID0gaXNSVEwoKSA/ICdyaWdodC1zdGFydCcgOiAnbGVmdC1zdGFydCc7XG4gIGNvbnN0IFBMQUNFTUVOVF9UT1BDRU5URVIgPSAndG9wJztcbiAgY29uc3QgUExBQ0VNRU5UX0JPVFRPTUNFTlRFUiA9ICdib3R0b20nO1xuICBjb25zdCBEZWZhdWx0JDkgPSB7XG4gICAgYXV0b0Nsb3NlOiB0cnVlLFxuICAgIGJvdW5kYXJ5OiAnY2xpcHBpbmdQYXJlbnRzJyxcbiAgICBkaXNwbGF5OiAnZHluYW1pYycsXG4gICAgb2Zmc2V0OiBbMCwgMl0sXG4gICAgcG9wcGVyQ29uZmlnOiBudWxsLFxuICAgIHJlZmVyZW5jZTogJ3RvZ2dsZSdcbiAgfTtcbiAgY29uc3QgRGVmYXVsdFR5cGUkOSA9IHtcbiAgICBhdXRvQ2xvc2U6ICcoYm9vbGVhbnxzdHJpbmcpJyxcbiAgICBib3VuZGFyeTogJyhzdHJpbmd8ZWxlbWVudCknLFxuICAgIGRpc3BsYXk6ICdzdHJpbmcnLFxuICAgIG9mZnNldDogJyhhcnJheXxzdHJpbmd8ZnVuY3Rpb24pJyxcbiAgICBwb3BwZXJDb25maWc6ICcobnVsbHxvYmplY3R8ZnVuY3Rpb24pJyxcbiAgICByZWZlcmVuY2U6ICcoc3RyaW5nfGVsZW1lbnR8b2JqZWN0KSdcbiAgfTtcblxuICAvKipcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxuICAgKi9cblxuICBjbGFzcyBEcm9wZG93biBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xuICAgICAgc3VwZXIoZWxlbWVudCwgY29uZmlnKTtcbiAgICAgIHRoaXMuX3BvcHBlciA9IG51bGw7XG4gICAgICB0aGlzLl9wYXJlbnQgPSB0aGlzLl9lbGVtZW50LnBhcmVudE5vZGU7IC8vIGRyb3Bkb3duIHdyYXBwZXJcbiAgICAgIC8vIFRPRE86IHY2IHJldmVydCAjMzcwMTEgJiBjaGFuZ2UgbWFya3VwIGh0dHBzOi8vZ2V0Ym9vdHN0cmFwLmNvbS9kb2NzLzUuMy9mb3Jtcy9pbnB1dC1ncm91cC9cbiAgICAgIHRoaXMuX21lbnUgPSBTZWxlY3RvckVuZ2luZS5uZXh0KHRoaXMuX2VsZW1lbnQsIFNFTEVDVE9SX01FTlUpWzBdIHx8IFNlbGVjdG9yRW5naW5lLnByZXYodGhpcy5fZWxlbWVudCwgU0VMRUNUT1JfTUVOVSlbMF0gfHwgU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9NRU5VLCB0aGlzLl9wYXJlbnQpO1xuICAgICAgdGhpcy5faW5OYXZiYXIgPSB0aGlzLl9kZXRlY3ROYXZiYXIoKTtcbiAgICB9XG5cbiAgICAvLyBHZXR0ZXJzXG4gICAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgICAgcmV0dXJuIERlZmF1bHQkOTtcbiAgICB9XG4gICAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICAgIHJldHVybiBEZWZhdWx0VHlwZSQ5O1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgICByZXR1cm4gTkFNRSRhO1xuICAgIH1cblxuICAgIC8vIFB1YmxpY1xuICAgIHRvZ2dsZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pc1Nob3duKCkgPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdygpO1xuICAgIH1cbiAgICBzaG93KCkge1xuICAgICAgaWYgKGlzRGlzYWJsZWQodGhpcy5fZWxlbWVudCkgfHwgdGhpcy5faXNTaG93bigpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlbGF0ZWRUYXJnZXQgPSB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRoaXMuX2VsZW1lbnRcbiAgICAgIH07XG4gICAgICBjb25zdCBzaG93RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XJDUsIHJlbGF0ZWRUYXJnZXQpO1xuICAgICAgaWYgKHNob3dFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHBlcigpO1xuXG4gICAgICAvLyBJZiB0aGlzIGlzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2Ugd2UgYWRkIGV4dHJhXG4gICAgICAvLyBlbXB0eSBtb3VzZW92ZXIgbGlzdGVuZXJzIHRvIHRoZSBib2R5J3MgaW1tZWRpYXRlIGNoaWxkcmVuO1xuICAgICAgLy8gb25seSBuZWVkZWQgYmVjYXVzZSBvZiBicm9rZW4gZXZlbnQgZGVsZWdhdGlvbiBvbiBpT1NcbiAgICAgIC8vIGh0dHBzOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxNC8wMi9tb3VzZV9ldmVudF9idWIuaHRtbFxuICAgICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiAhdGhpcy5fcGFyZW50LmNsb3Nlc3QoU0VMRUNUT1JfTkFWQkFSX05BVikpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKSkge1xuICAgICAgICAgIEV2ZW50SGFuZGxlci5vbihlbGVtZW50LCAnbW91c2VvdmVyJywgbm9vcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2VsZW1lbnQuZm9jdXMoKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSk7XG4gICAgICB0aGlzLl9tZW51LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XJDYpO1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyQ2KTtcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1dOJDUsIHJlbGF0ZWRUYXJnZXQpO1xuICAgIH1cbiAgICBoaWRlKCkge1xuICAgICAgaWYgKGlzRGlzYWJsZWQodGhpcy5fZWxlbWVudCkgfHwgIXRoaXMuX2lzU2hvd24oKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0ge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiB0aGlzLl9lbGVtZW50XG4gICAgICB9O1xuICAgICAgdGhpcy5fY29tcGxldGVIaWRlKHJlbGF0ZWRUYXJnZXQpO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgaWYgKHRoaXMuX3BvcHBlcikge1xuICAgICAgICB0aGlzLl9wb3BwZXIuZGVzdHJveSgpO1xuICAgICAgfVxuICAgICAgc3VwZXIuZGlzcG9zZSgpO1xuICAgIH1cbiAgICB1cGRhdGUoKSB7XG4gICAgICB0aGlzLl9pbk5hdmJhciA9IHRoaXMuX2RldGVjdE5hdmJhcigpO1xuICAgICAgaWYgKHRoaXMuX3BvcHBlcikge1xuICAgICAgICB0aGlzLl9wb3BwZXIudXBkYXRlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUHJpdmF0ZVxuICAgIF9jb21wbGV0ZUhpZGUocmVsYXRlZFRhcmdldCkge1xuICAgICAgY29uc3QgaGlkZUV2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElERSQ1LCByZWxhdGVkVGFyZ2V0KTtcbiAgICAgIGlmIChoaWRlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoaXMgaXMgYSB0b3VjaC1lbmFibGVkIGRldmljZSB3ZSByZW1vdmUgdGhlIGV4dHJhXG4gICAgICAvLyBlbXB0eSBtb3VzZW92ZXIgbGlzdGVuZXJzIHdlIGFkZGVkIGZvciBpT1Mgc3VwcG9ydFxuICAgICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgW10uY29uY2F0KC4uLmRvY3VtZW50LmJvZHkuY2hpbGRyZW4pKSB7XG4gICAgICAgICAgRXZlbnRIYW5kbGVyLm9mZihlbGVtZW50LCAnbW91c2VvdmVyJywgbm9vcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9wb3BwZXIpIHtcbiAgICAgICAgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX21lbnUuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1ckNik7XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDYpO1xuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCAnZmFsc2UnKTtcbiAgICAgIE1hbmlwdWxhdG9yLnJlbW92ZURhdGFBdHRyaWJ1dGUodGhpcy5fbWVudSwgJ3BvcHBlcicpO1xuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElEREVOJDUsIHJlbGF0ZWRUYXJnZXQpO1xuICAgIH1cbiAgICBfZ2V0Q29uZmlnKGNvbmZpZykge1xuICAgICAgY29uZmlnID0gc3VwZXIuX2dldENvbmZpZyhjb25maWcpO1xuICAgICAgaWYgKHR5cGVvZiBjb25maWcucmVmZXJlbmNlID09PSAnb2JqZWN0JyAmJiAhaXNFbGVtZW50JDEoY29uZmlnLnJlZmVyZW5jZSkgJiYgdHlwZW9mIGNvbmZpZy5yZWZlcmVuY2UuZ2V0Qm91bmRpbmdDbGllbnRSZWN0ICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFBvcHBlciB2aXJ0dWFsIGVsZW1lbnRzIHJlcXVpcmUgYSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgbWV0aG9kXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYCR7TkFNRSRhLnRvVXBwZXJDYXNlKCl9OiBPcHRpb24gXCJyZWZlcmVuY2VcIiBwcm92aWRlZCB0eXBlIFwib2JqZWN0XCIgd2l0aG91dCBhIHJlcXVpcmVkIFwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0XCIgbWV0aG9kLmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG4gICAgX2NyZWF0ZVBvcHBlcigpIHtcbiAgICAgIGlmICh0eXBlb2YgUG9wcGVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb290c3RyYXBcXCdzIGRyb3Bkb3ducyByZXF1aXJlIFBvcHBlciAoaHR0cHM6Ly9wb3BwZXIuanMub3JnKScpO1xuICAgICAgfVxuICAgICAgbGV0IHJlZmVyZW5jZUVsZW1lbnQgPSB0aGlzLl9lbGVtZW50O1xuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UgPT09ICdwYXJlbnQnKSB7XG4gICAgICAgIHJlZmVyZW5jZUVsZW1lbnQgPSB0aGlzLl9wYXJlbnQ7XG4gICAgICB9IGVsc2UgaWYgKGlzRWxlbWVudCQxKHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UpKSB7XG4gICAgICAgIHJlZmVyZW5jZUVsZW1lbnQgPSBnZXRFbGVtZW50KHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UpO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdGhpcy5fY29uZmlnLnJlZmVyZW5jZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmVmZXJlbmNlRWxlbWVudCA9IHRoaXMuX2NvbmZpZy5yZWZlcmVuY2U7XG4gICAgICB9XG4gICAgICBjb25zdCBwb3BwZXJDb25maWcgPSB0aGlzLl9nZXRQb3BwZXJDb25maWcoKTtcbiAgICAgIHRoaXMuX3BvcHBlciA9IGNyZWF0ZVBvcHBlcihyZWZlcmVuY2VFbGVtZW50LCB0aGlzLl9tZW51LCBwb3BwZXJDb25maWcpO1xuICAgIH1cbiAgICBfaXNTaG93bigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tZW51LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NIT1ckNik7XG4gICAgfVxuICAgIF9nZXRQbGFjZW1lbnQoKSB7XG4gICAgICBjb25zdCBwYXJlbnREcm9wZG93biA9IHRoaXMuX3BhcmVudDtcbiAgICAgIGlmIChwYXJlbnREcm9wZG93bi5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9EUk9QRU5EKSkge1xuICAgICAgICByZXR1cm4gUExBQ0VNRU5UX1JJR0hUO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudERyb3Bkb3duLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0RST1BTVEFSVCkpIHtcbiAgICAgICAgcmV0dXJuIFBMQUNFTUVOVF9MRUZUO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudERyb3Bkb3duLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0RST1BVUF9DRU5URVIpKSB7XG4gICAgICAgIHJldHVybiBQTEFDRU1FTlRfVE9QQ0VOVEVSO1xuICAgICAgfVxuICAgICAgaWYgKHBhcmVudERyb3Bkb3duLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0RST1BET1dOX0NFTlRFUikpIHtcbiAgICAgICAgcmV0dXJuIFBMQUNFTUVOVF9CT1RUT01DRU5URVI7XG4gICAgICB9XG5cbiAgICAgIC8vIFdlIG5lZWQgdG8gdHJpbSB0aGUgdmFsdWUgYmVjYXVzZSBjdXN0b20gcHJvcGVydGllcyBjYW4gYWxzbyBpbmNsdWRlIHNwYWNlc1xuICAgICAgY29uc3QgaXNFbmQgPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMuX21lbnUpLmdldFByb3BlcnR5VmFsdWUoJy0tYnMtcG9zaXRpb24nKS50cmltKCkgPT09ICdlbmQnO1xuICAgICAgaWYgKHBhcmVudERyb3Bkb3duLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0RST1BVUCkpIHtcbiAgICAgICAgcmV0dXJuIGlzRW5kID8gUExBQ0VNRU5UX1RPUEVORCA6IFBMQUNFTUVOVF9UT1A7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNFbmQgPyBQTEFDRU1FTlRfQk9UVE9NRU5EIDogUExBQ0VNRU5UX0JPVFRPTTtcbiAgICB9XG4gICAgX2RldGVjdE5hdmJhcigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmNsb3Nlc3QoU0VMRUNUT1JfTkFWQkFSKSAhPT0gbnVsbDtcbiAgICB9XG4gICAgX2dldE9mZnNldCgpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgb2Zmc2V0XG4gICAgICB9ID0gdGhpcy5fY29uZmlnO1xuICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBvZmZzZXQuc3BsaXQoJywnKS5tYXAodmFsdWUgPT4gTnVtYmVyLnBhcnNlSW50KHZhbHVlLCAxMCkpO1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHBvcHBlckRhdGEgPT4gb2Zmc2V0KHBvcHBlckRhdGEsIHRoaXMuX2VsZW1lbnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG9mZnNldDtcbiAgICB9XG4gICAgX2dldFBvcHBlckNvbmZpZygpIHtcbiAgICAgIGNvbnN0IGRlZmF1bHRCc1BvcHBlckNvbmZpZyA9IHtcbiAgICAgICAgcGxhY2VtZW50OiB0aGlzLl9nZXRQbGFjZW1lbnQoKSxcbiAgICAgICAgbW9kaWZpZXJzOiBbe1xuICAgICAgICAgIG5hbWU6ICdwcmV2ZW50T3ZlcmZsb3cnLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGJvdW5kYXJ5OiB0aGlzLl9jb25maWcuYm91bmRhcnlcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiAnb2Zmc2V0JyxcbiAgICAgICAgICBvcHRpb25zOiB7XG4gICAgICAgICAgICBvZmZzZXQ6IHRoaXMuX2dldE9mZnNldCgpXG4gICAgICAgICAgfVxuICAgICAgICB9XVxuICAgICAgfTtcblxuICAgICAgLy8gRGlzYWJsZSBQb3BwZXIgaWYgd2UgaGF2ZSBhIHN0YXRpYyBkaXNwbGF5IG9yIERyb3Bkb3duIGlzIGluIE5hdmJhclxuICAgICAgaWYgKHRoaXMuX2luTmF2YmFyIHx8IHRoaXMuX2NvbmZpZy5kaXNwbGF5ID09PSAnc3RhdGljJykge1xuICAgICAgICBNYW5pcHVsYXRvci5zZXREYXRhQXR0cmlidXRlKHRoaXMuX21lbnUsICdwb3BwZXInLCAnc3RhdGljJyk7IC8vIFRPRE86IHY2IHJlbW92ZVxuICAgICAgICBkZWZhdWx0QnNQb3BwZXJDb25maWcubW9kaWZpZXJzID0gW3tcbiAgICAgICAgICBuYW1lOiAnYXBwbHlTdHlsZXMnLFxuICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlXG4gICAgICAgIH1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4uZGVmYXVsdEJzUG9wcGVyQ29uZmlnLFxuICAgICAgICAuLi5leGVjdXRlKHRoaXMuX2NvbmZpZy5wb3BwZXJDb25maWcsIFtkZWZhdWx0QnNQb3BwZXJDb25maWddKVxuICAgICAgfTtcbiAgICB9XG4gICAgX3NlbGVjdE1lbnVJdGVtKHtcbiAgICAgIGtleSxcbiAgICAgIHRhcmdldFxuICAgIH0pIHtcbiAgICAgIGNvbnN0IGl0ZW1zID0gU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9WSVNJQkxFX0lURU1TLCB0aGlzLl9tZW51KS5maWx0ZXIoZWxlbWVudCA9PiBpc1Zpc2libGUoZWxlbWVudCkpO1xuICAgICAgaWYgKCFpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBpZiB0YXJnZXQgaXNuJ3QgaW5jbHVkZWQgaW4gaXRlbXMgKGUuZy4gd2hlbiBleHBhbmRpbmcgdGhlIGRyb3Bkb3duKVxuICAgICAgLy8gYWxsb3cgY3ljbGluZyB0byBnZXQgdGhlIGxhc3QgaXRlbSBpbiBjYXNlIGtleSBlcXVhbHMgQVJST1dfVVBfS0VZXG4gICAgICBnZXROZXh0QWN0aXZlRWxlbWVudChpdGVtcywgdGFyZ2V0LCBrZXkgPT09IEFSUk9XX0RPV05fS0VZJDEsICFpdGVtcy5pbmNsdWRlcyh0YXJnZXQpKS5mb2N1cygpO1xuICAgIH1cblxuICAgIC8vIFN0YXRpY1xuICAgIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IERyb3Bkb3duLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgY29uZmlnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtjb25maWddKCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGNsZWFyTWVudXMoZXZlbnQpIHtcbiAgICAgIGlmIChldmVudC5idXR0b24gPT09IFJJR0hUX01PVVNFX0JVVFRPTiB8fCBldmVudC50eXBlID09PSAna2V5dXAnICYmIGV2ZW50LmtleSAhPT0gVEFCX0tFWSQxKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG9wZW5Ub2dnbGVzID0gU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9EQVRBX1RPR0dMRV9TSE9XTik7XG4gICAgICBmb3IgKGNvbnN0IHRvZ2dsZSBvZiBvcGVuVG9nZ2xlcykge1xuICAgICAgICBjb25zdCBjb250ZXh0ID0gRHJvcGRvd24uZ2V0SW5zdGFuY2UodG9nZ2xlKTtcbiAgICAgICAgaWYgKCFjb250ZXh0IHx8IGNvbnRleHQuX2NvbmZpZy5hdXRvQ2xvc2UgPT09IGZhbHNlKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29tcG9zZWRQYXRoID0gZXZlbnQuY29tcG9zZWRQYXRoKCk7XG4gICAgICAgIGNvbnN0IGlzTWVudVRhcmdldCA9IGNvbXBvc2VkUGF0aC5pbmNsdWRlcyhjb250ZXh0Ll9tZW51KTtcbiAgICAgICAgaWYgKGNvbXBvc2VkUGF0aC5pbmNsdWRlcyhjb250ZXh0Ll9lbGVtZW50KSB8fCBjb250ZXh0Ll9jb25maWcuYXV0b0Nsb3NlID09PSAnaW5zaWRlJyAmJiAhaXNNZW51VGFyZ2V0IHx8IGNvbnRleHQuX2NvbmZpZy5hdXRvQ2xvc2UgPT09ICdvdXRzaWRlJyAmJiBpc01lbnVUYXJnZXQpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFRhYiBuYXZpZ2F0aW9uIHRocm91Z2ggdGhlIGRyb3Bkb3duIG1lbnUgb3IgZXZlbnRzIGZyb20gY29udGFpbmVkIGlucHV0cyBzaG91bGRuJ3QgY2xvc2UgdGhlIG1lbnVcbiAgICAgICAgaWYgKGNvbnRleHQuX21lbnUuY29udGFpbnMoZXZlbnQudGFyZ2V0KSAmJiAoZXZlbnQudHlwZSA9PT0gJ2tleXVwJyAmJiBldmVudC5rZXkgPT09IFRBQl9LRVkkMSB8fCAvaW5wdXR8c2VsZWN0fG9wdGlvbnx0ZXh0YXJlYXxmb3JtL2kudGVzdChldmVudC50YXJnZXQudGFnTmFtZSkpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVsYXRlZFRhcmdldCA9IHtcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0OiBjb250ZXh0Ll9lbGVtZW50XG4gICAgICAgIH07XG4gICAgICAgIGlmIChldmVudC50eXBlID09PSAnY2xpY2snKSB7XG4gICAgICAgICAgcmVsYXRlZFRhcmdldC5jbGlja0V2ZW50ID0gZXZlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY29udGV4dC5fY29tcGxldGVIaWRlKHJlbGF0ZWRUYXJnZXQpO1xuICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgZGF0YUFwaUtleWRvd25IYW5kbGVyKGV2ZW50KSB7XG4gICAgICAvLyBJZiBub3QgYW4gVVAgfCBET1dOIHwgRVNDQVBFIGtleSA9PiBub3QgYSBkcm9wZG93biBjb21tYW5kXG4gICAgICAvLyBJZiBpbnB1dC90ZXh0YXJlYSAmJiBpZiBrZXkgaXMgb3RoZXIgdGhhbiBFU0NBUEUgPT4gbm90IGEgZHJvcGRvd24gY29tbWFuZFxuXG4gICAgICBjb25zdCBpc0lucHV0ID0gL2lucHV0fHRleHRhcmVhL2kudGVzdChldmVudC50YXJnZXQudGFnTmFtZSk7XG4gICAgICBjb25zdCBpc0VzY2FwZUV2ZW50ID0gZXZlbnQua2V5ID09PSBFU0NBUEVfS0VZJDI7XG4gICAgICBjb25zdCBpc1VwT3JEb3duRXZlbnQgPSBbQVJST1dfVVBfS0VZJDEsIEFSUk9XX0RPV05fS0VZJDFdLmluY2x1ZGVzKGV2ZW50LmtleSk7XG4gICAgICBpZiAoIWlzVXBPckRvd25FdmVudCAmJiAhaXNFc2NhcGVFdmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNJbnB1dCAmJiAhaXNFc2NhcGVFdmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgICAvLyBUT0RPOiB2NiByZXZlcnQgIzM3MDExICYgY2hhbmdlIG1hcmt1cCBodHRwczovL2dldGJvb3RzdHJhcC5jb20vZG9jcy81LjMvZm9ybXMvaW5wdXQtZ3JvdXAvXG4gICAgICBjb25zdCBnZXRUb2dnbGVCdXR0b24gPSB0aGlzLm1hdGNoZXMoU0VMRUNUT1JfREFUQV9UT0dHTEUkMykgPyB0aGlzIDogU2VsZWN0b3JFbmdpbmUucHJldih0aGlzLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQzKVswXSB8fCBTZWxlY3RvckVuZ2luZS5uZXh0KHRoaXMsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDMpWzBdIHx8IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfREFUQV9UT0dHTEUkMywgZXZlbnQuZGVsZWdhdGVUYXJnZXQucGFyZW50Tm9kZSk7XG4gICAgICBjb25zdCBpbnN0YW5jZSA9IERyb3Bkb3duLmdldE9yQ3JlYXRlSW5zdGFuY2UoZ2V0VG9nZ2xlQnV0dG9uKTtcbiAgICAgIGlmIChpc1VwT3JEb3duRXZlbnQpIHtcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgICAgIGluc3RhbmNlLnNob3coKTtcbiAgICAgICAgaW5zdGFuY2UuX3NlbGVjdE1lbnVJdGVtKGV2ZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGluc3RhbmNlLl9pc1Nob3duKCkpIHtcbiAgICAgICAgLy8gZWxzZSBpcyBlc2NhcGUgYW5kIHdlIGNoZWNrIGlmIGl0IGlzIHNob3duXG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICBpbnN0YW5jZS5oaWRlKCk7XG4gICAgICAgIGdldFRvZ2dsZUJ1dHRvbi5mb2N1cygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxuICAgKi9cblxuICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0tFWURPV05fREFUQV9BUEksIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDMsIERyb3Bkb3duLmRhdGFBcGlLZXlkb3duSGFuZGxlcik7XG4gIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfS0VZRE9XTl9EQVRBX0FQSSwgU0VMRUNUT1JfTUVOVSwgRHJvcGRvd24uZGF0YUFwaUtleWRvd25IYW5kbGVyKTtcbiAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSQzLCBEcm9wZG93bi5jbGVhck1lbnVzKTtcbiAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9LRVlVUF9EQVRBX0FQSSwgRHJvcGRvd24uY2xlYXJNZW51cyk7XG4gIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMywgU0VMRUNUT1JfREFUQV9UT0dHTEUkMywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBEcm9wZG93bi5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpLnRvZ2dsZSgpO1xuICB9KTtcblxuICAvKipcbiAgICogalF1ZXJ5XG4gICAqL1xuXG4gIGRlZmluZUpRdWVyeVBsdWdpbihEcm9wZG93bik7XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEJvb3RzdHJhcCB1dGlsL2JhY2tkcm9wLmpzXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuXG4gIC8qKlxuICAgKiBDb25zdGFudHNcbiAgICovXG5cbiAgY29uc3QgTkFNRSQ5ID0gJ2JhY2tkcm9wJztcbiAgY29uc3QgQ0xBU1NfTkFNRV9GQURFJDQgPSAnZmFkZSc7XG4gIGNvbnN0IENMQVNTX05BTUVfU0hPVyQ1ID0gJ3Nob3cnO1xuICBjb25zdCBFVkVOVF9NT1VTRURPV04gPSBgbW91c2Vkb3duLmJzLiR7TkFNRSQ5fWA7XG4gIGNvbnN0IERlZmF1bHQkOCA9IHtcbiAgICBjbGFzc05hbWU6ICdtb2RhbC1iYWNrZHJvcCcsXG4gICAgY2xpY2tDYWxsYmFjazogbnVsbCxcbiAgICBpc0FuaW1hdGVkOiBmYWxzZSxcbiAgICBpc1Zpc2libGU6IHRydWUsXG4gICAgLy8gaWYgZmFsc2UsIHdlIHVzZSB0aGUgYmFja2Ryb3AgaGVscGVyIHdpdGhvdXQgYWRkaW5nIGFueSBlbGVtZW50IHRvIHRoZSBkb21cbiAgICByb290RWxlbWVudDogJ2JvZHknIC8vIGdpdmUgdGhlIGNob2ljZSB0byBwbGFjZSBiYWNrZHJvcCB1bmRlciBkaWZmZXJlbnQgZWxlbWVudHNcbiAgfTtcbiAgY29uc3QgRGVmYXVsdFR5cGUkOCA9IHtcbiAgICBjbGFzc05hbWU6ICdzdHJpbmcnLFxuICAgIGNsaWNrQ2FsbGJhY2s6ICcoZnVuY3Rpb258bnVsbCknLFxuICAgIGlzQW5pbWF0ZWQ6ICdib29sZWFuJyxcbiAgICBpc1Zpc2libGU6ICdib29sZWFuJyxcbiAgICByb290RWxlbWVudDogJyhlbGVtZW50fHN0cmluZyknXG4gIH07XG5cbiAgLyoqXG4gICAqIENsYXNzIGRlZmluaXRpb25cbiAgICovXG5cbiAgY2xhc3MgQmFja2Ryb3AgZXh0ZW5kcyBDb25maWcge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xuICAgICAgdGhpcy5faXNBcHBlbmRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fZWxlbWVudCA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gR2V0dGVyc1xuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiBEZWZhdWx0JDg7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdFR5cGUkODtcbiAgICB9XG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgICAgcmV0dXJuIE5BTUUkOTtcbiAgICB9XG5cbiAgICAvLyBQdWJsaWNcbiAgICBzaG93KGNhbGxiYWNrKSB7XG4gICAgICBpZiAoIXRoaXMuX2NvbmZpZy5pc1Zpc2libGUpIHtcbiAgICAgICAgZXhlY3V0ZShjYWxsYmFjayk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2FwcGVuZCgpO1xuICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2dldEVsZW1lbnQoKTtcbiAgICAgIGlmICh0aGlzLl9jb25maWcuaXNBbmltYXRlZCkge1xuICAgICAgICByZWZsb3coZWxlbWVudCk7XG4gICAgICB9XG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XJDUpO1xuICAgICAgdGhpcy5fZW11bGF0ZUFuaW1hdGlvbigoKSA9PiB7XG4gICAgICAgIGV4ZWN1dGUoY2FsbGJhY2spO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGhpZGUoY2FsbGJhY2spIHtcbiAgICAgIGlmICghdGhpcy5fY29uZmlnLmlzVmlzaWJsZSkge1xuICAgICAgICBleGVjdXRlKGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fZ2V0RWxlbWVudCgpLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDUpO1xuICAgICAgdGhpcy5fZW11bGF0ZUFuaW1hdGlvbigoKSA9PiB7XG4gICAgICAgIHRoaXMuZGlzcG9zZSgpO1xuICAgICAgICBleGVjdXRlKGNhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBkaXNwb3NlKCkge1xuICAgICAgaWYgKCF0aGlzLl9pc0FwcGVuZGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIEV2ZW50SGFuZGxlci5vZmYodGhpcy5fZWxlbWVudCwgRVZFTlRfTU9VU0VET1dOKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlKCk7XG4gICAgICB0aGlzLl9pc0FwcGVuZGVkID0gZmFsc2U7XG4gICAgfVxuXG4gICAgLy8gUHJpdmF0ZVxuICAgIF9nZXRFbGVtZW50KCkge1xuICAgICAgaWYgKCF0aGlzLl9lbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IGJhY2tkcm9wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgIGJhY2tkcm9wLmNsYXNzTmFtZSA9IHRoaXMuX2NvbmZpZy5jbGFzc05hbWU7XG4gICAgICAgIGlmICh0aGlzLl9jb25maWcuaXNBbmltYXRlZCkge1xuICAgICAgICAgIGJhY2tkcm9wLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9GQURFJDQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBiYWNrZHJvcDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50O1xuICAgIH1cbiAgICBfY29uZmlnQWZ0ZXJNZXJnZShjb25maWcpIHtcbiAgICAgIC8vIHVzZSBnZXRFbGVtZW50KCkgd2l0aCB0aGUgZGVmYXVsdCBcImJvZHlcIiB0byBnZXQgYSBmcmVzaCBFbGVtZW50IG9uIGVhY2ggaW5zdGFudGlhdGlvblxuICAgICAgY29uZmlnLnJvb3RFbGVtZW50ID0gZ2V0RWxlbWVudChjb25maWcucm9vdEVsZW1lbnQpO1xuICAgICAgcmV0dXJuIGNvbmZpZztcbiAgICB9XG4gICAgX2FwcGVuZCgpIHtcbiAgICAgIGlmICh0aGlzLl9pc0FwcGVuZGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9nZXRFbGVtZW50KCk7XG4gICAgICB0aGlzLl9jb25maWcucm9vdEVsZW1lbnQuYXBwZW5kKGVsZW1lbnQpO1xuICAgICAgRXZlbnRIYW5kbGVyLm9uKGVsZW1lbnQsIEVWRU5UX01PVVNFRE9XTiwgKCkgPT4ge1xuICAgICAgICBleGVjdXRlKHRoaXMuX2NvbmZpZy5jbGlja0NhbGxiYWNrKTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5faXNBcHBlbmRlZCA9IHRydWU7XG4gICAgfVxuICAgIF9lbXVsYXRlQW5pbWF0aW9uKGNhbGxiYWNrKSB7XG4gICAgICBleGVjdXRlQWZ0ZXJUcmFuc2l0aW9uKGNhbGxiYWNrLCB0aGlzLl9nZXRFbGVtZW50KCksIHRoaXMuX2NvbmZpZy5pc0FuaW1hdGVkKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQm9vdHN0cmFwIHV0aWwvZm9jdXN0cmFwLmpzXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuXG4gIC8qKlxuICAgKiBDb25zdGFudHNcbiAgICovXG5cbiAgY29uc3QgTkFNRSQ4ID0gJ2ZvY3VzdHJhcCc7XG4gIGNvbnN0IERBVEFfS0VZJDUgPSAnYnMuZm9jdXN0cmFwJztcbiAgY29uc3QgRVZFTlRfS0VZJDUgPSBgLiR7REFUQV9LRVkkNX1gO1xuICBjb25zdCBFVkVOVF9GT0NVU0lOJDIgPSBgZm9jdXNpbiR7RVZFTlRfS0VZJDV9YDtcbiAgY29uc3QgRVZFTlRfS0VZRE9XTl9UQUIgPSBga2V5ZG93bi50YWIke0VWRU5UX0tFWSQ1fWA7XG4gIGNvbnN0IFRBQl9LRVkgPSAnVGFiJztcbiAgY29uc3QgVEFCX05BVl9GT1JXQVJEID0gJ2ZvcndhcmQnO1xuICBjb25zdCBUQUJfTkFWX0JBQ0tXQVJEID0gJ2JhY2t3YXJkJztcbiAgY29uc3QgRGVmYXVsdCQ3ID0ge1xuICAgIGF1dG9mb2N1czogdHJ1ZSxcbiAgICB0cmFwRWxlbWVudDogbnVsbCAvLyBUaGUgZWxlbWVudCB0byB0cmFwIGZvY3VzIGluc2lkZSBvZlxuICB9O1xuICBjb25zdCBEZWZhdWx0VHlwZSQ3ID0ge1xuICAgIGF1dG9mb2N1czogJ2Jvb2xlYW4nLFxuICAgIHRyYXBFbGVtZW50OiAnZWxlbWVudCdcbiAgfTtcblxuICAvKipcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxuICAgKi9cblxuICBjbGFzcyBGb2N1c1RyYXAgZXh0ZW5kcyBDb25maWcge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xuICAgICAgdGhpcy5faXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgIHRoaXMuX2xhc3RUYWJOYXZEaXJlY3Rpb24gPSBudWxsO1xuICAgIH1cblxuICAgIC8vIEdldHRlcnNcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdCQ3O1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlJDc7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICAgIHJldHVybiBOQU1FJDg7XG4gICAgfVxuXG4gICAgLy8gUHVibGljXG4gICAgYWN0aXZhdGUoKSB7XG4gICAgICBpZiAodGhpcy5faXNBY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5hdXRvZm9jdXMpIHtcbiAgICAgICAgdGhpcy5fY29uZmlnLnRyYXBFbGVtZW50LmZvY3VzKCk7XG4gICAgICB9XG4gICAgICBFdmVudEhhbmRsZXIub2ZmKGRvY3VtZW50LCBFVkVOVF9LRVkkNSk7IC8vIGd1YXJkIGFnYWluc3QgaW5maW5pdGUgZm9jdXMgbG9vcFxuICAgICAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9GT0NVU0lOJDIsIGV2ZW50ID0+IHRoaXMuX2hhbmRsZUZvY3VzaW4oZXZlbnQpKTtcbiAgICAgIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfS0VZRE9XTl9UQUIsIGV2ZW50ID0+IHRoaXMuX2hhbmRsZUtleWRvd24oZXZlbnQpKTtcbiAgICAgIHRoaXMuX2lzQWN0aXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgZGVhY3RpdmF0ZSgpIHtcbiAgICAgIGlmICghdGhpcy5faXNBY3RpdmUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5faXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgIEV2ZW50SGFuZGxlci5vZmYoZG9jdW1lbnQsIEVWRU5UX0tFWSQ1KTtcbiAgICB9XG5cbiAgICAvLyBQcml2YXRlXG4gICAgX2hhbmRsZUZvY3VzaW4oZXZlbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgdHJhcEVsZW1lbnRcbiAgICAgIH0gPSB0aGlzLl9jb25maWc7XG4gICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSBkb2N1bWVudCB8fCBldmVudC50YXJnZXQgPT09IHRyYXBFbGVtZW50IHx8IHRyYXBFbGVtZW50LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgZWxlbWVudHMgPSBTZWxlY3RvckVuZ2luZS5mb2N1c2FibGVDaGlsZHJlbih0cmFwRWxlbWVudCk7XG4gICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRyYXBFbGVtZW50LmZvY3VzKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuX2xhc3RUYWJOYXZEaXJlY3Rpb24gPT09IFRBQl9OQVZfQkFDS1dBUkQpIHtcbiAgICAgICAgZWxlbWVudHNbZWxlbWVudHMubGVuZ3RoIC0gMV0uZm9jdXMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnRzWzBdLmZvY3VzKCk7XG4gICAgICB9XG4gICAgfVxuICAgIF9oYW5kbGVLZXlkb3duKGV2ZW50KSB7XG4gICAgICBpZiAoZXZlbnQua2V5ICE9PSBUQUJfS0VZKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2xhc3RUYWJOYXZEaXJlY3Rpb24gPSBldmVudC5zaGlmdEtleSA/IFRBQl9OQVZfQkFDS1dBUkQgOiBUQUJfTkFWX0ZPUldBUkQ7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEJvb3RzdHJhcCB1dGlsL3Njcm9sbEJhci5qc1xuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cblxuICAvKipcbiAgICogQ29uc3RhbnRzXG4gICAqL1xuXG4gIGNvbnN0IFNFTEVDVE9SX0ZJWEVEX0NPTlRFTlQgPSAnLmZpeGVkLXRvcCwgLmZpeGVkLWJvdHRvbSwgLmlzLWZpeGVkLCAuc3RpY2t5LXRvcCc7XG4gIGNvbnN0IFNFTEVDVE9SX1NUSUNLWV9DT05URU5UID0gJy5zdGlja3ktdG9wJztcbiAgY29uc3QgUFJPUEVSVFlfUEFERElORyA9ICdwYWRkaW5nLXJpZ2h0JztcbiAgY29uc3QgUFJPUEVSVFlfTUFSR0lOID0gJ21hcmdpbi1yaWdodCc7XG5cbiAgLyoqXG4gICAqIENsYXNzIGRlZmluaXRpb25cbiAgICovXG5cbiAgY2xhc3MgU2Nyb2xsQmFySGVscGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBkb2N1bWVudC5ib2R5O1xuICAgIH1cblxuICAgIC8vIFB1YmxpY1xuICAgIGdldFdpZHRoKCkge1xuICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1dpbmRvdy9pbm5lcldpZHRoI3VzYWdlX25vdGVzXG4gICAgICBjb25zdCBkb2N1bWVudFdpZHRoID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudFdpZHRoO1xuICAgICAgcmV0dXJuIE1hdGguYWJzKHdpbmRvdy5pbm5lcldpZHRoIC0gZG9jdW1lbnRXaWR0aCk7XG4gICAgfVxuICAgIGhpZGUoKSB7XG4gICAgICBjb25zdCB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcbiAgICAgIHRoaXMuX2Rpc2FibGVPdmVyRmxvdygpO1xuICAgICAgLy8gZ2l2ZSBwYWRkaW5nIHRvIGVsZW1lbnQgdG8gYmFsYW5jZSB0aGUgaGlkZGVuIHNjcm9sbGJhciB3aWR0aFxuICAgICAgdGhpcy5fc2V0RWxlbWVudEF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCwgUFJPUEVSVFlfUEFERElORywgY2FsY3VsYXRlZFZhbHVlID0+IGNhbGN1bGF0ZWRWYWx1ZSArIHdpZHRoKTtcbiAgICAgIC8vIHRyaWNrOiBXZSBhZGp1c3QgcG9zaXRpdmUgcGFkZGluZ1JpZ2h0IGFuZCBuZWdhdGl2ZSBtYXJnaW5SaWdodCB0byBzdGlja3ktdG9wIGVsZW1lbnRzIHRvIGtlZXAgc2hvd2luZyBmdWxsd2lkdGhcbiAgICAgIHRoaXMuX3NldEVsZW1lbnRBdHRyaWJ1dGVzKFNFTEVDVE9SX0ZJWEVEX0NPTlRFTlQsIFBST1BFUlRZX1BBRERJTkcsIGNhbGN1bGF0ZWRWYWx1ZSA9PiBjYWxjdWxhdGVkVmFsdWUgKyB3aWR0aCk7XG4gICAgICB0aGlzLl9zZXRFbGVtZW50QXR0cmlidXRlcyhTRUxFQ1RPUl9TVElDS1lfQ09OVEVOVCwgUFJPUEVSVFlfTUFSR0lOLCBjYWxjdWxhdGVkVmFsdWUgPT4gY2FsY3VsYXRlZFZhbHVlIC0gd2lkdGgpO1xuICAgIH1cbiAgICByZXNldCgpIHtcbiAgICAgIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCwgJ292ZXJmbG93Jyk7XG4gICAgICB0aGlzLl9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQsIFBST1BFUlRZX1BBRERJTkcpO1xuICAgICAgdGhpcy5fcmVzZXRFbGVtZW50QXR0cmlidXRlcyhTRUxFQ1RPUl9GSVhFRF9DT05URU5ULCBQUk9QRVJUWV9QQURESU5HKTtcbiAgICAgIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXMoU0VMRUNUT1JfU1RJQ0tZX0NPTlRFTlQsIFBST1BFUlRZX01BUkdJTik7XG4gICAgfVxuICAgIGlzT3ZlcmZsb3dpbmcoKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRXaWR0aCgpID4gMDtcbiAgICB9XG5cbiAgICAvLyBQcml2YXRlXG4gICAgX2Rpc2FibGVPdmVyRmxvdygpIHtcbiAgICAgIHRoaXMuX3NhdmVJbml0aWFsQXR0cmlidXRlKHRoaXMuX2VsZW1lbnQsICdvdmVyZmxvdycpO1xuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xuICAgIH1cbiAgICBfc2V0RWxlbWVudEF0dHJpYnV0ZXMoc2VsZWN0b3IsIHN0eWxlUHJvcGVydHksIGNhbGxiYWNrKSB7XG4gICAgICBjb25zdCBzY3JvbGxiYXJXaWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcbiAgICAgIGNvbnN0IG1hbmlwdWxhdGlvbkNhbGxCYWNrID0gZWxlbWVudCA9PiB7XG4gICAgICAgIGlmIChlbGVtZW50ICE9PSB0aGlzLl9lbGVtZW50ICYmIHdpbmRvdy5pbm5lcldpZHRoID4gZWxlbWVudC5jbGllbnRXaWR0aCArIHNjcm9sbGJhcldpZHRoKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NhdmVJbml0aWFsQXR0cmlidXRlKGVsZW1lbnQsIHN0eWxlUHJvcGVydHkpO1xuICAgICAgICBjb25zdCBjYWxjdWxhdGVkVmFsdWUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKHN0eWxlUHJvcGVydHkpO1xuICAgICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KHN0eWxlUHJvcGVydHksIGAke2NhbGxiYWNrKE51bWJlci5wYXJzZUZsb2F0KGNhbGN1bGF0ZWRWYWx1ZSkpfXB4YCk7XG4gICAgICB9O1xuICAgICAgdGhpcy5fYXBwbHlNYW5pcHVsYXRpb25DYWxsYmFjayhzZWxlY3RvciwgbWFuaXB1bGF0aW9uQ2FsbEJhY2spO1xuICAgIH1cbiAgICBfc2F2ZUluaXRpYWxBdHRyaWJ1dGUoZWxlbWVudCwgc3R5bGVQcm9wZXJ0eSkge1xuICAgICAgY29uc3QgYWN0dWFsVmFsdWUgPSBlbGVtZW50LnN0eWxlLmdldFByb3BlcnR5VmFsdWUoc3R5bGVQcm9wZXJ0eSk7XG4gICAgICBpZiAoYWN0dWFsVmFsdWUpIHtcbiAgICAgICAgTWFuaXB1bGF0b3Iuc2V0RGF0YUF0dHJpYnV0ZShlbGVtZW50LCBzdHlsZVByb3BlcnR5LCBhY3R1YWxWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIF9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzKHNlbGVjdG9yLCBzdHlsZVByb3BlcnR5KSB7XG4gICAgICBjb25zdCBtYW5pcHVsYXRpb25DYWxsQmFjayA9IGVsZW1lbnQgPT4ge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IE1hbmlwdWxhdG9yLmdldERhdGFBdHRyaWJ1dGUoZWxlbWVudCwgc3R5bGVQcm9wZXJ0eSk7XG4gICAgICAgIC8vIFdlIG9ubHkgd2FudCB0byByZW1vdmUgdGhlIHByb3BlcnR5IGlmIHRoZSB2YWx1ZSBpcyBgbnVsbGA7IHRoZSB2YWx1ZSBjYW4gYWxzbyBiZSB6ZXJvXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGVsZW1lbnQuc3R5bGUucmVtb3ZlUHJvcGVydHkoc3R5bGVQcm9wZXJ0eSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIE1hbmlwdWxhdG9yLnJlbW92ZURhdGFBdHRyaWJ1dGUoZWxlbWVudCwgc3R5bGVQcm9wZXJ0eSk7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoc3R5bGVQcm9wZXJ0eSwgdmFsdWUpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuX2FwcGx5TWFuaXB1bGF0aW9uQ2FsbGJhY2soc2VsZWN0b3IsIG1hbmlwdWxhdGlvbkNhbGxCYWNrKTtcbiAgICB9XG4gICAgX2FwcGx5TWFuaXB1bGF0aW9uQ2FsbGJhY2soc2VsZWN0b3IsIGNhbGxCYWNrKSB7XG4gICAgICBpZiAoaXNFbGVtZW50JDEoc2VsZWN0b3IpKSB7XG4gICAgICAgIGNhbGxCYWNrKHNlbGVjdG9yKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBzZWwgb2YgU2VsZWN0b3JFbmdpbmUuZmluZChzZWxlY3RvciwgdGhpcy5fZWxlbWVudCkpIHtcbiAgICAgICAgY2FsbEJhY2soc2VsKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQm9vdHN0cmFwIG1vZGFsLmpzXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuXG4gIC8qKlxuICAgKiBDb25zdGFudHNcbiAgICovXG5cbiAgY29uc3QgTkFNRSQ3ID0gJ21vZGFsJztcbiAgY29uc3QgREFUQV9LRVkkNCA9ICdicy5tb2RhbCc7XG4gIGNvbnN0IEVWRU5UX0tFWSQ0ID0gYC4ke0RBVEFfS0VZJDR9YDtcbiAgY29uc3QgREFUQV9BUElfS0VZJDIgPSAnLmRhdGEtYXBpJztcbiAgY29uc3QgRVNDQVBFX0tFWSQxID0gJ0VzY2FwZSc7XG4gIGNvbnN0IEVWRU5UX0hJREUkNCA9IGBoaWRlJHtFVkVOVF9LRVkkNH1gO1xuICBjb25zdCBFVkVOVF9ISURFX1BSRVZFTlRFRCQxID0gYGhpZGVQcmV2ZW50ZWQke0VWRU5UX0tFWSQ0fWA7XG4gIGNvbnN0IEVWRU5UX0hJRERFTiQ0ID0gYGhpZGRlbiR7RVZFTlRfS0VZJDR9YDtcbiAgY29uc3QgRVZFTlRfU0hPVyQ0ID0gYHNob3cke0VWRU5UX0tFWSQ0fWA7XG4gIGNvbnN0IEVWRU5UX1NIT1dOJDQgPSBgc2hvd24ke0VWRU5UX0tFWSQ0fWA7XG4gIGNvbnN0IEVWRU5UX1JFU0laRSQxID0gYHJlc2l6ZSR7RVZFTlRfS0VZJDR9YDtcbiAgY29uc3QgRVZFTlRfQ0xJQ0tfRElTTUlTUyA9IGBjbGljay5kaXNtaXNzJHtFVkVOVF9LRVkkNH1gO1xuICBjb25zdCBFVkVOVF9NT1VTRURPV05fRElTTUlTUyA9IGBtb3VzZWRvd24uZGlzbWlzcyR7RVZFTlRfS0VZJDR9YDtcbiAgY29uc3QgRVZFTlRfS0VZRE9XTl9ESVNNSVNTJDEgPSBga2V5ZG93bi5kaXNtaXNzJHtFVkVOVF9LRVkkNH1gO1xuICBjb25zdCBFVkVOVF9DTElDS19EQVRBX0FQSSQyID0gYGNsaWNrJHtFVkVOVF9LRVkkNH0ke0RBVEFfQVBJX0tFWSQyfWA7XG4gIGNvbnN0IENMQVNTX05BTUVfT1BFTiA9ICdtb2RhbC1vcGVuJztcbiAgY29uc3QgQ0xBU1NfTkFNRV9GQURFJDMgPSAnZmFkZSc7XG4gIGNvbnN0IENMQVNTX05BTUVfU0hPVyQ0ID0gJ3Nob3cnO1xuICBjb25zdCBDTEFTU19OQU1FX1NUQVRJQyA9ICdtb2RhbC1zdGF0aWMnO1xuICBjb25zdCBPUEVOX1NFTEVDVE9SJDEgPSAnLm1vZGFsLnNob3cnO1xuICBjb25zdCBTRUxFQ1RPUl9ESUFMT0cgPSAnLm1vZGFsLWRpYWxvZyc7XG4gIGNvbnN0IFNFTEVDVE9SX01PREFMX0JPRFkgPSAnLm1vZGFsLWJvZHknO1xuICBjb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQyID0gJ1tkYXRhLWJzLXRvZ2dsZT1cIm1vZGFsXCJdJztcbiAgY29uc3QgRGVmYXVsdCQ2ID0ge1xuICAgIGJhY2tkcm9wOiB0cnVlLFxuICAgIGZvY3VzOiB0cnVlLFxuICAgIGtleWJvYXJkOiB0cnVlXG4gIH07XG4gIGNvbnN0IERlZmF1bHRUeXBlJDYgPSB7XG4gICAgYmFja2Ryb3A6ICcoYm9vbGVhbnxzdHJpbmcpJyxcbiAgICBmb2N1czogJ2Jvb2xlYW4nLFxuICAgIGtleWJvYXJkOiAnYm9vbGVhbidcbiAgfTtcblxuICAvKipcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxuICAgKi9cblxuICBjbGFzcyBNb2RhbCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xuICAgICAgc3VwZXIoZWxlbWVudCwgY29uZmlnKTtcbiAgICAgIHRoaXMuX2RpYWxvZyA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfRElBTE9HLCB0aGlzLl9lbGVtZW50KTtcbiAgICAgIHRoaXMuX2JhY2tkcm9wID0gdGhpcy5faW5pdGlhbGl6ZUJhY2tEcm9wKCk7XG4gICAgICB0aGlzLl9mb2N1c3RyYXAgPSB0aGlzLl9pbml0aWFsaXplRm9jdXNUcmFwKCk7XG4gICAgICB0aGlzLl9pc1Nob3duID0gZmFsc2U7XG4gICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICAgIHRoaXMuX3Njcm9sbEJhciA9IG5ldyBTY3JvbGxCYXJIZWxwZXIoKTtcbiAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXJzKCk7XG4gICAgfVxuXG4gICAgLy8gR2V0dGVyc1xuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiBEZWZhdWx0JDY7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdFR5cGUkNjtcbiAgICB9XG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgICAgcmV0dXJuIE5BTUUkNztcbiAgICB9XG5cbiAgICAvLyBQdWJsaWNcbiAgICB0b2dnbGUocmVsYXRlZFRhcmdldCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2lzU2hvd24gPyB0aGlzLmhpZGUoKSA6IHRoaXMuc2hvdyhyZWxhdGVkVGFyZ2V0KTtcbiAgICB9XG4gICAgc2hvdyhyZWxhdGVkVGFyZ2V0KSB7XG4gICAgICBpZiAodGhpcy5faXNTaG93biB8fCB0aGlzLl9pc1RyYW5zaXRpb25pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2hvd0V2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPVyQ0LCB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXRcbiAgICAgIH0pO1xuICAgICAgaWYgKHNob3dFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2lzU2hvd24gPSB0cnVlO1xuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3Njcm9sbEJhci5oaWRlKCk7XG4gICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9PUEVOKTtcbiAgICAgIHRoaXMuX2FkanVzdERpYWxvZygpO1xuICAgICAgdGhpcy5fYmFja2Ryb3Auc2hvdygoKSA9PiB0aGlzLl9zaG93RWxlbWVudChyZWxhdGVkVGFyZ2V0KSk7XG4gICAgfVxuICAgIGhpZGUoKSB7XG4gICAgICBpZiAoIXRoaXMuX2lzU2hvd24gfHwgdGhpcy5faXNUcmFuc2l0aW9uaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGhpZGVFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREUkNCk7XG4gICAgICBpZiAoaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5faXNTaG93biA9IGZhbHNlO1xuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2ZvY3VzdHJhcC5kZWFjdGl2YXRlKCk7XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDQpO1xuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjaygoKSA9PiB0aGlzLl9oaWRlTW9kYWwoKSwgdGhpcy5fZWxlbWVudCwgdGhpcy5faXNBbmltYXRlZCgpKTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgIEV2ZW50SGFuZGxlci5vZmYod2luZG93LCBFVkVOVF9LRVkkNCk7XG4gICAgICBFdmVudEhhbmRsZXIub2ZmKHRoaXMuX2RpYWxvZywgRVZFTlRfS0VZJDQpO1xuICAgICAgdGhpcy5fYmFja2Ryb3AuZGlzcG9zZSgpO1xuICAgICAgdGhpcy5fZm9jdXN0cmFwLmRlYWN0aXZhdGUoKTtcbiAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgaGFuZGxlVXBkYXRlKCkge1xuICAgICAgdGhpcy5fYWRqdXN0RGlhbG9nKCk7XG4gICAgfVxuXG4gICAgLy8gUHJpdmF0ZVxuICAgIF9pbml0aWFsaXplQmFja0Ryb3AoKSB7XG4gICAgICByZXR1cm4gbmV3IEJhY2tkcm9wKHtcbiAgICAgICAgaXNWaXNpYmxlOiBCb29sZWFuKHRoaXMuX2NvbmZpZy5iYWNrZHJvcCksXG4gICAgICAgIC8vICdzdGF0aWMnIG9wdGlvbiB3aWxsIGJlIHRyYW5zbGF0ZWQgdG8gdHJ1ZSwgYW5kIGJvb2xlYW5zIHdpbGwga2VlcCB0aGVpciB2YWx1ZSxcbiAgICAgICAgaXNBbmltYXRlZDogdGhpcy5faXNBbmltYXRlZCgpXG4gICAgICB9KTtcbiAgICB9XG4gICAgX2luaXRpYWxpemVGb2N1c1RyYXAoKSB7XG4gICAgICByZXR1cm4gbmV3IEZvY3VzVHJhcCh7XG4gICAgICAgIHRyYXBFbGVtZW50OiB0aGlzLl9lbGVtZW50XG4gICAgICB9KTtcbiAgICB9XG4gICAgX3Nob3dFbGVtZW50KHJlbGF0ZWRUYXJnZXQpIHtcbiAgICAgIC8vIHRyeSB0byBhcHBlbmQgZHluYW1pYyBtb2RhbFxuICAgICAgaWYgKCFkb2N1bWVudC5ib2R5LmNvbnRhaW5zKHRoaXMuX2VsZW1lbnQpKSB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kKHRoaXMuX2VsZW1lbnQpO1xuICAgICAgfVxuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ2Jsb2NrJztcbiAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWhpZGRlbicpO1xuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbW9kYWwnLCB0cnVlKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2RpYWxvZycpO1xuICAgICAgdGhpcy5fZWxlbWVudC5zY3JvbGxUb3AgPSAwO1xuICAgICAgY29uc3QgbW9kYWxCb2R5ID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9NT0RBTF9CT0RZLCB0aGlzLl9kaWFsb2cpO1xuICAgICAgaWYgKG1vZGFsQm9keSkge1xuICAgICAgICBtb2RhbEJvZHkuc2Nyb2xsVG9wID0gMDtcbiAgICAgIH1cbiAgICAgIHJlZmxvdyh0aGlzLl9lbGVtZW50KTtcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1ckNCk7XG4gICAgICBjb25zdCB0cmFuc2l0aW9uQ29tcGxldGUgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9jb25maWcuZm9jdXMpIHtcbiAgICAgICAgICB0aGlzLl9mb2N1c3RyYXAuYWN0aXZhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pc1RyYW5zaXRpb25pbmcgPSBmYWxzZTtcbiAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPV04kNCwge1xuICAgICAgICAgIHJlbGF0ZWRUYXJnZXRcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjayh0cmFuc2l0aW9uQ29tcGxldGUsIHRoaXMuX2RpYWxvZywgdGhpcy5faXNBbmltYXRlZCgpKTtcbiAgICB9XG4gICAgX2FkZEV2ZW50TGlzdGVuZXJzKCkge1xuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0tFWURPV05fRElTTUlTUyQxLCBldmVudCA9PiB7XG4gICAgICAgIGlmIChldmVudC5rZXkgIT09IEVTQ0FQRV9LRVkkMSkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fY29uZmlnLmtleWJvYXJkKSB7XG4gICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3RyaWdnZXJCYWNrZHJvcFRyYW5zaXRpb24oKTtcbiAgICAgIH0pO1xuICAgICAgRXZlbnRIYW5kbGVyLm9uKHdpbmRvdywgRVZFTlRfUkVTSVpFJDEsICgpID0+IHtcbiAgICAgICAgaWYgKHRoaXMuX2lzU2hvd24gJiYgIXRoaXMuX2lzVHJhbnNpdGlvbmluZykge1xuICAgICAgICAgIHRoaXMuX2FkanVzdERpYWxvZygpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9NT1VTRURPV05fRElTTUlTUywgZXZlbnQgPT4ge1xuICAgICAgICAvLyBhIGJhZCB0cmljayB0byBzZWdyZWdhdGUgY2xpY2tzIHRoYXQgbWF5IHN0YXJ0IGluc2lkZSBkaWFsb2cgYnV0IGVuZCBvdXRzaWRlLCBhbmQgYXZvaWQgbGlzdGVuIHRvIHNjcm9sbGJhciBjbGlja3NcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uZSh0aGlzLl9lbGVtZW50LCBFVkVOVF9DTElDS19ESVNNSVNTLCBldmVudDIgPT4ge1xuICAgICAgICAgIGlmICh0aGlzLl9lbGVtZW50ICE9PSBldmVudC50YXJnZXQgfHwgdGhpcy5fZWxlbWVudCAhPT0gZXZlbnQyLnRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5fY29uZmlnLmJhY2tkcm9wID09PSAnc3RhdGljJykge1xuICAgICAgICAgICAgdGhpcy5fdHJpZ2dlckJhY2tkcm9wVHJhbnNpdGlvbigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodGhpcy5fY29uZmlnLmJhY2tkcm9wKSB7XG4gICAgICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIF9oaWRlTW9kYWwoKSB7XG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCB0cnVlKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLW1vZGFsJyk7XG4gICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgncm9sZScpO1xuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XG4gICAgICB0aGlzLl9iYWNrZHJvcC5oaWRlKCgpID0+IHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfT1BFTik7XG4gICAgICAgIHRoaXMuX3Jlc2V0QWRqdXN0bWVudHMoKTtcbiAgICAgICAgdGhpcy5fc2Nyb2xsQmFyLnJlc2V0KCk7XG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJRERFTiQ0KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBfaXNBbmltYXRlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0ZBREUkMyk7XG4gICAgfVxuICAgIF90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uKCkge1xuICAgICAgY29uc3QgaGlkZUV2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElERV9QUkVWRU5URUQkMSk7XG4gICAgICBpZiAoaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNNb2RhbE92ZXJmbG93aW5nID0gdGhpcy5fZWxlbWVudC5zY3JvbGxIZWlnaHQgPiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0O1xuICAgICAgY29uc3QgaW5pdGlhbE92ZXJmbG93WSA9IHRoaXMuX2VsZW1lbnQuc3R5bGUub3ZlcmZsb3dZO1xuICAgICAgLy8gcmV0dXJuIGlmIHRoZSBmb2xsb3dpbmcgYmFja2dyb3VuZCB0cmFuc2l0aW9uIGhhc24ndCB5ZXQgY29tcGxldGVkXG4gICAgICBpZiAoaW5pdGlhbE92ZXJmbG93WSA9PT0gJ2hpZGRlbicgfHwgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TVEFUSUMpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghaXNNb2RhbE92ZXJmbG93aW5nKSB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUub3ZlcmZsb3dZID0gJ2hpZGRlbic7XG4gICAgICB9XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TVEFUSUMpO1xuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjaygoKSA9PiB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NUQVRJQyk7XG4gICAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGUub3ZlcmZsb3dZID0gaW5pdGlhbE92ZXJmbG93WTtcbiAgICAgICAgfSwgdGhpcy5fZGlhbG9nKTtcbiAgICAgIH0sIHRoaXMuX2RpYWxvZyk7XG4gICAgICB0aGlzLl9lbGVtZW50LmZvY3VzKCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGZvbGxvd2luZyBtZXRob2RzIGFyZSB1c2VkIHRvIGhhbmRsZSBvdmVyZmxvd2luZyBtb2RhbHNcbiAgICAgKi9cblxuICAgIF9hZGp1c3REaWFsb2coKSB7XG4gICAgICBjb25zdCBpc01vZGFsT3ZlcmZsb3dpbmcgPSB0aGlzLl9lbGVtZW50LnNjcm9sbEhlaWdodCA+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XG4gICAgICBjb25zdCBzY3JvbGxiYXJXaWR0aCA9IHRoaXMuX3Njcm9sbEJhci5nZXRXaWR0aCgpO1xuICAgICAgY29uc3QgaXNCb2R5T3ZlcmZsb3dpbmcgPSBzY3JvbGxiYXJXaWR0aCA+IDA7XG4gICAgICBpZiAoaXNCb2R5T3ZlcmZsb3dpbmcgJiYgIWlzTW9kYWxPdmVyZmxvd2luZykge1xuICAgICAgICBjb25zdCBwcm9wZXJ0eSA9IGlzUlRMKCkgPyAncGFkZGluZ0xlZnQnIDogJ3BhZGRpbmdSaWdodCc7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbcHJvcGVydHldID0gYCR7c2Nyb2xsYmFyV2lkdGh9cHhgO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0JvZHlPdmVyZmxvd2luZyAmJiBpc01vZGFsT3ZlcmZsb3dpbmcpIHtcbiAgICAgICAgY29uc3QgcHJvcGVydHkgPSBpc1JUTCgpID8gJ3BhZGRpbmdSaWdodCcgOiAncGFkZGluZ0xlZnQnO1xuICAgICAgICB0aGlzLl9lbGVtZW50LnN0eWxlW3Byb3BlcnR5XSA9IGAke3Njcm9sbGJhcldpZHRofXB4YDtcbiAgICAgIH1cbiAgICB9XG4gICAgX3Jlc2V0QWRqdXN0bWVudHMoKSB7XG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdMZWZ0ID0gJyc7XG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdSaWdodCA9ICcnO1xuICAgIH1cblxuICAgIC8vIFN0YXRpY1xuICAgIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnLCByZWxhdGVkVGFyZ2V0KSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IE1vZGFsLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgY29uZmlnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtjb25maWddKHJlbGF0ZWRUYXJnZXQpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXG4gICAqL1xuXG4gIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMiwgU0VMRUNUT1JfREFUQV9UT0dHTEUkMiwgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgY29uc3QgdGFyZ2V0ID0gU2VsZWN0b3JFbmdpbmUuZ2V0RWxlbWVudEZyb21TZWxlY3Rvcih0aGlzKTtcbiAgICBpZiAoWydBJywgJ0FSRUEnXS5pbmNsdWRlcyh0aGlzLnRhZ05hbWUpKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgICBFdmVudEhhbmRsZXIub25lKHRhcmdldCwgRVZFTlRfU0hPVyQ0LCBzaG93RXZlbnQgPT4ge1xuICAgICAgaWYgKHNob3dFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIC8vIG9ubHkgcmVnaXN0ZXIgZm9jdXMgcmVzdG9yZXIgaWYgbW9kYWwgd2lsbCBhY3R1YWxseSBnZXQgc2hvd25cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgRXZlbnRIYW5kbGVyLm9uZSh0YXJnZXQsIEVWRU5UX0hJRERFTiQ0LCAoKSA9PiB7XG4gICAgICAgIGlmIChpc1Zpc2libGUodGhpcykpIHtcbiAgICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgLy8gYXZvaWQgY29uZmxpY3Qgd2hlbiBjbGlja2luZyBtb2RhbCB0b2dnbGVyIHdoaWxlIGFub3RoZXIgb25lIGlzIG9wZW5cbiAgICBjb25zdCBhbHJlYWR5T3BlbiA9IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoT1BFTl9TRUxFQ1RPUiQxKTtcbiAgICBpZiAoYWxyZWFkeU9wZW4pIHtcbiAgICAgIE1vZGFsLmdldEluc3RhbmNlKGFscmVhZHlPcGVuKS5oaWRlKCk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBNb2RhbC5nZXRPckNyZWF0ZUluc3RhbmNlKHRhcmdldCk7XG4gICAgZGF0YS50b2dnbGUodGhpcyk7XG4gIH0pO1xuICBlbmFibGVEaXNtaXNzVHJpZ2dlcihNb2RhbCk7XG5cbiAgLyoqXG4gICAqIGpRdWVyeVxuICAgKi9cblxuICBkZWZpbmVKUXVlcnlQbHVnaW4oTW9kYWwpO1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgb2ZmY2FudmFzLmpzXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuXG4gIC8qKlxuICAgKiBDb25zdGFudHNcbiAgICovXG5cbiAgY29uc3QgTkFNRSQ2ID0gJ29mZmNhbnZhcyc7XG4gIGNvbnN0IERBVEFfS0VZJDMgPSAnYnMub2ZmY2FudmFzJztcbiAgY29uc3QgRVZFTlRfS0VZJDMgPSBgLiR7REFUQV9LRVkkM31gO1xuICBjb25zdCBEQVRBX0FQSV9LRVkkMSA9ICcuZGF0YS1hcGknO1xuICBjb25zdCBFVkVOVF9MT0FEX0RBVEFfQVBJJDIgPSBgbG9hZCR7RVZFTlRfS0VZJDN9JHtEQVRBX0FQSV9LRVkkMX1gO1xuICBjb25zdCBFU0NBUEVfS0VZID0gJ0VzY2FwZSc7XG4gIGNvbnN0IENMQVNTX05BTUVfU0hPVyQzID0gJ3Nob3cnO1xuICBjb25zdCBDTEFTU19OQU1FX1NIT1dJTkckMSA9ICdzaG93aW5nJztcbiAgY29uc3QgQ0xBU1NfTkFNRV9ISURJTkcgPSAnaGlkaW5nJztcbiAgY29uc3QgQ0xBU1NfTkFNRV9CQUNLRFJPUCA9ICdvZmZjYW52YXMtYmFja2Ryb3AnO1xuICBjb25zdCBPUEVOX1NFTEVDVE9SID0gJy5vZmZjYW52YXMuc2hvdyc7XG4gIGNvbnN0IEVWRU5UX1NIT1ckMyA9IGBzaG93JHtFVkVOVF9LRVkkM31gO1xuICBjb25zdCBFVkVOVF9TSE9XTiQzID0gYHNob3duJHtFVkVOVF9LRVkkM31gO1xuICBjb25zdCBFVkVOVF9ISURFJDMgPSBgaGlkZSR7RVZFTlRfS0VZJDN9YDtcbiAgY29uc3QgRVZFTlRfSElERV9QUkVWRU5URUQgPSBgaGlkZVByZXZlbnRlZCR7RVZFTlRfS0VZJDN9YDtcbiAgY29uc3QgRVZFTlRfSElEREVOJDMgPSBgaGlkZGVuJHtFVkVOVF9LRVkkM31gO1xuICBjb25zdCBFVkVOVF9SRVNJWkUgPSBgcmVzaXplJHtFVkVOVF9LRVkkM31gO1xuICBjb25zdCBFVkVOVF9DTElDS19EQVRBX0FQSSQxID0gYGNsaWNrJHtFVkVOVF9LRVkkM30ke0RBVEFfQVBJX0tFWSQxfWA7XG4gIGNvbnN0IEVWRU5UX0tFWURPV05fRElTTUlTUyA9IGBrZXlkb3duLmRpc21pc3Mke0VWRU5UX0tFWSQzfWA7XG4gIGNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFJDEgPSAnW2RhdGEtYnMtdG9nZ2xlPVwib2ZmY2FudmFzXCJdJztcbiAgY29uc3QgRGVmYXVsdCQ1ID0ge1xuICAgIGJhY2tkcm9wOiB0cnVlLFxuICAgIGtleWJvYXJkOiB0cnVlLFxuICAgIHNjcm9sbDogZmFsc2VcbiAgfTtcbiAgY29uc3QgRGVmYXVsdFR5cGUkNSA9IHtcbiAgICBiYWNrZHJvcDogJyhib29sZWFufHN0cmluZyknLFxuICAgIGtleWJvYXJkOiAnYm9vbGVhbicsXG4gICAgc2Nyb2xsOiAnYm9vbGVhbidcbiAgfTtcblxuICAvKipcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxuICAgKi9cblxuICBjbGFzcyBPZmZjYW52YXMgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICAgIHN1cGVyKGVsZW1lbnQsIGNvbmZpZyk7XG4gICAgICB0aGlzLl9pc1Nob3duID0gZmFsc2U7XG4gICAgICB0aGlzLl9iYWNrZHJvcCA9IHRoaXMuX2luaXRpYWxpemVCYWNrRHJvcCgpO1xuICAgICAgdGhpcy5fZm9jdXN0cmFwID0gdGhpcy5faW5pdGlhbGl6ZUZvY3VzVHJhcCgpO1xuICAgICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG5cbiAgICAvLyBHZXR0ZXJzXG4gICAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgICAgcmV0dXJuIERlZmF1bHQkNTtcbiAgICB9XG4gICAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICAgIHJldHVybiBEZWZhdWx0VHlwZSQ1O1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgICByZXR1cm4gTkFNRSQ2O1xuICAgIH1cblxuICAgIC8vIFB1YmxpY1xuICAgIHRvZ2dsZShyZWxhdGVkVGFyZ2V0KSB7XG4gICAgICByZXR1cm4gdGhpcy5faXNTaG93biA/IHRoaXMuaGlkZSgpIDogdGhpcy5zaG93KHJlbGF0ZWRUYXJnZXQpO1xuICAgIH1cbiAgICBzaG93KHJlbGF0ZWRUYXJnZXQpIHtcbiAgICAgIGlmICh0aGlzLl9pc1Nob3duKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNob3dFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1ckMywge1xuICAgICAgICByZWxhdGVkVGFyZ2V0XG4gICAgICB9KTtcbiAgICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9pc1Nob3duID0gdHJ1ZTtcbiAgICAgIHRoaXMuX2JhY2tkcm9wLnNob3coKTtcbiAgICAgIGlmICghdGhpcy5fY29uZmlnLnNjcm9sbCkge1xuICAgICAgICBuZXcgU2Nyb2xsQmFySGVscGVyKCkuaGlkZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbW9kYWwnLCB0cnVlKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdyb2xlJywgJ2RpYWxvZycpO1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPV0lORyQxKTtcbiAgICAgIGNvbnN0IGNvbXBsZXRlQ2FsbEJhY2sgPSAoKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5fY29uZmlnLnNjcm9sbCB8fCB0aGlzLl9jb25maWcuYmFja2Ryb3ApIHtcbiAgICAgICAgICB0aGlzLl9mb2N1c3RyYXAuYWN0aXZhdGUoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XJDMpO1xuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XSU5HJDEpO1xuICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XTiQzLCB7XG4gICAgICAgICAgcmVsYXRlZFRhcmdldFxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlQ2FsbEJhY2ssIHRoaXMuX2VsZW1lbnQsIHRydWUpO1xuICAgIH1cbiAgICBoaWRlKCkge1xuICAgICAgaWYgKCF0aGlzLl9pc1Nob3duKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGhpZGVFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREUkMyk7XG4gICAgICBpZiAoaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fZm9jdXN0cmFwLmRlYWN0aXZhdGUoKTtcbiAgICAgIHRoaXMuX2VsZW1lbnQuYmx1cigpO1xuICAgICAgdGhpcy5faXNTaG93biA9IGZhbHNlO1xuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfSElESU5HKTtcbiAgICAgIHRoaXMuX2JhY2tkcm9wLmhpZGUoKTtcbiAgICAgIGNvbnN0IGNvbXBsZXRlQ2FsbGJhY2sgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1ckMywgQ0xBU1NfTkFNRV9ISURJTkcpO1xuICAgICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1tb2RhbCcpO1xuICAgICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgncm9sZScpO1xuICAgICAgICBpZiAoIXRoaXMuX2NvbmZpZy5zY3JvbGwpIHtcbiAgICAgICAgICBuZXcgU2Nyb2xsQmFySGVscGVyKCkucmVzZXQoKTtcbiAgICAgICAgfVxuICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURERU4kMyk7XG4gICAgICB9O1xuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZUNhbGxiYWNrLCB0aGlzLl9lbGVtZW50LCB0cnVlKTtcbiAgICB9XG4gICAgZGlzcG9zZSgpIHtcbiAgICAgIHRoaXMuX2JhY2tkcm9wLmRpc3Bvc2UoKTtcbiAgICAgIHRoaXMuX2ZvY3VzdHJhcC5kZWFjdGl2YXRlKCk7XG4gICAgICBzdXBlci5kaXNwb3NlKCk7XG4gICAgfVxuXG4gICAgLy8gUHJpdmF0ZVxuICAgIF9pbml0aWFsaXplQmFja0Ryb3AoKSB7XG4gICAgICBjb25zdCBjbGlja0NhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgICBpZiAodGhpcy5fY29uZmlnLmJhY2tkcm9wID09PSAnc3RhdGljJykge1xuICAgICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREVfUFJFVkVOVEVEKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICB9O1xuXG4gICAgICAvLyAnc3RhdGljJyBvcHRpb24gd2lsbCBiZSB0cmFuc2xhdGVkIHRvIHRydWUsIGFuZCBib29sZWFucyB3aWxsIGtlZXAgdGhlaXIgdmFsdWVcbiAgICAgIGNvbnN0IGlzVmlzaWJsZSA9IEJvb2xlYW4odGhpcy5fY29uZmlnLmJhY2tkcm9wKTtcbiAgICAgIHJldHVybiBuZXcgQmFja2Ryb3Aoe1xuICAgICAgICBjbGFzc05hbWU6IENMQVNTX05BTUVfQkFDS0RST1AsXG4gICAgICAgIGlzVmlzaWJsZSxcbiAgICAgICAgaXNBbmltYXRlZDogdHJ1ZSxcbiAgICAgICAgcm9vdEVsZW1lbnQ6IHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSxcbiAgICAgICAgY2xpY2tDYWxsYmFjazogaXNWaXNpYmxlID8gY2xpY2tDYWxsYmFjayA6IG51bGxcbiAgICAgIH0pO1xuICAgIH1cbiAgICBfaW5pdGlhbGl6ZUZvY3VzVHJhcCgpIHtcbiAgICAgIHJldHVybiBuZXcgRm9jdXNUcmFwKHtcbiAgICAgICAgdHJhcEVsZW1lbnQ6IHRoaXMuX2VsZW1lbnRcbiAgICAgIH0pO1xuICAgIH1cbiAgICBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfS0VZRE9XTl9ESVNNSVNTLCBldmVudCA9PiB7XG4gICAgICAgIGlmIChldmVudC5rZXkgIT09IEVTQ0FQRV9LRVkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5rZXlib2FyZCkge1xuICAgICAgICAgIHRoaXMuaGlkZSgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFX1BSRVZFTlRFRCk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBTdGF0aWNcbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBPZmZjYW52YXMuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBjb25maWcpO1xuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRhdGFbY29uZmlnXSA9PT0gdW5kZWZpbmVkIHx8IGNvbmZpZy5zdGFydHNXaXRoKCdfJykgfHwgY29uZmlnID09PSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhW2NvbmZpZ10odGhpcyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGF0YSBBUEkgaW1wbGVtZW50YXRpb25cbiAgICovXG5cbiAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSQxLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQxLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICBjb25zdCB0YXJnZXQgPSBTZWxlY3RvckVuZ2luZS5nZXRFbGVtZW50RnJvbVNlbGVjdG9yKHRoaXMpO1xuICAgIGlmIChbJ0EnLCAnQVJFQSddLmluY2x1ZGVzKHRoaXMudGFnTmFtZSkpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIGlmIChpc0Rpc2FibGVkKHRoaXMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIEV2ZW50SGFuZGxlci5vbmUodGFyZ2V0LCBFVkVOVF9ISURERU4kMywgKCkgPT4ge1xuICAgICAgLy8gZm9jdXMgb24gdHJpZ2dlciB3aGVuIGl0IGlzIGNsb3NlZFxuICAgICAgaWYgKGlzVmlzaWJsZSh0aGlzKSkge1xuICAgICAgICB0aGlzLmZvY3VzKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBhdm9pZCBjb25mbGljdCB3aGVuIGNsaWNraW5nIGEgdG9nZ2xlciBvZiBhbiBvZmZjYW52YXMsIHdoaWxlIGFub3RoZXIgaXMgb3BlblxuICAgIGNvbnN0IGFscmVhZHlPcGVuID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShPUEVOX1NFTEVDVE9SKTtcbiAgICBpZiAoYWxyZWFkeU9wZW4gJiYgYWxyZWFkeU9wZW4gIT09IHRhcmdldCkge1xuICAgICAgT2ZmY2FudmFzLmdldEluc3RhbmNlKGFscmVhZHlPcGVuKS5oaWRlKCk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBPZmZjYW52YXMuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0YXJnZXQpO1xuICAgIGRhdGEudG9nZ2xlKHRoaXMpO1xuICB9KTtcbiAgRXZlbnRIYW5kbGVyLm9uKHdpbmRvdywgRVZFTlRfTE9BRF9EQVRBX0FQSSQyLCAoKSA9PiB7XG4gICAgZm9yIChjb25zdCBzZWxlY3RvciBvZiBTZWxlY3RvckVuZ2luZS5maW5kKE9QRU5fU0VMRUNUT1IpKSB7XG4gICAgICBPZmZjYW52YXMuZ2V0T3JDcmVhdGVJbnN0YW5jZShzZWxlY3Rvcikuc2hvdygpO1xuICAgIH1cbiAgfSk7XG4gIEV2ZW50SGFuZGxlci5vbih3aW5kb3csIEVWRU5UX1JFU0laRSwgKCkgPT4ge1xuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBTZWxlY3RvckVuZ2luZS5maW5kKCdbYXJpYS1tb2RhbF1bY2xhc3MqPXNob3ddW2NsYXNzKj1vZmZjYW52YXMtXScpKSB7XG4gICAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbiAhPT0gJ2ZpeGVkJykge1xuICAgICAgICBPZmZjYW52YXMuZ2V0T3JDcmVhdGVJbnN0YW5jZShlbGVtZW50KS5oaWRlKCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgZW5hYmxlRGlzbWlzc1RyaWdnZXIoT2ZmY2FudmFzKTtcblxuICAvKipcbiAgICogalF1ZXJ5XG4gICAqL1xuXG4gIGRlZmluZUpRdWVyeVBsdWdpbihPZmZjYW52YXMpO1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgdXRpbC9zYW5pdGl6ZXIuanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG4gIC8vIGpzLWRvY3Mtc3RhcnQgYWxsb3ctbGlzdFxuICBjb25zdCBBUklBX0FUVFJJQlVURV9QQVRURVJOID0gL15hcmlhLVtcXHctXSokL2k7XG4gIGNvbnN0IERlZmF1bHRBbGxvd2xpc3QgPSB7XG4gICAgLy8gR2xvYmFsIGF0dHJpYnV0ZXMgYWxsb3dlZCBvbiBhbnkgc3VwcGxpZWQgZWxlbWVudCBiZWxvdy5cbiAgICAnKic6IFsnY2xhc3MnLCAnZGlyJywgJ2lkJywgJ2xhbmcnLCAncm9sZScsIEFSSUFfQVRUUklCVVRFX1BBVFRFUk5dLFxuICAgIGE6IFsndGFyZ2V0JywgJ2hyZWYnLCAndGl0bGUnLCAncmVsJ10sXG4gICAgYXJlYTogW10sXG4gICAgYjogW10sXG4gICAgYnI6IFtdLFxuICAgIGNvbDogW10sXG4gICAgY29kZTogW10sXG4gICAgZGQ6IFtdLFxuICAgIGRpdjogW10sXG4gICAgZGw6IFtdLFxuICAgIGR0OiBbXSxcbiAgICBlbTogW10sXG4gICAgaHI6IFtdLFxuICAgIGgxOiBbXSxcbiAgICBoMjogW10sXG4gICAgaDM6IFtdLFxuICAgIGg0OiBbXSxcbiAgICBoNTogW10sXG4gICAgaDY6IFtdLFxuICAgIGk6IFtdLFxuICAgIGltZzogWydzcmMnLCAnc3Jjc2V0JywgJ2FsdCcsICd0aXRsZScsICd3aWR0aCcsICdoZWlnaHQnXSxcbiAgICBsaTogW10sXG4gICAgb2w6IFtdLFxuICAgIHA6IFtdLFxuICAgIHByZTogW10sXG4gICAgczogW10sXG4gICAgc21hbGw6IFtdLFxuICAgIHNwYW46IFtdLFxuICAgIHN1YjogW10sXG4gICAgc3VwOiBbXSxcbiAgICBzdHJvbmc6IFtdLFxuICAgIHU6IFtdLFxuICAgIHVsOiBbXVxuICB9O1xuICAvLyBqcy1kb2NzLWVuZCBhbGxvdy1saXN0XG5cbiAgY29uc3QgdXJpQXR0cmlidXRlcyA9IG5ldyBTZXQoWydiYWNrZ3JvdW5kJywgJ2NpdGUnLCAnaHJlZicsICdpdGVtdHlwZScsICdsb25nZGVzYycsICdwb3N0ZXInLCAnc3JjJywgJ3hsaW5rOmhyZWYnXSk7XG5cbiAgLyoqXG4gICAqIEEgcGF0dGVybiB0aGF0IHJlY29nbml6ZXMgVVJMcyB0aGF0IGFyZSBzYWZlIHdydC4gWFNTIGluIFVSTCBuYXZpZ2F0aW9uXG4gICAqIGNvbnRleHRzLlxuICAgKlxuICAgKiBTaG91dC1vdXQgdG8gQW5ndWxhciBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2Jsb2IvMTUuMi44L3BhY2thZ2VzL2NvcmUvc3JjL3Nhbml0aXphdGlvbi91cmxfc2FuaXRpemVyLnRzI0wzOFxuICAgKi9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHVuaWNvcm4vYmV0dGVyLXJlZ2V4XG4gIGNvbnN0IFNBRkVfVVJMX1BBVFRFUk4gPSAvXig/IWphdmFzY3JpcHQ6KSg/OlthLXowLTkrLi1dKzp8W14mOi8/I10qKD86Wy8/I118JCkpL2k7XG4gIGNvbnN0IGFsbG93ZWRBdHRyaWJ1dGUgPSAoYXR0cmlidXRlLCBhbGxvd2VkQXR0cmlidXRlTGlzdCkgPT4ge1xuICAgIGNvbnN0IGF0dHJpYnV0ZU5hbWUgPSBhdHRyaWJ1dGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoYWxsb3dlZEF0dHJpYnV0ZUxpc3QuaW5jbHVkZXMoYXR0cmlidXRlTmFtZSkpIHtcbiAgICAgIGlmICh1cmlBdHRyaWJ1dGVzLmhhcyhhdHRyaWJ1dGVOYW1lKSkge1xuICAgICAgICByZXR1cm4gQm9vbGVhbihTQUZFX1VSTF9QQVRURVJOLnRlc3QoYXR0cmlidXRlLm5vZGVWYWx1ZSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgYSByZWd1bGFyIGV4cHJlc3Npb24gdmFsaWRhdGVzIHRoZSBhdHRyaWJ1dGUuXG4gICAgcmV0dXJuIGFsbG93ZWRBdHRyaWJ1dGVMaXN0LmZpbHRlcihhdHRyaWJ1dGVSZWdleCA9PiBhdHRyaWJ1dGVSZWdleCBpbnN0YW5jZW9mIFJlZ0V4cCkuc29tZShyZWdleCA9PiByZWdleC50ZXN0KGF0dHJpYnV0ZU5hbWUpKTtcbiAgfTtcbiAgZnVuY3Rpb24gc2FuaXRpemVIdG1sKHVuc2FmZUh0bWwsIGFsbG93TGlzdCwgc2FuaXRpemVGdW5jdGlvbikge1xuICAgIGlmICghdW5zYWZlSHRtbC5sZW5ndGgpIHtcbiAgICAgIHJldHVybiB1bnNhZmVIdG1sO1xuICAgIH1cbiAgICBpZiAoc2FuaXRpemVGdW5jdGlvbiAmJiB0eXBlb2Ygc2FuaXRpemVGdW5jdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcmV0dXJuIHNhbml0aXplRnVuY3Rpb24odW5zYWZlSHRtbCk7XG4gICAgfVxuICAgIGNvbnN0IGRvbVBhcnNlciA9IG5ldyB3aW5kb3cuRE9NUGFyc2VyKCk7XG4gICAgY29uc3QgY3JlYXRlZERvY3VtZW50ID0gZG9tUGFyc2VyLnBhcnNlRnJvbVN0cmluZyh1bnNhZmVIdG1sLCAndGV4dC9odG1sJyk7XG4gICAgY29uc3QgZWxlbWVudHMgPSBbXS5jb25jYXQoLi4uY3JlYXRlZERvY3VtZW50LmJvZHkucXVlcnlTZWxlY3RvckFsbCgnKicpKTtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgZWxlbWVudHMpIHtcbiAgICAgIGNvbnN0IGVsZW1lbnROYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgaWYgKCFPYmplY3Qua2V5cyhhbGxvd0xpc3QpLmluY2x1ZGVzKGVsZW1lbnROYW1lKSkge1xuICAgICAgICBlbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGF0dHJpYnV0ZUxpc3QgPSBbXS5jb25jYXQoLi4uZWxlbWVudC5hdHRyaWJ1dGVzKTtcbiAgICAgIGNvbnN0IGFsbG93ZWRBdHRyaWJ1dGVzID0gW10uY29uY2F0KGFsbG93TGlzdFsnKiddIHx8IFtdLCBhbGxvd0xpc3RbZWxlbWVudE5hbWVdIHx8IFtdKTtcbiAgICAgIGZvciAoY29uc3QgYXR0cmlidXRlIG9mIGF0dHJpYnV0ZUxpc3QpIHtcbiAgICAgICAgaWYgKCFhbGxvd2VkQXR0cmlidXRlKGF0dHJpYnV0ZSwgYWxsb3dlZEF0dHJpYnV0ZXMpKSB7XG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlLm5vZGVOYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlZERvY3VtZW50LmJvZHkuaW5uZXJIVE1MO1xuICB9XG5cbiAgLyoqXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqIEJvb3RzdHJhcCB1dGlsL3RlbXBsYXRlLWZhY3RvcnkuanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIENvbnN0YW50c1xuICAgKi9cblxuICBjb25zdCBOQU1FJDUgPSAnVGVtcGxhdGVGYWN0b3J5JztcbiAgY29uc3QgRGVmYXVsdCQ0ID0ge1xuICAgIGFsbG93TGlzdDogRGVmYXVsdEFsbG93bGlzdCxcbiAgICBjb250ZW50OiB7fSxcbiAgICAvLyB7IHNlbGVjdG9yIDogdGV4dCAsICBzZWxlY3RvcjIgOiB0ZXh0MiAsIH1cbiAgICBleHRyYUNsYXNzOiAnJyxcbiAgICBodG1sOiBmYWxzZSxcbiAgICBzYW5pdGl6ZTogdHJ1ZSxcbiAgICBzYW5pdGl6ZUZuOiBudWxsLFxuICAgIHRlbXBsYXRlOiAnPGRpdj48L2Rpdj4nXG4gIH07XG4gIGNvbnN0IERlZmF1bHRUeXBlJDQgPSB7XG4gICAgYWxsb3dMaXN0OiAnb2JqZWN0JyxcbiAgICBjb250ZW50OiAnb2JqZWN0JyxcbiAgICBleHRyYUNsYXNzOiAnKHN0cmluZ3xmdW5jdGlvbiknLFxuICAgIGh0bWw6ICdib29sZWFuJyxcbiAgICBzYW5pdGl6ZTogJ2Jvb2xlYW4nLFxuICAgIHNhbml0aXplRm46ICcobnVsbHxmdW5jdGlvbiknLFxuICAgIHRlbXBsYXRlOiAnc3RyaW5nJ1xuICB9O1xuICBjb25zdCBEZWZhdWx0Q29udGVudFR5cGUgPSB7XG4gICAgZW50cnk6ICcoc3RyaW5nfGVsZW1lbnR8ZnVuY3Rpb258bnVsbCknLFxuICAgIHNlbGVjdG9yOiAnKHN0cmluZ3xlbGVtZW50KSdcbiAgfTtcblxuICAvKipcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxuICAgKi9cblxuICBjbGFzcyBUZW1wbGF0ZUZhY3RvcnkgZXh0ZW5kcyBDb25maWcge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZykge1xuICAgICAgc3VwZXIoKTtcbiAgICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xuICAgIH1cblxuICAgIC8vIEdldHRlcnNcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdCQ0O1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlJDQ7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcbiAgICAgIHJldHVybiBOQU1FJDU7XG4gICAgfVxuXG4gICAgLy8gUHVibGljXG4gICAgZ2V0Q29udGVudCgpIHtcbiAgICAgIHJldHVybiBPYmplY3QudmFsdWVzKHRoaXMuX2NvbmZpZy5jb250ZW50KS5tYXAoY29uZmlnID0+IHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKGNvbmZpZykpLmZpbHRlcihCb29sZWFuKTtcbiAgICB9XG4gICAgaGFzQ29udGVudCgpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldENvbnRlbnQoKS5sZW5ndGggPiAwO1xuICAgIH1cbiAgICBjaGFuZ2VDb250ZW50KGNvbnRlbnQpIHtcbiAgICAgIHRoaXMuX2NoZWNrQ29udGVudChjb250ZW50KTtcbiAgICAgIHRoaXMuX2NvbmZpZy5jb250ZW50ID0ge1xuICAgICAgICAuLi50aGlzLl9jb25maWcuY29udGVudCxcbiAgICAgICAgLi4uY29udGVudFxuICAgICAgfTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICB0b0h0bWwoKSB7XG4gICAgICBjb25zdCB0ZW1wbGF0ZVdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgIHRlbXBsYXRlV3JhcHBlci5pbm5lckhUTUwgPSB0aGlzLl9tYXliZVNhbml0aXplKHRoaXMuX2NvbmZpZy50ZW1wbGF0ZSk7XG4gICAgICBmb3IgKGNvbnN0IFtzZWxlY3RvciwgdGV4dF0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5fY29uZmlnLmNvbnRlbnQpKSB7XG4gICAgICAgIHRoaXMuX3NldENvbnRlbnQodGVtcGxhdGVXcmFwcGVyLCB0ZXh0LCBzZWxlY3Rvcik7XG4gICAgICB9XG4gICAgICBjb25zdCB0ZW1wbGF0ZSA9IHRlbXBsYXRlV3JhcHBlci5jaGlsZHJlblswXTtcbiAgICAgIGNvbnN0IGV4dHJhQ2xhc3MgPSB0aGlzLl9yZXNvbHZlUG9zc2libGVGdW5jdGlvbih0aGlzLl9jb25maWcuZXh0cmFDbGFzcyk7XG4gICAgICBpZiAoZXh0cmFDbGFzcykge1xuICAgICAgICB0ZW1wbGF0ZS5jbGFzc0xpc3QuYWRkKC4uLmV4dHJhQ2xhc3Muc3BsaXQoJyAnKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGVtcGxhdGU7XG4gICAgfVxuXG4gICAgLy8gUHJpdmF0ZVxuICAgIF90eXBlQ2hlY2tDb25maWcoY29uZmlnKSB7XG4gICAgICBzdXBlci5fdHlwZUNoZWNrQ29uZmlnKGNvbmZpZyk7XG4gICAgICB0aGlzLl9jaGVja0NvbnRlbnQoY29uZmlnLmNvbnRlbnQpO1xuICAgIH1cbiAgICBfY2hlY2tDb250ZW50KGFyZykge1xuICAgICAgZm9yIChjb25zdCBbc2VsZWN0b3IsIGNvbnRlbnRdIG9mIE9iamVjdC5lbnRyaWVzKGFyZykpIHtcbiAgICAgICAgc3VwZXIuX3R5cGVDaGVja0NvbmZpZyh7XG4gICAgICAgICAgc2VsZWN0b3IsXG4gICAgICAgICAgZW50cnk6IGNvbnRlbnRcbiAgICAgICAgfSwgRGVmYXVsdENvbnRlbnRUeXBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX3NldENvbnRlbnQodGVtcGxhdGUsIGNvbnRlbnQsIHNlbGVjdG9yKSB7XG4gICAgICBjb25zdCB0ZW1wbGF0ZUVsZW1lbnQgPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKHNlbGVjdG9yLCB0ZW1wbGF0ZSk7XG4gICAgICBpZiAoIXRlbXBsYXRlRWxlbWVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb250ZW50ID0gdGhpcy5fcmVzb2x2ZVBvc3NpYmxlRnVuY3Rpb24oY29udGVudCk7XG4gICAgICBpZiAoIWNvbnRlbnQpIHtcbiAgICAgICAgdGVtcGxhdGVFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoaXNFbGVtZW50JDEoY29udGVudCkpIHtcbiAgICAgICAgdGhpcy5fcHV0RWxlbWVudEluVGVtcGxhdGUoZ2V0RWxlbWVudChjb250ZW50KSwgdGVtcGxhdGVFbGVtZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5odG1sKSB7XG4gICAgICAgIHRlbXBsYXRlRWxlbWVudC5pbm5lckhUTUwgPSB0aGlzLl9tYXliZVNhbml0aXplKGNvbnRlbnQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0ZW1wbGF0ZUVsZW1lbnQudGV4dENvbnRlbnQgPSBjb250ZW50O1xuICAgIH1cbiAgICBfbWF5YmVTYW5pdGl6ZShhcmcpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb25maWcuc2FuaXRpemUgPyBzYW5pdGl6ZUh0bWwoYXJnLCB0aGlzLl9jb25maWcuYWxsb3dMaXN0LCB0aGlzLl9jb25maWcuc2FuaXRpemVGbikgOiBhcmc7XG4gICAgfVxuICAgIF9yZXNvbHZlUG9zc2libGVGdW5jdGlvbihhcmcpIHtcbiAgICAgIHJldHVybiBleGVjdXRlKGFyZywgW3RoaXNdKTtcbiAgICB9XG4gICAgX3B1dEVsZW1lbnRJblRlbXBsYXRlKGVsZW1lbnQsIHRlbXBsYXRlRWxlbWVudCkge1xuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5odG1sKSB7XG4gICAgICAgIHRlbXBsYXRlRWxlbWVudC5pbm5lckhUTUwgPSAnJztcbiAgICAgICAgdGVtcGxhdGVFbGVtZW50LmFwcGVuZChlbGVtZW50KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGVtcGxhdGVFbGVtZW50LnRleHRDb250ZW50ID0gZWxlbWVudC50ZXh0Q29udGVudDtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQm9vdHN0cmFwIHRvb2x0aXAuanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIENvbnN0YW50c1xuICAgKi9cblxuICBjb25zdCBOQU1FJDQgPSAndG9vbHRpcCc7XG4gIGNvbnN0IERJU0FMTE9XRURfQVRUUklCVVRFUyA9IG5ldyBTZXQoWydzYW5pdGl6ZScsICdhbGxvd0xpc3QnLCAnc2FuaXRpemVGbiddKTtcbiAgY29uc3QgQ0xBU1NfTkFNRV9GQURFJDIgPSAnZmFkZSc7XG4gIGNvbnN0IENMQVNTX05BTUVfTU9EQUwgPSAnbW9kYWwnO1xuICBjb25zdCBDTEFTU19OQU1FX1NIT1ckMiA9ICdzaG93JztcbiAgY29uc3QgU0VMRUNUT1JfVE9PTFRJUF9JTk5FUiA9ICcudG9vbHRpcC1pbm5lcic7XG4gIGNvbnN0IFNFTEVDVE9SX01PREFMID0gYC4ke0NMQVNTX05BTUVfTU9EQUx9YDtcbiAgY29uc3QgRVZFTlRfTU9EQUxfSElERSA9ICdoaWRlLmJzLm1vZGFsJztcbiAgY29uc3QgVFJJR0dFUl9IT1ZFUiA9ICdob3Zlcic7XG4gIGNvbnN0IFRSSUdHRVJfRk9DVVMgPSAnZm9jdXMnO1xuICBjb25zdCBUUklHR0VSX0NMSUNLID0gJ2NsaWNrJztcbiAgY29uc3QgVFJJR0dFUl9NQU5VQUwgPSAnbWFudWFsJztcbiAgY29uc3QgRVZFTlRfSElERSQyID0gJ2hpZGUnO1xuICBjb25zdCBFVkVOVF9ISURERU4kMiA9ICdoaWRkZW4nO1xuICBjb25zdCBFVkVOVF9TSE9XJDIgPSAnc2hvdyc7XG4gIGNvbnN0IEVWRU5UX1NIT1dOJDIgPSAnc2hvd24nO1xuICBjb25zdCBFVkVOVF9JTlNFUlRFRCA9ICdpbnNlcnRlZCc7XG4gIGNvbnN0IEVWRU5UX0NMSUNLJDEgPSAnY2xpY2snO1xuICBjb25zdCBFVkVOVF9GT0NVU0lOJDEgPSAnZm9jdXNpbic7XG4gIGNvbnN0IEVWRU5UX0ZPQ1VTT1VUJDEgPSAnZm9jdXNvdXQnO1xuICBjb25zdCBFVkVOVF9NT1VTRUVOVEVSID0gJ21vdXNlZW50ZXInO1xuICBjb25zdCBFVkVOVF9NT1VTRUxFQVZFID0gJ21vdXNlbGVhdmUnO1xuICBjb25zdCBBdHRhY2htZW50TWFwID0ge1xuICAgIEFVVE86ICdhdXRvJyxcbiAgICBUT1A6ICd0b3AnLFxuICAgIFJJR0hUOiBpc1JUTCgpID8gJ2xlZnQnIDogJ3JpZ2h0JyxcbiAgICBCT1RUT006ICdib3R0b20nLFxuICAgIExFRlQ6IGlzUlRMKCkgPyAncmlnaHQnIDogJ2xlZnQnXG4gIH07XG4gIGNvbnN0IERlZmF1bHQkMyA9IHtcbiAgICBhbGxvd0xpc3Q6IERlZmF1bHRBbGxvd2xpc3QsXG4gICAgYW5pbWF0aW9uOiB0cnVlLFxuICAgIGJvdW5kYXJ5OiAnY2xpcHBpbmdQYXJlbnRzJyxcbiAgICBjb250YWluZXI6IGZhbHNlLFxuICAgIGN1c3RvbUNsYXNzOiAnJyxcbiAgICBkZWxheTogMCxcbiAgICBmYWxsYmFja1BsYWNlbWVudHM6IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J10sXG4gICAgaHRtbDogZmFsc2UsXG4gICAgb2Zmc2V0OiBbMCwgNl0sXG4gICAgcGxhY2VtZW50OiAndG9wJyxcbiAgICBwb3BwZXJDb25maWc6IG51bGwsXG4gICAgc2FuaXRpemU6IHRydWUsXG4gICAgc2FuaXRpemVGbjogbnVsbCxcbiAgICBzZWxlY3RvcjogZmFsc2UsXG4gICAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwidG9vbHRpcFwiIHJvbGU9XCJ0b29sdGlwXCI+JyArICc8ZGl2IGNsYXNzPVwidG9vbHRpcC1hcnJvd1wiPjwvZGl2PicgKyAnPGRpdiBjbGFzcz1cInRvb2x0aXAtaW5uZXJcIj48L2Rpdj4nICsgJzwvZGl2PicsXG4gICAgdGl0bGU6ICcnLFxuICAgIHRyaWdnZXI6ICdob3ZlciBmb2N1cydcbiAgfTtcbiAgY29uc3QgRGVmYXVsdFR5cGUkMyA9IHtcbiAgICBhbGxvd0xpc3Q6ICdvYmplY3QnLFxuICAgIGFuaW1hdGlvbjogJ2Jvb2xlYW4nLFxuICAgIGJvdW5kYXJ5OiAnKHN0cmluZ3xlbGVtZW50KScsXG4gICAgY29udGFpbmVyOiAnKHN0cmluZ3xlbGVtZW50fGJvb2xlYW4pJyxcbiAgICBjdXN0b21DbGFzczogJyhzdHJpbmd8ZnVuY3Rpb24pJyxcbiAgICBkZWxheTogJyhudW1iZXJ8b2JqZWN0KScsXG4gICAgZmFsbGJhY2tQbGFjZW1lbnRzOiAnYXJyYXknLFxuICAgIGh0bWw6ICdib29sZWFuJyxcbiAgICBvZmZzZXQ6ICcoYXJyYXl8c3RyaW5nfGZ1bmN0aW9uKScsXG4gICAgcGxhY2VtZW50OiAnKHN0cmluZ3xmdW5jdGlvbiknLFxuICAgIHBvcHBlckNvbmZpZzogJyhudWxsfG9iamVjdHxmdW5jdGlvbiknLFxuICAgIHNhbml0aXplOiAnYm9vbGVhbicsXG4gICAgc2FuaXRpemVGbjogJyhudWxsfGZ1bmN0aW9uKScsXG4gICAgc2VsZWN0b3I6ICcoc3RyaW5nfGJvb2xlYW4pJyxcbiAgICB0ZW1wbGF0ZTogJ3N0cmluZycsXG4gICAgdGl0bGU6ICcoc3RyaW5nfGVsZW1lbnR8ZnVuY3Rpb24pJyxcbiAgICB0cmlnZ2VyOiAnc3RyaW5nJ1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGFzcyBkZWZpbml0aW9uXG4gICAqL1xuXG4gIGNsYXNzIFRvb2x0aXAgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICAgIGlmICh0eXBlb2YgUG9wcGVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb290c3RyYXBcXCdzIHRvb2x0aXBzIHJlcXVpcmUgUG9wcGVyIChodHRwczovL3BvcHBlci5qcy5vcmcpJyk7XG4gICAgICB9XG4gICAgICBzdXBlcihlbGVtZW50LCBjb25maWcpO1xuXG4gICAgICAvLyBQcml2YXRlXG4gICAgICB0aGlzLl9pc0VuYWJsZWQgPSB0cnVlO1xuICAgICAgdGhpcy5fdGltZW91dCA9IDA7XG4gICAgICB0aGlzLl9pc0hvdmVyZWQgPSBudWxsO1xuICAgICAgdGhpcy5fYWN0aXZlVHJpZ2dlciA9IHt9O1xuICAgICAgdGhpcy5fcG9wcGVyID0gbnVsbDtcbiAgICAgIHRoaXMuX3RlbXBsYXRlRmFjdG9yeSA9IG51bGw7XG4gICAgICB0aGlzLl9uZXdDb250ZW50ID0gbnVsbDtcblxuICAgICAgLy8gUHJvdGVjdGVkXG4gICAgICB0aGlzLnRpcCA9IG51bGw7XG4gICAgICB0aGlzLl9zZXRMaXN0ZW5lcnMoKTtcbiAgICAgIGlmICghdGhpcy5fY29uZmlnLnNlbGVjdG9yKSB7XG4gICAgICAgIHRoaXMuX2ZpeFRpdGxlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gR2V0dGVyc1xuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiBEZWZhdWx0JDM7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdFR5cGUkMztcbiAgICB9XG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgICAgcmV0dXJuIE5BTUUkNDtcbiAgICB9XG5cbiAgICAvLyBQdWJsaWNcbiAgICBlbmFibGUoKSB7XG4gICAgICB0aGlzLl9pc0VuYWJsZWQgPSB0cnVlO1xuICAgIH1cbiAgICBkaXNhYmxlKCkge1xuICAgICAgdGhpcy5faXNFbmFibGVkID0gZmFsc2U7XG4gICAgfVxuICAgIHRvZ2dsZUVuYWJsZWQoKSB7XG4gICAgICB0aGlzLl9pc0VuYWJsZWQgPSAhdGhpcy5faXNFbmFibGVkO1xuICAgIH1cbiAgICB0b2dnbGUoKSB7XG4gICAgICBpZiAoIXRoaXMuX2lzRW5hYmxlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyLmNsaWNrID0gIXRoaXMuX2FjdGl2ZVRyaWdnZXIuY2xpY2s7XG4gICAgICBpZiAodGhpcy5faXNTaG93bigpKSB7XG4gICAgICAgIHRoaXMuX2xlYXZlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2VudGVyKCk7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dCk7XG4gICAgICBFdmVudEhhbmRsZXIub2ZmKHRoaXMuX2VsZW1lbnQuY2xvc2VzdChTRUxFQ1RPUl9NT0RBTCksIEVWRU5UX01PREFMX0hJREUsIHRoaXMuX2hpZGVNb2RhbEhhbmRsZXIpO1xuICAgICAgaWYgKHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWJzLW9yaWdpbmFsLXRpdGxlJykpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtb3JpZ2luYWwtdGl0bGUnKSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9kaXNwb3NlUG9wcGVyKCk7XG4gICAgICBzdXBlci5kaXNwb3NlKCk7XG4gICAgfVxuICAgIHNob3coKSB7XG4gICAgICBpZiAodGhpcy5fZWxlbWVudC5zdHlsZS5kaXNwbGF5ID09PSAnbm9uZScpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgdXNlIHNob3cgb24gdmlzaWJsZSBlbGVtZW50cycpO1xuICAgICAgfVxuICAgICAgaWYgKCEodGhpcy5faXNXaXRoQ29udGVudCgpICYmIHRoaXMuX2lzRW5hYmxlZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3Qgc2hvd0V2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfU0hPVyQyKSk7XG4gICAgICBjb25zdCBzaGFkb3dSb290ID0gZmluZFNoYWRvd1Jvb3QodGhpcy5fZWxlbWVudCk7XG4gICAgICBjb25zdCBpc0luVGhlRG9tID0gKHNoYWRvd1Jvb3QgfHwgdGhpcy5fZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkuY29udGFpbnModGhpcy5fZWxlbWVudCk7XG4gICAgICBpZiAoc2hvd0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQgfHwgIWlzSW5UaGVEb20pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBUT0RPOiB2NiByZW1vdmUgdGhpcyBvciBtYWtlIGl0IG9wdGlvbmFsXG4gICAgICB0aGlzLl9kaXNwb3NlUG9wcGVyKCk7XG4gICAgICBjb25zdCB0aXAgPSB0aGlzLl9nZXRUaXBFbGVtZW50KCk7XG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1kZXNjcmliZWRieScsIHRpcC5nZXRBdHRyaWJ1dGUoJ2lkJykpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBjb250YWluZXJcbiAgICAgIH0gPSB0aGlzLl9jb25maWc7XG4gICAgICBpZiAoIXRoaXMuX2VsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY29udGFpbnModGhpcy50aXApKSB7XG4gICAgICAgIGNvbnRhaW5lci5hcHBlbmQodGlwKTtcbiAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfSU5TRVJURUQpKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3BvcHBlciA9IHRoaXMuX2NyZWF0ZVBvcHBlcih0aXApO1xuICAgICAgdGlwLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XJDIpO1xuXG4gICAgICAvLyBJZiB0aGlzIGlzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2Ugd2UgYWRkIGV4dHJhXG4gICAgICAvLyBlbXB0eSBtb3VzZW92ZXIgbGlzdGVuZXJzIHRvIHRoZSBib2R5J3MgaW1tZWRpYXRlIGNoaWxkcmVuO1xuICAgICAgLy8gb25seSBuZWVkZWQgYmVjYXVzZSBvZiBicm9rZW4gZXZlbnQgZGVsZWdhdGlvbiBvbiBpT1NcbiAgICAgIC8vIGh0dHBzOi8vd3d3LnF1aXJrc21vZGUub3JnL2Jsb2cvYXJjaGl2ZXMvMjAxNC8wMi9tb3VzZV9ldmVudF9idWIuaHRtbFxuICAgICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgW10uY29uY2F0KC4uLmRvY3VtZW50LmJvZHkuY2hpbGRyZW4pKSB7XG4gICAgICAgICAgRXZlbnRIYW5kbGVyLm9uKGVsZW1lbnQsICdtb3VzZW92ZXInLCBub29wKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX1NIT1dOJDIpKTtcbiAgICAgICAgaWYgKHRoaXMuX2lzSG92ZXJlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgICB0aGlzLl9sZWF2ZSgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2lzSG92ZXJlZCA9IGZhbHNlO1xuICAgICAgfTtcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIHRoaXMudGlwLCB0aGlzLl9pc0FuaW1hdGVkKCkpO1xuICAgIH1cbiAgICBoaWRlKCkge1xuICAgICAgaWYgKCF0aGlzLl9pc1Nob3duKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaGlkZUV2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfSElERSQyKSk7XG4gICAgICBpZiAoaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdGlwID0gdGhpcy5fZ2V0VGlwRWxlbWVudCgpO1xuICAgICAgdGlwLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDIpO1xuXG4gICAgICAvLyBJZiB0aGlzIGlzIGEgdG91Y2gtZW5hYmxlZCBkZXZpY2Ugd2UgcmVtb3ZlIHRoZSBleHRyYVxuICAgICAgLy8gZW1wdHkgbW91c2VvdmVyIGxpc3RlbmVycyB3ZSBhZGRlZCBmb3IgaU9TIHN1cHBvcnRcbiAgICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcbiAgICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIFtdLmNvbmNhdCguLi5kb2N1bWVudC5ib2R5LmNoaWxkcmVuKSkge1xuICAgICAgICAgIEV2ZW50SGFuZGxlci5vZmYoZWxlbWVudCwgJ21vdXNlb3ZlcicsIG5vb3ApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyW1RSSUdHRVJfQ0xJQ0tdID0gZmFsc2U7XG4gICAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyW1RSSUdHRVJfRk9DVVNdID0gZmFsc2U7XG4gICAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyW1RSSUdHRVJfSE9WRVJdID0gZmFsc2U7XG4gICAgICB0aGlzLl9pc0hvdmVyZWQgPSBudWxsOyAvLyBpdCBpcyBhIHRyaWNrIHRvIHN1cHBvcnQgbWFudWFsIHRyaWdnZXJpbmdcblxuICAgICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9pc1dpdGhBY3RpdmVUcmlnZ2VyKCkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9pc0hvdmVyZWQpIHtcbiAgICAgICAgICB0aGlzLl9kaXNwb3NlUG9wcGVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtZGVzY3JpYmVkYnknKTtcbiAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfSElEREVOJDIpKTtcbiAgICAgIH07XG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlLCB0aGlzLnRpcCwgdGhpcy5faXNBbmltYXRlZCgpKTtcbiAgICB9XG4gICAgdXBkYXRlKCkge1xuICAgICAgaWYgKHRoaXMuX3BvcHBlcikge1xuICAgICAgICB0aGlzLl9wb3BwZXIudXBkYXRlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUHJvdGVjdGVkXG4gICAgX2lzV2l0aENvbnRlbnQoKSB7XG4gICAgICByZXR1cm4gQm9vbGVhbih0aGlzLl9nZXRUaXRsZSgpKTtcbiAgICB9XG4gICAgX2dldFRpcEVsZW1lbnQoKSB7XG4gICAgICBpZiAoIXRoaXMudGlwKSB7XG4gICAgICAgIHRoaXMudGlwID0gdGhpcy5fY3JlYXRlVGlwRWxlbWVudCh0aGlzLl9uZXdDb250ZW50IHx8IHRoaXMuX2dldENvbnRlbnRGb3JUZW1wbGF0ZSgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnRpcDtcbiAgICB9XG4gICAgX2NyZWF0ZVRpcEVsZW1lbnQoY29udGVudCkge1xuICAgICAgY29uc3QgdGlwID0gdGhpcy5fZ2V0VGVtcGxhdGVGYWN0b3J5KGNvbnRlbnQpLnRvSHRtbCgpO1xuXG4gICAgICAvLyBUT0RPOiByZW1vdmUgdGhpcyBjaGVjayBpbiB2NlxuICAgICAgaWYgKCF0aXApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICB0aXAuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0ZBREUkMiwgQ0xBU1NfTkFNRV9TSE9XJDIpO1xuICAgICAgLy8gVE9ETzogdjYgdGhlIGZvbGxvd2luZyBjYW4gYmUgYWNoaWV2ZWQgd2l0aCBDU1Mgb25seVxuICAgICAgdGlwLmNsYXNzTGlzdC5hZGQoYGJzLSR7dGhpcy5jb25zdHJ1Y3Rvci5OQU1FfS1hdXRvYCk7XG4gICAgICBjb25zdCB0aXBJZCA9IGdldFVJRCh0aGlzLmNvbnN0cnVjdG9yLk5BTUUpLnRvU3RyaW5nKCk7XG4gICAgICB0aXAuc2V0QXR0cmlidXRlKCdpZCcsIHRpcElkKTtcbiAgICAgIGlmICh0aGlzLl9pc0FuaW1hdGVkKCkpIHtcbiAgICAgICAgdGlwLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9GQURFJDIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRpcDtcbiAgICB9XG4gICAgc2V0Q29udGVudChjb250ZW50KSB7XG4gICAgICB0aGlzLl9uZXdDb250ZW50ID0gY29udGVudDtcbiAgICAgIGlmICh0aGlzLl9pc1Nob3duKCkpIHtcbiAgICAgICAgdGhpcy5fZGlzcG9zZVBvcHBlcigpO1xuICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgIH1cbiAgICB9XG4gICAgX2dldFRlbXBsYXRlRmFjdG9yeShjb250ZW50KSB7XG4gICAgICBpZiAodGhpcy5fdGVtcGxhdGVGYWN0b3J5KSB7XG4gICAgICAgIHRoaXMuX3RlbXBsYXRlRmFjdG9yeS5jaGFuZ2VDb250ZW50KGNvbnRlbnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fdGVtcGxhdGVGYWN0b3J5ID0gbmV3IFRlbXBsYXRlRmFjdG9yeSh7XG4gICAgICAgICAgLi4udGhpcy5fY29uZmlnLFxuICAgICAgICAgIC8vIHRoZSBgY29udGVudGAgdmFyIGhhcyB0byBiZSBhZnRlciBgdGhpcy5fY29uZmlnYFxuICAgICAgICAgIC8vIHRvIG92ZXJyaWRlIGNvbmZpZy5jb250ZW50IGluIGNhc2Ugb2YgcG9wb3ZlclxuICAgICAgICAgIGNvbnRlbnQsXG4gICAgICAgICAgZXh0cmFDbGFzczogdGhpcy5fcmVzb2x2ZVBvc3NpYmxlRnVuY3Rpb24odGhpcy5fY29uZmlnLmN1c3RvbUNsYXNzKVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl90ZW1wbGF0ZUZhY3Rvcnk7XG4gICAgfVxuICAgIF9nZXRDb250ZW50Rm9yVGVtcGxhdGUoKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBbU0VMRUNUT1JfVE9PTFRJUF9JTk5FUl06IHRoaXMuX2dldFRpdGxlKClcbiAgICAgIH07XG4gICAgfVxuICAgIF9nZXRUaXRsZSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlUG9zc2libGVGdW5jdGlvbih0aGlzLl9jb25maWcudGl0bGUpIHx8IHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWJzLW9yaWdpbmFsLXRpdGxlJyk7XG4gICAgfVxuXG4gICAgLy8gUHJpdmF0ZVxuICAgIF9pbml0aWFsaXplT25EZWxlZ2F0ZWRUYXJnZXQoZXZlbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLmdldE9yQ3JlYXRlSW5zdGFuY2UoZXZlbnQuZGVsZWdhdGVUYXJnZXQsIHRoaXMuX2dldERlbGVnYXRlQ29uZmlnKCkpO1xuICAgIH1cbiAgICBfaXNBbmltYXRlZCgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9jb25maWcuYW5pbWF0aW9uIHx8IHRoaXMudGlwICYmIHRoaXMudGlwLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0ZBREUkMik7XG4gICAgfVxuICAgIF9pc1Nob3duKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGlwICYmIHRoaXMudGlwLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NIT1ckMik7XG4gICAgfVxuICAgIF9jcmVhdGVQb3BwZXIodGlwKSB7XG4gICAgICBjb25zdCBwbGFjZW1lbnQgPSBleGVjdXRlKHRoaXMuX2NvbmZpZy5wbGFjZW1lbnQsIFt0aGlzLCB0aXAsIHRoaXMuX2VsZW1lbnRdKTtcbiAgICAgIGNvbnN0IGF0dGFjaG1lbnQgPSBBdHRhY2htZW50TWFwW3BsYWNlbWVudC50b1VwcGVyQ2FzZSgpXTtcbiAgICAgIHJldHVybiBjcmVhdGVQb3BwZXIodGhpcy5fZWxlbWVudCwgdGlwLCB0aGlzLl9nZXRQb3BwZXJDb25maWcoYXR0YWNobWVudCkpO1xuICAgIH1cbiAgICBfZ2V0T2Zmc2V0KCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBvZmZzZXRcbiAgICAgIH0gPSB0aGlzLl9jb25maWc7XG4gICAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIG9mZnNldC5zcGxpdCgnLCcpLm1hcCh2YWx1ZSA9PiBOdW1iZXIucGFyc2VJbnQodmFsdWUsIDEwKSk7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gcG9wcGVyRGF0YSA9PiBvZmZzZXQocG9wcGVyRGF0YSwgdGhpcy5fZWxlbWVudCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2Zmc2V0O1xuICAgIH1cbiAgICBfcmVzb2x2ZVBvc3NpYmxlRnVuY3Rpb24oYXJnKSB7XG4gICAgICByZXR1cm4gZXhlY3V0ZShhcmcsIFt0aGlzLl9lbGVtZW50XSk7XG4gICAgfVxuICAgIF9nZXRQb3BwZXJDb25maWcoYXR0YWNobWVudCkge1xuICAgICAgY29uc3QgZGVmYXVsdEJzUG9wcGVyQ29uZmlnID0ge1xuICAgICAgICBwbGFjZW1lbnQ6IGF0dGFjaG1lbnQsXG4gICAgICAgIG1vZGlmaWVyczogW3tcbiAgICAgICAgICBuYW1lOiAnZmxpcCcsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgZmFsbGJhY2tQbGFjZW1lbnRzOiB0aGlzLl9jb25maWcuZmFsbGJhY2tQbGFjZW1lbnRzXG4gICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgbmFtZTogJ29mZnNldCcsXG4gICAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLl9nZXRPZmZzZXQoKVxuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIG5hbWU6ICdwcmV2ZW50T3ZlcmZsb3cnLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGJvdW5kYXJ5OiB0aGlzLl9jb25maWcuYm91bmRhcnlcbiAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICBuYW1lOiAnYXJyb3cnLFxuICAgICAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgICAgIGVsZW1lbnQ6IGAuJHt0aGlzLmNvbnN0cnVjdG9yLk5BTUV9LWFycm93YFxuICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgIG5hbWU6ICdwcmVTZXRQbGFjZW1lbnQnLFxuICAgICAgICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgICAgICAgcGhhc2U6ICdiZWZvcmVNYWluJyxcbiAgICAgICAgICBmbjogZGF0YSA9PiB7XG4gICAgICAgICAgICAvLyBQcmUtc2V0IFBvcHBlcidzIHBsYWNlbWVudCBhdHRyaWJ1dGUgaW4gb3JkZXIgdG8gcmVhZCB0aGUgYXJyb3cgc2l6ZXMgcHJvcGVybHkuXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIFBvcHBlciBtaXhlcyB1cCB0aGUgd2lkdGggYW5kIGhlaWdodCBkaW1lbnNpb25zIHNpbmNlIHRoZSBpbml0aWFsIGFycm93IHN0eWxlIGlzIGZvciB0b3AgcGxhY2VtZW50XG4gICAgICAgICAgICB0aGlzLl9nZXRUaXBFbGVtZW50KCkuc2V0QXR0cmlidXRlKCdkYXRhLXBvcHBlci1wbGFjZW1lbnQnLCBkYXRhLnN0YXRlLnBsYWNlbWVudCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XVxuICAgICAgfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLmRlZmF1bHRCc1BvcHBlckNvbmZpZyxcbiAgICAgICAgLi4uZXhlY3V0ZSh0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnLCBbZGVmYXVsdEJzUG9wcGVyQ29uZmlnXSlcbiAgICAgIH07XG4gICAgfVxuICAgIF9zZXRMaXN0ZW5lcnMoKSB7XG4gICAgICBjb25zdCB0cmlnZ2VycyA9IHRoaXMuX2NvbmZpZy50cmlnZ2VyLnNwbGl0KCcgJyk7XG4gICAgICBmb3IgKGNvbnN0IHRyaWdnZXIgb2YgdHJpZ2dlcnMpIHtcbiAgICAgICAgaWYgKHRyaWdnZXIgPT09ICdjbGljaycpIHtcbiAgICAgICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfQ0xJQ0skMSksIHRoaXMuX2NvbmZpZy5zZWxlY3RvciwgZXZlbnQgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29udGV4dCA9IHRoaXMuX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldChldmVudCk7XG4gICAgICAgICAgICBjb250ZXh0LnRvZ2dsZSgpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKHRyaWdnZXIgIT09IFRSSUdHRVJfTUFOVUFMKSB7XG4gICAgICAgICAgY29uc3QgZXZlbnRJbiA9IHRyaWdnZXIgPT09IFRSSUdHRVJfSE9WRVIgPyB0aGlzLmNvbnN0cnVjdG9yLmV2ZW50TmFtZShFVkVOVF9NT1VTRUVOVEVSKSA6IHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX0ZPQ1VTSU4kMSk7XG4gICAgICAgICAgY29uc3QgZXZlbnRPdXQgPSB0cmlnZ2VyID09PSBUUklHR0VSX0hPVkVSID8gdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfTU9VU0VMRUFWRSkgOiB0aGlzLmNvbnN0cnVjdG9yLmV2ZW50TmFtZShFVkVOVF9GT0NVU09VVCQxKTtcbiAgICAgICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgZXZlbnRJbiwgdGhpcy5fY29uZmlnLnNlbGVjdG9yLCBldmVudCA9PiB7XG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5faW5pdGlhbGl6ZU9uRGVsZWdhdGVkVGFyZ2V0KGV2ZW50KTtcbiAgICAgICAgICAgIGNvbnRleHQuX2FjdGl2ZVRyaWdnZXJbZXZlbnQudHlwZSA9PT0gJ2ZvY3VzaW4nID8gVFJJR0dFUl9GT0NVUyA6IFRSSUdHRVJfSE9WRVJdID0gdHJ1ZTtcbiAgICAgICAgICAgIGNvbnRleHQuX2VudGVyKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIGV2ZW50T3V0LCB0aGlzLl9jb25maWcuc2VsZWN0b3IsIGV2ZW50ID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRleHQgPSB0aGlzLl9pbml0aWFsaXplT25EZWxlZ2F0ZWRUYXJnZXQoZXZlbnQpO1xuICAgICAgICAgICAgY29udGV4dC5fYWN0aXZlVHJpZ2dlcltldmVudC50eXBlID09PSAnZm9jdXNvdXQnID8gVFJJR0dFUl9GT0NVUyA6IFRSSUdHRVJfSE9WRVJdID0gY29udGV4dC5fZWxlbWVudC5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KTtcbiAgICAgICAgICAgIGNvbnRleHQuX2xlYXZlKCk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMuX2hpZGVNb2RhbEhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9lbGVtZW50KSB7XG4gICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudC5jbG9zZXN0KFNFTEVDVE9SX01PREFMKSwgRVZFTlRfTU9EQUxfSElERSwgdGhpcy5faGlkZU1vZGFsSGFuZGxlcik7XG4gICAgfVxuICAgIF9maXhUaXRsZSgpIHtcbiAgICAgIGNvbnN0IHRpdGxlID0gdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RpdGxlJyk7XG4gICAgICBpZiAoIXRpdGxlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICghdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnKSAmJiAhdGhpcy5fZWxlbWVudC50ZXh0Q29udGVudC50cmltKCkpIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCB0aXRsZSk7XG4gICAgICB9XG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1icy1vcmlnaW5hbC10aXRsZScsIHRpdGxlKTsgLy8gRE8gTk9UIFVTRSBJVC4gSXMgb25seSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd0aXRsZScpO1xuICAgIH1cbiAgICBfZW50ZXIoKSB7XG4gICAgICBpZiAodGhpcy5faXNTaG93bigpIHx8IHRoaXMuX2lzSG92ZXJlZCkge1xuICAgICAgICB0aGlzLl9pc0hvdmVyZWQgPSB0cnVlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9pc0hvdmVyZWQgPSB0cnVlO1xuICAgICAgdGhpcy5fc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICh0aGlzLl9pc0hvdmVyZWQpIHtcbiAgICAgICAgICB0aGlzLnNob3coKTtcbiAgICAgICAgfVxuICAgICAgfSwgdGhpcy5fY29uZmlnLmRlbGF5LnNob3cpO1xuICAgIH1cbiAgICBfbGVhdmUoKSB7XG4gICAgICBpZiAodGhpcy5faXNXaXRoQWN0aXZlVHJpZ2dlcigpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2lzSG92ZXJlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5fc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmICghdGhpcy5faXNIb3ZlcmVkKSB7XG4gICAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgICAgIH1cbiAgICAgIH0sIHRoaXMuX2NvbmZpZy5kZWxheS5oaWRlKTtcbiAgICB9XG4gICAgX3NldFRpbWVvdXQoaGFuZGxlciwgdGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xuICAgICAgdGhpcy5fdGltZW91dCA9IHNldFRpbWVvdXQoaGFuZGxlciwgdGltZW91dCk7XG4gICAgfVxuICAgIF9pc1dpdGhBY3RpdmVUcmlnZ2VyKCkge1xuICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5fYWN0aXZlVHJpZ2dlcikuaW5jbHVkZXModHJ1ZSk7XG4gICAgfVxuICAgIF9nZXRDb25maWcoY29uZmlnKSB7XG4gICAgICBjb25zdCBkYXRhQXR0cmlidXRlcyA9IE1hbmlwdWxhdG9yLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xuICAgICAgZm9yIChjb25zdCBkYXRhQXR0cmlidXRlIG9mIE9iamVjdC5rZXlzKGRhdGFBdHRyaWJ1dGVzKSkge1xuICAgICAgICBpZiAoRElTQUxMT1dFRF9BVFRSSUJVVEVTLmhhcyhkYXRhQXR0cmlidXRlKSkge1xuICAgICAgICAgIGRlbGV0ZSBkYXRhQXR0cmlidXRlc1tkYXRhQXR0cmlidXRlXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uZmlnID0ge1xuICAgICAgICAuLi5kYXRhQXR0cmlidXRlcyxcbiAgICAgICAgLi4uKHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnICYmIGNvbmZpZyA/IGNvbmZpZyA6IHt9KVxuICAgICAgfTtcbiAgICAgIGNvbmZpZyA9IHRoaXMuX21lcmdlQ29uZmlnT2JqKGNvbmZpZyk7XG4gICAgICBjb25maWcgPSB0aGlzLl9jb25maWdBZnRlck1lcmdlKGNvbmZpZyk7XG4gICAgICB0aGlzLl90eXBlQ2hlY2tDb25maWcoY29uZmlnKTtcbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuICAgIF9jb25maWdBZnRlck1lcmdlKGNvbmZpZykge1xuICAgICAgY29uZmlnLmNvbnRhaW5lciA9IGNvbmZpZy5jb250YWluZXIgPT09IGZhbHNlID8gZG9jdW1lbnQuYm9keSA6IGdldEVsZW1lbnQoY29uZmlnLmNvbnRhaW5lcik7XG4gICAgICBpZiAodHlwZW9mIGNvbmZpZy5kZWxheSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgY29uZmlnLmRlbGF5ID0ge1xuICAgICAgICAgIHNob3c6IGNvbmZpZy5kZWxheSxcbiAgICAgICAgICBoaWRlOiBjb25maWcuZGVsYXlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgY29uZmlnLnRpdGxlID09PSAnbnVtYmVyJykge1xuICAgICAgICBjb25maWcudGl0bGUgPSBjb25maWcudGl0bGUudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgY29uZmlnLmNvbnRlbnQgPT09ICdudW1iZXInKSB7XG4gICAgICAgIGNvbmZpZy5jb250ZW50ID0gY29uZmlnLmNvbnRlbnQudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuICAgIF9nZXREZWxlZ2F0ZUNvbmZpZygpIHtcbiAgICAgIGNvbnN0IGNvbmZpZyA9IHt9O1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5fY29uZmlnKSkge1xuICAgICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0W2tleV0gIT09IHZhbHVlKSB7XG4gICAgICAgICAgY29uZmlnW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uZmlnLnNlbGVjdG9yID0gZmFsc2U7XG4gICAgICBjb25maWcudHJpZ2dlciA9ICdtYW51YWwnO1xuXG4gICAgICAvLyBJbiB0aGUgZnV0dXJlIGNhbiBiZSByZXBsYWNlZCB3aXRoOlxuICAgICAgLy8gY29uc3Qga2V5c1dpdGhEaWZmZXJlbnRWYWx1ZXMgPSBPYmplY3QuZW50cmllcyh0aGlzLl9jb25maWcpLmZpbHRlcihlbnRyeSA9PiB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRbZW50cnlbMF1dICE9PSB0aGlzLl9jb25maWdbZW50cnlbMF1dKVxuICAgICAgLy8gYE9iamVjdC5mcm9tRW50cmllcyhrZXlzV2l0aERpZmZlcmVudFZhbHVlcylgXG4gICAgICByZXR1cm4gY29uZmlnO1xuICAgIH1cbiAgICBfZGlzcG9zZVBvcHBlcigpIHtcbiAgICAgIGlmICh0aGlzLl9wb3BwZXIpIHtcbiAgICAgICAgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKTtcbiAgICAgICAgdGhpcy5fcG9wcGVyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnRpcCkge1xuICAgICAgICB0aGlzLnRpcC5yZW1vdmUoKTtcbiAgICAgICAgdGhpcy50aXAgPSBudWxsO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFN0YXRpY1xuICAgIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IFRvb2x0aXAuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBjb25maWcpO1xuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBkYXRhW2NvbmZpZ10oKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBqUXVlcnlcbiAgICovXG5cbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luKFRvb2x0aXApO1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgcG9wb3Zlci5qc1xuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cblxuICAvKipcbiAgICogQ29uc3RhbnRzXG4gICAqL1xuXG4gIGNvbnN0IE5BTUUkMyA9ICdwb3BvdmVyJztcbiAgY29uc3QgU0VMRUNUT1JfVElUTEUgPSAnLnBvcG92ZXItaGVhZGVyJztcbiAgY29uc3QgU0VMRUNUT1JfQ09OVEVOVCA9ICcucG9wb3Zlci1ib2R5JztcbiAgY29uc3QgRGVmYXVsdCQyID0ge1xuICAgIC4uLlRvb2x0aXAuRGVmYXVsdCxcbiAgICBjb250ZW50OiAnJyxcbiAgICBvZmZzZXQ6IFswLCA4XSxcbiAgICBwbGFjZW1lbnQ6ICdyaWdodCcsXG4gICAgdGVtcGxhdGU6ICc8ZGl2IGNsYXNzPVwicG9wb3ZlclwiIHJvbGU9XCJ0b29sdGlwXCI+JyArICc8ZGl2IGNsYXNzPVwicG9wb3Zlci1hcnJvd1wiPjwvZGl2PicgKyAnPGgzIGNsYXNzPVwicG9wb3Zlci1oZWFkZXJcIj48L2gzPicgKyAnPGRpdiBjbGFzcz1cInBvcG92ZXItYm9keVwiPjwvZGl2PicgKyAnPC9kaXY+JyxcbiAgICB0cmlnZ2VyOiAnY2xpY2snXG4gIH07XG4gIGNvbnN0IERlZmF1bHRUeXBlJDIgPSB7XG4gICAgLi4uVG9vbHRpcC5EZWZhdWx0VHlwZSxcbiAgICBjb250ZW50OiAnKG51bGx8c3RyaW5nfGVsZW1lbnR8ZnVuY3Rpb24pJ1xuICB9O1xuXG4gIC8qKlxuICAgKiBDbGFzcyBkZWZpbml0aW9uXG4gICAqL1xuXG4gIGNsYXNzIFBvcG92ZXIgZXh0ZW5kcyBUb29sdGlwIHtcbiAgICAvLyBHZXR0ZXJzXG4gICAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xuICAgICAgcmV0dXJuIERlZmF1bHQkMjtcbiAgICB9XG4gICAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICAgIHJldHVybiBEZWZhdWx0VHlwZSQyO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XG4gICAgICByZXR1cm4gTkFNRSQzO1xuICAgIH1cblxuICAgIC8vIE92ZXJyaWRlc1xuICAgIF9pc1dpdGhDb250ZW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX2dldFRpdGxlKCkgfHwgdGhpcy5fZ2V0Q29udGVudCgpO1xuICAgIH1cblxuICAgIC8vIFByaXZhdGVcbiAgICBfZ2V0Q29udGVudEZvclRlbXBsYXRlKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgW1NFTEVDVE9SX1RJVExFXTogdGhpcy5fZ2V0VGl0bGUoKSxcbiAgICAgICAgW1NFTEVDVE9SX0NPTlRFTlRdOiB0aGlzLl9nZXRDb250ZW50KClcbiAgICAgIH07XG4gICAgfVxuICAgIF9nZXRDb250ZW50KCkge1xuICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKHRoaXMuX2NvbmZpZy5jb250ZW50KTtcbiAgICB9XG5cbiAgICAvLyBTdGF0aWNcbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBQb3BvdmVyLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgY29uZmlnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtjb25maWddKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogalF1ZXJ5XG4gICAqL1xuXG4gIGRlZmluZUpRdWVyeVBsdWdpbihQb3BvdmVyKTtcblxuICAvKipcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICogQm9vdHN0cmFwIHNjcm9sbHNweS5qc1xuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cbiAgICovXG5cblxuICAvKipcbiAgICogQ29uc3RhbnRzXG4gICAqL1xuXG4gIGNvbnN0IE5BTUUkMiA9ICdzY3JvbGxzcHknO1xuICBjb25zdCBEQVRBX0tFWSQyID0gJ2JzLnNjcm9sbHNweSc7XG4gIGNvbnN0IEVWRU5UX0tFWSQyID0gYC4ke0RBVEFfS0VZJDJ9YDtcbiAgY29uc3QgREFUQV9BUElfS0VZID0gJy5kYXRhLWFwaSc7XG4gIGNvbnN0IEVWRU5UX0FDVElWQVRFID0gYGFjdGl2YXRlJHtFVkVOVF9LRVkkMn1gO1xuICBjb25zdCBFVkVOVF9DTElDSyA9IGBjbGljayR7RVZFTlRfS0VZJDJ9YDtcbiAgY29uc3QgRVZFTlRfTE9BRF9EQVRBX0FQSSQxID0gYGxvYWQke0VWRU5UX0tFWSQyfSR7REFUQV9BUElfS0VZfWA7XG4gIGNvbnN0IENMQVNTX05BTUVfRFJPUERPV05fSVRFTSA9ICdkcm9wZG93bi1pdGVtJztcbiAgY29uc3QgQ0xBU1NfTkFNRV9BQ1RJVkUkMSA9ICdhY3RpdmUnO1xuICBjb25zdCBTRUxFQ1RPUl9EQVRBX1NQWSA9ICdbZGF0YS1icy1zcHk9XCJzY3JvbGxcIl0nO1xuICBjb25zdCBTRUxFQ1RPUl9UQVJHRVRfTElOS1MgPSAnW2hyZWZdJztcbiAgY29uc3QgU0VMRUNUT1JfTkFWX0xJU1RfR1JPVVAgPSAnLm5hdiwgLmxpc3QtZ3JvdXAnO1xuICBjb25zdCBTRUxFQ1RPUl9OQVZfTElOS1MgPSAnLm5hdi1saW5rJztcbiAgY29uc3QgU0VMRUNUT1JfTkFWX0lURU1TID0gJy5uYXYtaXRlbSc7XG4gIGNvbnN0IFNFTEVDVE9SX0xJU1RfSVRFTVMgPSAnLmxpc3QtZ3JvdXAtaXRlbSc7XG4gIGNvbnN0IFNFTEVDVE9SX0xJTktfSVRFTVMgPSBgJHtTRUxFQ1RPUl9OQVZfTElOS1N9LCAke1NFTEVDVE9SX05BVl9JVEVNU30gPiAke1NFTEVDVE9SX05BVl9MSU5LU30sICR7U0VMRUNUT1JfTElTVF9JVEVNU31gO1xuICBjb25zdCBTRUxFQ1RPUl9EUk9QRE9XTiA9ICcuZHJvcGRvd24nO1xuICBjb25zdCBTRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEUkMSA9ICcuZHJvcGRvd24tdG9nZ2xlJztcbiAgY29uc3QgRGVmYXVsdCQxID0ge1xuICAgIG9mZnNldDogbnVsbCxcbiAgICAvLyBUT0RPOiB2NiBAZGVwcmVjYXRlZCwga2VlcCBpdCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgcmVhc29uc1xuICAgIHJvb3RNYXJnaW46ICcwcHggMHB4IC0yNSUnLFxuICAgIHNtb290aFNjcm9sbDogZmFsc2UsXG4gICAgdGFyZ2V0OiBudWxsLFxuICAgIHRocmVzaG9sZDogWzAuMSwgMC41LCAxXVxuICB9O1xuICBjb25zdCBEZWZhdWx0VHlwZSQxID0ge1xuICAgIG9mZnNldDogJyhudW1iZXJ8bnVsbCknLFxuICAgIC8vIFRPRE8gdjYgQGRlcHJlY2F0ZWQsIGtlZXAgaXQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHJlYXNvbnNcbiAgICByb290TWFyZ2luOiAnc3RyaW5nJyxcbiAgICBzbW9vdGhTY3JvbGw6ICdib29sZWFuJyxcbiAgICB0YXJnZXQ6ICdlbGVtZW50JyxcbiAgICB0aHJlc2hvbGQ6ICdhcnJheSdcbiAgfTtcblxuICAvKipcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxuICAgKi9cblxuICBjbGFzcyBTY3JvbGxTcHkgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICAgIHN1cGVyKGVsZW1lbnQsIGNvbmZpZyk7XG5cbiAgICAgIC8vIHRoaXMuX2VsZW1lbnQgaXMgdGhlIG9ic2VydmFibGVzQ29udGFpbmVyIGFuZCBjb25maWcudGFyZ2V0IHRoZSBtZW51IGxpbmtzIHdyYXBwZXJcbiAgICAgIHRoaXMuX3RhcmdldExpbmtzID0gbmV3IE1hcCgpO1xuICAgICAgdGhpcy5fb2JzZXJ2YWJsZVNlY3Rpb25zID0gbmV3IE1hcCgpO1xuICAgICAgdGhpcy5fcm9vdEVsZW1lbnQgPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMuX2VsZW1lbnQpLm92ZXJmbG93WSA9PT0gJ3Zpc2libGUnID8gbnVsbCA6IHRoaXMuX2VsZW1lbnQ7XG4gICAgICB0aGlzLl9hY3RpdmVUYXJnZXQgPSBudWxsO1xuICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSBudWxsO1xuICAgICAgdGhpcy5fcHJldmlvdXNTY3JvbGxEYXRhID0ge1xuICAgICAgICB2aXNpYmxlRW50cnlUb3A6IDAsXG4gICAgICAgIHBhcmVudFNjcm9sbFRvcDogMFxuICAgICAgfTtcbiAgICAgIHRoaXMucmVmcmVzaCgpOyAvLyBpbml0aWFsaXplXG4gICAgfVxuXG4gICAgLy8gR2V0dGVyc1xuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcbiAgICAgIHJldHVybiBEZWZhdWx0JDE7XG4gICAgfVxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdFR5cGUkMTtcbiAgICB9XG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgICAgcmV0dXJuIE5BTUUkMjtcbiAgICB9XG5cbiAgICAvLyBQdWJsaWNcbiAgICByZWZyZXNoKCkge1xuICAgICAgdGhpcy5faW5pdGlhbGl6ZVRhcmdldHNBbmRPYnNlcnZhYmxlcygpO1xuICAgICAgdGhpcy5fbWF5YmVFbmFibGVTbW9vdGhTY3JvbGwoKTtcbiAgICAgIGlmICh0aGlzLl9vYnNlcnZlcikge1xuICAgICAgICB0aGlzLl9vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9vYnNlcnZlciA9IHRoaXMuX2dldE5ld09ic2VydmVyKCk7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IHNlY3Rpb24gb2YgdGhpcy5fb2JzZXJ2YWJsZVNlY3Rpb25zLnZhbHVlcygpKSB7XG4gICAgICAgIHRoaXMuX29ic2VydmVyLm9ic2VydmUoc2VjdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICB0aGlzLl9vYnNlcnZlci5kaXNjb25uZWN0KCk7XG4gICAgICBzdXBlci5kaXNwb3NlKCk7XG4gICAgfVxuXG4gICAgLy8gUHJpdmF0ZVxuICAgIF9jb25maWdBZnRlck1lcmdlKGNvbmZpZykge1xuICAgICAgLy8gVE9ETzogb24gdjYgdGFyZ2V0IHNob3VsZCBiZSBnaXZlbiBleHBsaWNpdGx5ICYgcmVtb3ZlIHRoZSB7dGFyZ2V0OiAnc3MtdGFyZ2V0J30gY2FzZVxuICAgICAgY29uZmlnLnRhcmdldCA9IGdldEVsZW1lbnQoY29uZmlnLnRhcmdldCkgfHwgZG9jdW1lbnQuYm9keTtcblxuICAgICAgLy8gVE9ETzogdjYgT25seSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgcmVhc29ucy4gVXNlIHJvb3RNYXJnaW4gb25seVxuICAgICAgY29uZmlnLnJvb3RNYXJnaW4gPSBjb25maWcub2Zmc2V0ID8gYCR7Y29uZmlnLm9mZnNldH1weCAwcHggLTMwJWAgOiBjb25maWcucm9vdE1hcmdpbjtcbiAgICAgIGlmICh0eXBlb2YgY29uZmlnLnRocmVzaG9sZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgY29uZmlnLnRocmVzaG9sZCA9IGNvbmZpZy50aHJlc2hvbGQuc3BsaXQoJywnKS5tYXAodmFsdWUgPT4gTnVtYmVyLnBhcnNlRmxvYXQodmFsdWUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb25maWc7XG4gICAgfVxuICAgIF9tYXliZUVuYWJsZVNtb290aFNjcm9sbCgpIHtcbiAgICAgIGlmICghdGhpcy5fY29uZmlnLnNtb290aFNjcm9sbCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIHVucmVnaXN0ZXIgYW55IHByZXZpb3VzIGxpc3RlbmVyc1xuICAgICAgRXZlbnRIYW5kbGVyLm9mZih0aGlzLl9jb25maWcudGFyZ2V0LCBFVkVOVF9DTElDSyk7XG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fY29uZmlnLnRhcmdldCwgRVZFTlRfQ0xJQ0ssIFNFTEVDVE9SX1RBUkdFVF9MSU5LUywgZXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBvYnNlcnZhYmxlU2VjdGlvbiA9IHRoaXMuX29ic2VydmFibGVTZWN0aW9ucy5nZXQoZXZlbnQudGFyZ2V0Lmhhc2gpO1xuICAgICAgICBpZiAob2JzZXJ2YWJsZVNlY3Rpb24pIHtcbiAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgIGNvbnN0IHJvb3QgPSB0aGlzLl9yb290RWxlbWVudCB8fCB3aW5kb3c7XG4gICAgICAgICAgY29uc3QgaGVpZ2h0ID0gb2JzZXJ2YWJsZVNlY3Rpb24ub2Zmc2V0VG9wIC0gdGhpcy5fZWxlbWVudC5vZmZzZXRUb3A7XG4gICAgICAgICAgaWYgKHJvb3Quc2Nyb2xsVG8pIHtcbiAgICAgICAgICAgIHJvb3Quc2Nyb2xsVG8oe1xuICAgICAgICAgICAgICB0b3A6IGhlaWdodCxcbiAgICAgICAgICAgICAgYmVoYXZpb3I6ICdzbW9vdGgnXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBDaHJvbWUgNjAgZG9lc24ndCBzdXBwb3J0IGBzY3JvbGxUb2BcbiAgICAgICAgICByb290LnNjcm9sbFRvcCA9IGhlaWdodDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIF9nZXROZXdPYnNlcnZlcigpIHtcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIHJvb3Q6IHRoaXMuX3Jvb3RFbGVtZW50LFxuICAgICAgICB0aHJlc2hvbGQ6IHRoaXMuX2NvbmZpZy50aHJlc2hvbGQsXG4gICAgICAgIHJvb3RNYXJnaW46IHRoaXMuX2NvbmZpZy5yb290TWFyZ2luXG4gICAgICB9O1xuICAgICAgcmV0dXJuIG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihlbnRyaWVzID0+IHRoaXMuX29ic2VydmVyQ2FsbGJhY2soZW50cmllcyksIG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8vIFRoZSBsb2dpYyBvZiBzZWxlY3Rpb25cbiAgICBfb2JzZXJ2ZXJDYWxsYmFjayhlbnRyaWVzKSB7XG4gICAgICBjb25zdCB0YXJnZXRFbGVtZW50ID0gZW50cnkgPT4gdGhpcy5fdGFyZ2V0TGlua3MuZ2V0KGAjJHtlbnRyeS50YXJnZXQuaWR9YCk7XG4gICAgICBjb25zdCBhY3RpdmF0ZSA9IGVudHJ5ID0+IHtcbiAgICAgICAgdGhpcy5fcHJldmlvdXNTY3JvbGxEYXRhLnZpc2libGVFbnRyeVRvcCA9IGVudHJ5LnRhcmdldC5vZmZzZXRUb3A7XG4gICAgICAgIHRoaXMuX3Byb2Nlc3ModGFyZ2V0RWxlbWVudChlbnRyeSkpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHBhcmVudFNjcm9sbFRvcCA9ICh0aGlzLl9yb290RWxlbWVudCB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpLnNjcm9sbFRvcDtcbiAgICAgIGNvbnN0IHVzZXJTY3JvbGxzRG93biA9IHBhcmVudFNjcm9sbFRvcCA+PSB0aGlzLl9wcmV2aW91c1Njcm9sbERhdGEucGFyZW50U2Nyb2xsVG9wO1xuICAgICAgdGhpcy5fcHJldmlvdXNTY3JvbGxEYXRhLnBhcmVudFNjcm9sbFRvcCA9IHBhcmVudFNjcm9sbFRvcDtcbiAgICAgIGZvciAoY29uc3QgZW50cnkgb2YgZW50cmllcykge1xuICAgICAgICBpZiAoIWVudHJ5LmlzSW50ZXJzZWN0aW5nKSB7XG4gICAgICAgICAgdGhpcy5fYWN0aXZlVGFyZ2V0ID0gbnVsbDtcbiAgICAgICAgICB0aGlzLl9jbGVhckFjdGl2ZUNsYXNzKHRhcmdldEVsZW1lbnQoZW50cnkpKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbnRyeUlzTG93ZXJUaGFuUHJldmlvdXMgPSBlbnRyeS50YXJnZXQub2Zmc2V0VG9wID49IHRoaXMuX3ByZXZpb3VzU2Nyb2xsRGF0YS52aXNpYmxlRW50cnlUb3A7XG4gICAgICAgIC8vIGlmIHdlIGFyZSBzY3JvbGxpbmcgZG93biwgcGljayB0aGUgYmlnZ2VyIG9mZnNldFRvcFxuICAgICAgICBpZiAodXNlclNjcm9sbHNEb3duICYmIGVudHJ5SXNMb3dlclRoYW5QcmV2aW91cykge1xuICAgICAgICAgIGFjdGl2YXRlKGVudHJ5KTtcbiAgICAgICAgICAvLyBpZiBwYXJlbnQgaXNuJ3Qgc2Nyb2xsZWQsIGxldCdzIGtlZXAgdGhlIGZpcnN0IHZpc2libGUgaXRlbSwgYnJlYWtpbmcgdGhlIGl0ZXJhdGlvblxuICAgICAgICAgIGlmICghcGFyZW50U2Nyb2xsVG9wKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaWYgd2UgYXJlIHNjcm9sbGluZyB1cCwgcGljayB0aGUgc21hbGxlc3Qgb2Zmc2V0VG9wXG4gICAgICAgIGlmICghdXNlclNjcm9sbHNEb3duICYmICFlbnRyeUlzTG93ZXJUaGFuUHJldmlvdXMpIHtcbiAgICAgICAgICBhY3RpdmF0ZShlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgX2luaXRpYWxpemVUYXJnZXRzQW5kT2JzZXJ2YWJsZXMoKSB7XG4gICAgICB0aGlzLl90YXJnZXRMaW5rcyA9IG5ldyBNYXAoKTtcbiAgICAgIHRoaXMuX29ic2VydmFibGVTZWN0aW9ucyA9IG5ldyBNYXAoKTtcbiAgICAgIGNvbnN0IHRhcmdldExpbmtzID0gU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9UQVJHRVRfTElOS1MsIHRoaXMuX2NvbmZpZy50YXJnZXQpO1xuICAgICAgZm9yIChjb25zdCBhbmNob3Igb2YgdGFyZ2V0TGlua3MpIHtcbiAgICAgICAgLy8gZW5zdXJlIHRoYXQgdGhlIGFuY2hvciBoYXMgYW4gaWQgYW5kIGlzIG5vdCBkaXNhYmxlZFxuICAgICAgICBpZiAoIWFuY2hvci5oYXNoIHx8IGlzRGlzYWJsZWQoYW5jaG9yKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9ic2VydmFibGVTZWN0aW9uID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShkZWNvZGVVUkkoYW5jaG9yLmhhc2gpLCB0aGlzLl9lbGVtZW50KTtcblxuICAgICAgICAvLyBlbnN1cmUgdGhhdCB0aGUgb2JzZXJ2YWJsZVNlY3Rpb24gZXhpc3RzICYgaXMgdmlzaWJsZVxuICAgICAgICBpZiAoaXNWaXNpYmxlKG9ic2VydmFibGVTZWN0aW9uKSkge1xuICAgICAgICAgIHRoaXMuX3RhcmdldExpbmtzLnNldChkZWNvZGVVUkkoYW5jaG9yLmhhc2gpLCBhbmNob3IpO1xuICAgICAgICAgIHRoaXMuX29ic2VydmFibGVTZWN0aW9ucy5zZXQoYW5jaG9yLmhhc2gsIG9ic2VydmFibGVTZWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBfcHJvY2Vzcyh0YXJnZXQpIHtcbiAgICAgIGlmICh0aGlzLl9hY3RpdmVUYXJnZXQgPT09IHRhcmdldCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9jbGVhckFjdGl2ZUNsYXNzKHRoaXMuX2NvbmZpZy50YXJnZXQpO1xuICAgICAgdGhpcy5fYWN0aXZlVGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUkMSk7XG4gICAgICB0aGlzLl9hY3RpdmF0ZVBhcmVudHModGFyZ2V0KTtcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0FDVElWQVRFLCB7XG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRhcmdldFxuICAgICAgfSk7XG4gICAgfVxuICAgIF9hY3RpdmF0ZVBhcmVudHModGFyZ2V0KSB7XG4gICAgICAvLyBBY3RpdmF0ZSBkcm9wZG93biBwYXJlbnRzXG4gICAgICBpZiAodGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0RST1BET1dOX0lURU0pKSB7XG4gICAgICAgIFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFJDEsIHRhcmdldC5jbG9zZXN0KFNFTEVDVE9SX0RST1BET1dOKSkuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0FDVElWRSQxKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBsaXN0R3JvdXAgb2YgU2VsZWN0b3JFbmdpbmUucGFyZW50cyh0YXJnZXQsIFNFTEVDVE9SX05BVl9MSVNUX0dST1VQKSkge1xuICAgICAgICAvLyBTZXQgdHJpZ2dlcmVkIGxpbmtzIHBhcmVudHMgYXMgYWN0aXZlXG4gICAgICAgIC8vIFdpdGggYm90aCA8dWw+IGFuZCA8bmF2PiBtYXJrdXAgYSBwYXJlbnQgaXMgdGhlIHByZXZpb3VzIHNpYmxpbmcgb2YgYW55IG5hdiBhbmNlc3RvclxuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgU2VsZWN0b3JFbmdpbmUucHJldihsaXN0R3JvdXAsIFNFTEVDVE9SX0xJTktfSVRFTVMpKSB7XG4gICAgICAgICAgaXRlbS5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQUNUSVZFJDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIF9jbGVhckFjdGl2ZUNsYXNzKHBhcmVudCkge1xuICAgICAgcGFyZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9BQ1RJVkUkMSk7XG4gICAgICBjb25zdCBhY3RpdmVOb2RlcyA9IFNlbGVjdG9yRW5naW5lLmZpbmQoYCR7U0VMRUNUT1JfVEFSR0VUX0xJTktTfS4ke0NMQVNTX05BTUVfQUNUSVZFJDF9YCwgcGFyZW50KTtcbiAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBhY3RpdmVOb2Rlcykge1xuICAgICAgICBub2RlLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9BQ1RJVkUkMSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU3RhdGljXG4gICAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gU2Nyb2xsU3B5LmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgY29uZmlnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhW2NvbmZpZ10gPT09IHVuZGVmaW5lZCB8fCBjb25maWcuc3RhcnRzV2l0aCgnXycpIHx8IGNvbmZpZyA9PT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtjb25maWddKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGF0YSBBUEkgaW1wbGVtZW50YXRpb25cbiAgICovXG5cbiAgRXZlbnRIYW5kbGVyLm9uKHdpbmRvdywgRVZFTlRfTE9BRF9EQVRBX0FQSSQxLCAoKSA9PiB7XG4gICAgZm9yIChjb25zdCBzcHkgb2YgU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9EQVRBX1NQWSkpIHtcbiAgICAgIFNjcm9sbFNweS5nZXRPckNyZWF0ZUluc3RhbmNlKHNweSk7XG4gICAgfVxuICB9KTtcblxuICAvKipcbiAgICogalF1ZXJ5XG4gICAqL1xuXG4gIGRlZmluZUpRdWVyeVBsdWdpbihTY3JvbGxTcHkpO1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgdGFiLmpzXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuXG4gIC8qKlxuICAgKiBDb25zdGFudHNcbiAgICovXG5cbiAgY29uc3QgTkFNRSQxID0gJ3RhYic7XG4gIGNvbnN0IERBVEFfS0VZJDEgPSAnYnMudGFiJztcbiAgY29uc3QgRVZFTlRfS0VZJDEgPSBgLiR7REFUQV9LRVkkMX1gO1xuICBjb25zdCBFVkVOVF9ISURFJDEgPSBgaGlkZSR7RVZFTlRfS0VZJDF9YDtcbiAgY29uc3QgRVZFTlRfSElEREVOJDEgPSBgaGlkZGVuJHtFVkVOVF9LRVkkMX1gO1xuICBjb25zdCBFVkVOVF9TSE9XJDEgPSBgc2hvdyR7RVZFTlRfS0VZJDF9YDtcbiAgY29uc3QgRVZFTlRfU0hPV04kMSA9IGBzaG93biR7RVZFTlRfS0VZJDF9YDtcbiAgY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkgPSBgY2xpY2ske0VWRU5UX0tFWSQxfWA7XG4gIGNvbnN0IEVWRU5UX0tFWURPV04gPSBga2V5ZG93biR7RVZFTlRfS0VZJDF9YDtcbiAgY29uc3QgRVZFTlRfTE9BRF9EQVRBX0FQSSA9IGBsb2FkJHtFVkVOVF9LRVkkMX1gO1xuICBjb25zdCBBUlJPV19MRUZUX0tFWSA9ICdBcnJvd0xlZnQnO1xuICBjb25zdCBBUlJPV19SSUdIVF9LRVkgPSAnQXJyb3dSaWdodCc7XG4gIGNvbnN0IEFSUk9XX1VQX0tFWSA9ICdBcnJvd1VwJztcbiAgY29uc3QgQVJST1dfRE9XTl9LRVkgPSAnQXJyb3dEb3duJztcbiAgY29uc3QgSE9NRV9LRVkgPSAnSG9tZSc7XG4gIGNvbnN0IEVORF9LRVkgPSAnRW5kJztcbiAgY29uc3QgQ0xBU1NfTkFNRV9BQ1RJVkUgPSAnYWN0aXZlJztcbiAgY29uc3QgQ0xBU1NfTkFNRV9GQURFJDEgPSAnZmFkZSc7XG4gIGNvbnN0IENMQVNTX05BTUVfU0hPVyQxID0gJ3Nob3cnO1xuICBjb25zdCBDTEFTU19EUk9QRE9XTiA9ICdkcm9wZG93bic7XG4gIGNvbnN0IFNFTEVDVE9SX0RST1BET1dOX1RPR0dMRSA9ICcuZHJvcGRvd24tdG9nZ2xlJztcbiAgY29uc3QgU0VMRUNUT1JfRFJPUERPV05fTUVOVSA9ICcuZHJvcGRvd24tbWVudSc7XG4gIGNvbnN0IE5PVF9TRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEUgPSBgOm5vdCgke1NFTEVDVE9SX0RST1BET1dOX1RPR0dMRX0pYDtcbiAgY29uc3QgU0VMRUNUT1JfVEFCX1BBTkVMID0gJy5saXN0LWdyb3VwLCAubmF2LCBbcm9sZT1cInRhYmxpc3RcIl0nO1xuICBjb25zdCBTRUxFQ1RPUl9PVVRFUiA9ICcubmF2LWl0ZW0sIC5saXN0LWdyb3VwLWl0ZW0nO1xuICBjb25zdCBTRUxFQ1RPUl9JTk5FUiA9IGAubmF2LWxpbmske05PVF9TRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEV9LCAubGlzdC1ncm91cC1pdGVtJHtOT1RfU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFfSwgW3JvbGU9XCJ0YWJcIl0ke05PVF9TRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEV9YDtcbiAgY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEUgPSAnW2RhdGEtYnMtdG9nZ2xlPVwidGFiXCJdLCBbZGF0YS1icy10b2dnbGU9XCJwaWxsXCJdLCBbZGF0YS1icy10b2dnbGU9XCJsaXN0XCJdJzsgLy8gVE9ETzogY291bGQgb25seSBiZSBgdGFiYCBpbiB2NlxuICBjb25zdCBTRUxFQ1RPUl9JTk5FUl9FTEVNID0gYCR7U0VMRUNUT1JfSU5ORVJ9LCAke1NFTEVDVE9SX0RBVEFfVE9HR0xFfWA7XG4gIGNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFX0FDVElWRSA9IGAuJHtDTEFTU19OQU1FX0FDVElWRX1bZGF0YS1icy10b2dnbGU9XCJ0YWJcIl0sIC4ke0NMQVNTX05BTUVfQUNUSVZFfVtkYXRhLWJzLXRvZ2dsZT1cInBpbGxcIl0sIC4ke0NMQVNTX05BTUVfQUNUSVZFfVtkYXRhLWJzLXRvZ2dsZT1cImxpc3RcIl1gO1xuXG4gIC8qKlxuICAgKiBDbGFzcyBkZWZpbml0aW9uXG4gICAqL1xuXG4gIGNsYXNzIFRhYiBleHRlbmRzIEJhc2VDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQpIHtcbiAgICAgIHN1cGVyKGVsZW1lbnQpO1xuICAgICAgdGhpcy5fcGFyZW50ID0gdGhpcy5fZWxlbWVudC5jbG9zZXN0KFNFTEVDVE9SX1RBQl9QQU5FTCk7XG4gICAgICBpZiAoIXRoaXMuX3BhcmVudCkge1xuICAgICAgICByZXR1cm47XG4gICAgICAgIC8vIFRPRE86IHNob3VsZCB0aHJvdyBleGNlcHRpb24gaW4gdjZcbiAgICAgICAgLy8gdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtlbGVtZW50Lm91dGVySFRNTH0gaGFzIG5vdCBhIHZhbGlkIHBhcmVudCAke1NFTEVDVE9SX0lOTkVSX0VMRU19YClcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IHVwIGluaXRpYWwgYXJpYSBhdHRyaWJ1dGVzXG4gICAgICB0aGlzLl9zZXRJbml0aWFsQXR0cmlidXRlcyh0aGlzLl9wYXJlbnQsIHRoaXMuX2dldENoaWxkcmVuKCkpO1xuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0tFWURPV04sIGV2ZW50ID0+IHRoaXMuX2tleWRvd24oZXZlbnQpKTtcbiAgICB9XG5cbiAgICAvLyBHZXR0ZXJzXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgICAgcmV0dXJuIE5BTUUkMTtcbiAgICB9XG5cbiAgICAvLyBQdWJsaWNcbiAgICBzaG93KCkge1xuICAgICAgLy8gU2hvd3MgdGhpcyBlbGVtIGFuZCBkZWFjdGl2YXRlIHRoZSBhY3RpdmUgc2libGluZyBpZiBleGlzdHNcbiAgICAgIGNvbnN0IGlubmVyRWxlbSA9IHRoaXMuX2VsZW1lbnQ7XG4gICAgICBpZiAodGhpcy5fZWxlbUlzQWN0aXZlKGlubmVyRWxlbSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBTZWFyY2ggZm9yIGFjdGl2ZSB0YWIgb24gc2FtZSBwYXJlbnQgdG8gZGVhY3RpdmF0ZSBpdFxuICAgICAgY29uc3QgYWN0aXZlID0gdGhpcy5fZ2V0QWN0aXZlRWxlbSgpO1xuICAgICAgY29uc3QgaGlkZUV2ZW50ID0gYWN0aXZlID8gRXZlbnRIYW5kbGVyLnRyaWdnZXIoYWN0aXZlLCBFVkVOVF9ISURFJDEsIHtcbiAgICAgICAgcmVsYXRlZFRhcmdldDogaW5uZXJFbGVtXG4gICAgICB9KSA6IG51bGw7XG4gICAgICBjb25zdCBzaG93RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcihpbm5lckVsZW0sIEVWRU5UX1NIT1ckMSwge1xuICAgICAgICByZWxhdGVkVGFyZ2V0OiBhY3RpdmVcbiAgICAgIH0pO1xuICAgICAgaWYgKHNob3dFdmVudC5kZWZhdWx0UHJldmVudGVkIHx8IGhpZGVFdmVudCAmJiBoaWRlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9kZWFjdGl2YXRlKGFjdGl2ZSwgaW5uZXJFbGVtKTtcbiAgICAgIHRoaXMuX2FjdGl2YXRlKGlubmVyRWxlbSwgYWN0aXZlKTtcbiAgICB9XG5cbiAgICAvLyBQcml2YXRlXG4gICAgX2FjdGl2YXRlKGVsZW1lbnQsIHJlbGF0ZWRFbGVtKSB7XG4gICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQUNUSVZFKTtcbiAgICAgIHRoaXMuX2FjdGl2YXRlKFNlbGVjdG9yRW5naW5lLmdldEVsZW1lbnRGcm9tU2VsZWN0b3IoZWxlbWVudCkpOyAvLyBTZWFyY2ggYW5kIGFjdGl2YXRlL3Nob3cgdGhlIHByb3BlciBzZWN0aW9uXG5cbiAgICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xuICAgICAgICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3JvbGUnKSAhPT0gJ3RhYicpIHtcbiAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XJDEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLCB0cnVlKTtcbiAgICAgICAgdGhpcy5fdG9nZ2xlRHJvcERvd24oZWxlbWVudCwgdHJ1ZSk7XG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKGVsZW1lbnQsIEVWRU5UX1NIT1dOJDEsIHtcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0OiByZWxhdGVkRWxlbVxuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlLCBlbGVtZW50LCBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0ZBREUkMSkpO1xuICAgIH1cbiAgICBfZGVhY3RpdmF0ZShlbGVtZW50LCByZWxhdGVkRWxlbSkge1xuICAgICAgaWYgKCFlbGVtZW50KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0FDVElWRSk7XG4gICAgICBlbGVtZW50LmJsdXIoKTtcbiAgICAgIHRoaXMuX2RlYWN0aXZhdGUoU2VsZWN0b3JFbmdpbmUuZ2V0RWxlbWVudEZyb21TZWxlY3RvcihlbGVtZW50KSk7IC8vIFNlYXJjaCBhbmQgZGVhY3RpdmF0ZSB0aGUgc2hvd24gc2VjdGlvbiB0b29cblxuICAgICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICAgIGlmIChlbGVtZW50LmdldEF0dHJpYnV0ZSgncm9sZScpICE9PSAndGFiJykge1xuICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1ckMSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgZmFsc2UpO1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgICAgICAgdGhpcy5fdG9nZ2xlRHJvcERvd24oZWxlbWVudCwgZmFsc2UpO1xuICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcihlbGVtZW50LCBFVkVOVF9ISURERU4kMSwge1xuICAgICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHJlbGF0ZWRFbGVtXG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIGVsZW1lbnQsIGVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRkFERSQxKSk7XG4gICAgfVxuICAgIF9rZXlkb3duKGV2ZW50KSB7XG4gICAgICBpZiAoIVtBUlJPV19MRUZUX0tFWSwgQVJST1dfUklHSFRfS0VZLCBBUlJPV19VUF9LRVksIEFSUk9XX0RPV05fS0VZLCBIT01FX0tFWSwgRU5EX0tFWV0uaW5jbHVkZXMoZXZlbnQua2V5KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTsgLy8gc3RvcFByb3BhZ2F0aW9uL3ByZXZlbnREZWZhdWx0IGJvdGggYWRkZWQgdG8gc3VwcG9ydCB1cC9kb3duIGtleXMgd2l0aG91dCBzY3JvbGxpbmcgdGhlIHBhZ2VcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuX2dldENoaWxkcmVuKCkuZmlsdGVyKGVsZW1lbnQgPT4gIWlzRGlzYWJsZWQoZWxlbWVudCkpO1xuICAgICAgbGV0IG5leHRBY3RpdmVFbGVtZW50O1xuICAgICAgaWYgKFtIT01FX0tFWSwgRU5EX0tFWV0uaW5jbHVkZXMoZXZlbnQua2V5KSkge1xuICAgICAgICBuZXh0QWN0aXZlRWxlbWVudCA9IGNoaWxkcmVuW2V2ZW50LmtleSA9PT0gSE9NRV9LRVkgPyAwIDogY2hpbGRyZW4ubGVuZ3RoIC0gMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBpc05leHQgPSBbQVJST1dfUklHSFRfS0VZLCBBUlJPV19ET1dOX0tFWV0uaW5jbHVkZXMoZXZlbnQua2V5KTtcbiAgICAgICAgbmV4dEFjdGl2ZUVsZW1lbnQgPSBnZXROZXh0QWN0aXZlRWxlbWVudChjaGlsZHJlbiwgZXZlbnQudGFyZ2V0LCBpc05leHQsIHRydWUpO1xuICAgICAgfVxuICAgICAgaWYgKG5leHRBY3RpdmVFbGVtZW50KSB7XG4gICAgICAgIG5leHRBY3RpdmVFbGVtZW50LmZvY3VzKHtcbiAgICAgICAgICBwcmV2ZW50U2Nyb2xsOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBUYWIuZ2V0T3JDcmVhdGVJbnN0YW5jZShuZXh0QWN0aXZlRWxlbWVudCkuc2hvdygpO1xuICAgICAgfVxuICAgIH1cbiAgICBfZ2V0Q2hpbGRyZW4oKSB7XG4gICAgICAvLyBjb2xsZWN0aW9uIG9mIGlubmVyIGVsZW1lbnRzXG4gICAgICByZXR1cm4gU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9JTk5FUl9FTEVNLCB0aGlzLl9wYXJlbnQpO1xuICAgIH1cbiAgICBfZ2V0QWN0aXZlRWxlbSgpIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXRDaGlsZHJlbigpLmZpbmQoY2hpbGQgPT4gdGhpcy5fZWxlbUlzQWN0aXZlKGNoaWxkKSkgfHwgbnVsbDtcbiAgICB9XG4gICAgX3NldEluaXRpYWxBdHRyaWJ1dGVzKHBhcmVudCwgY2hpbGRyZW4pIHtcbiAgICAgIHRoaXMuX3NldEF0dHJpYnV0ZUlmTm90RXhpc3RzKHBhcmVudCwgJ3JvbGUnLCAndGFibGlzdCcpO1xuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgICAgICB0aGlzLl9zZXRJbml0aWFsQXR0cmlidXRlc09uQ2hpbGQoY2hpbGQpO1xuICAgICAgfVxuICAgIH1cbiAgICBfc2V0SW5pdGlhbEF0dHJpYnV0ZXNPbkNoaWxkKGNoaWxkKSB7XG4gICAgICBjaGlsZCA9IHRoaXMuX2dldElubmVyRWxlbWVudChjaGlsZCk7XG4gICAgICBjb25zdCBpc0FjdGl2ZSA9IHRoaXMuX2VsZW1Jc0FjdGl2ZShjaGlsZCk7XG4gICAgICBjb25zdCBvdXRlckVsZW0gPSB0aGlzLl9nZXRPdXRlckVsZW1lbnQoY2hpbGQpO1xuICAgICAgY2hpbGQuc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgaXNBY3RpdmUpO1xuICAgICAgaWYgKG91dGVyRWxlbSAhPT0gY2hpbGQpIHtcbiAgICAgICAgdGhpcy5fc2V0QXR0cmlidXRlSWZOb3RFeGlzdHMob3V0ZXJFbGVtLCAncm9sZScsICdwcmVzZW50YXRpb24nKTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNBY3RpdmUpIHtcbiAgICAgICAgY2hpbGQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2V0QXR0cmlidXRlSWZOb3RFeGlzdHMoY2hpbGQsICdyb2xlJywgJ3RhYicpO1xuXG4gICAgICAvLyBzZXQgYXR0cmlidXRlcyB0byB0aGUgcmVsYXRlZCBwYW5lbCB0b29cbiAgICAgIHRoaXMuX3NldEluaXRpYWxBdHRyaWJ1dGVzT25UYXJnZXRQYW5lbChjaGlsZCk7XG4gICAgfVxuICAgIF9zZXRJbml0aWFsQXR0cmlidXRlc09uVGFyZ2V0UGFuZWwoY2hpbGQpIHtcbiAgICAgIGNvbnN0IHRhcmdldCA9IFNlbGVjdG9yRW5naW5lLmdldEVsZW1lbnRGcm9tU2VsZWN0b3IoY2hpbGQpO1xuICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fc2V0QXR0cmlidXRlSWZOb3RFeGlzdHModGFyZ2V0LCAncm9sZScsICd0YWJwYW5lbCcpO1xuICAgICAgaWYgKGNoaWxkLmlkKSB7XG4gICAgICAgIHRoaXMuX3NldEF0dHJpYnV0ZUlmTm90RXhpc3RzKHRhcmdldCwgJ2FyaWEtbGFiZWxsZWRieScsIGAke2NoaWxkLmlkfWApO1xuICAgICAgfVxuICAgIH1cbiAgICBfdG9nZ2xlRHJvcERvd24oZWxlbWVudCwgb3Blbikge1xuICAgICAgY29uc3Qgb3V0ZXJFbGVtID0gdGhpcy5fZ2V0T3V0ZXJFbGVtZW50KGVsZW1lbnQpO1xuICAgICAgaWYgKCFvdXRlckVsZW0uY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX0RST1BET1dOKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB0b2dnbGUgPSAoc2VsZWN0b3IsIGNsYXNzTmFtZSkgPT4ge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShzZWxlY3Rvciwgb3V0ZXJFbGVtKTtcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgICAgICBlbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoY2xhc3NOYW1lLCBvcGVuKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRvZ2dsZShTRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEUsIENMQVNTX05BTUVfQUNUSVZFKTtcbiAgICAgIHRvZ2dsZShTRUxFQ1RPUl9EUk9QRE9XTl9NRU5VLCBDTEFTU19OQU1FX1NIT1ckMSk7XG4gICAgICBvdXRlckVsZW0uc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgb3Blbik7XG4gICAgfVxuICAgIF9zZXRBdHRyaWJ1dGVJZk5vdEV4aXN0cyhlbGVtZW50LCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgICBpZiAoIWVsZW1lbnQuaGFzQXR0cmlidXRlKGF0dHJpYnV0ZSkpIHtcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIF9lbGVtSXNBY3RpdmUoZWxlbSkge1xuICAgICAgcmV0dXJuIGVsZW0uY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfQUNUSVZFKTtcbiAgICB9XG5cbiAgICAvLyBUcnkgdG8gZ2V0IHRoZSBpbm5lciBlbGVtZW50ICh1c3VhbGx5IHRoZSAubmF2LWxpbmspXG4gICAgX2dldElubmVyRWxlbWVudChlbGVtKSB7XG4gICAgICByZXR1cm4gZWxlbS5tYXRjaGVzKFNFTEVDVE9SX0lOTkVSX0VMRU0pID8gZWxlbSA6IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfSU5ORVJfRUxFTSwgZWxlbSk7XG4gICAgfVxuXG4gICAgLy8gVHJ5IHRvIGdldCB0aGUgb3V0ZXIgZWxlbWVudCAodXN1YWxseSB0aGUgLm5hdi1pdGVtKVxuICAgIF9nZXRPdXRlckVsZW1lbnQoZWxlbSkge1xuICAgICAgcmV0dXJuIGVsZW0uY2xvc2VzdChTRUxFQ1RPUl9PVVRFUikgfHwgZWxlbTtcbiAgICB9XG5cbiAgICAvLyBTdGF0aWNcbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBUYWIuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChkYXRhW2NvbmZpZ10gPT09IHVuZGVmaW5lZCB8fCBjb25maWcuc3RhcnRzV2l0aCgnXycpIHx8IGNvbmZpZyA9PT0gJ2NvbnN0cnVjdG9yJykge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgZGF0YVtjb25maWddKCk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRGF0YSBBUEkgaW1wbGVtZW50YXRpb25cbiAgICovXG5cbiAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSwgU0VMRUNUT1JfREFUQV9UT0dHTEUsIGZ1bmN0aW9uIChldmVudCkge1xuICAgIGlmIChbJ0EnLCAnQVJFQSddLmluY2x1ZGVzKHRoaXMudGFnTmFtZSkpIHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxuICAgIGlmIChpc0Rpc2FibGVkKHRoaXMpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIFRhYi5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpLnNob3coKTtcbiAgfSk7XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemUgb24gZm9jdXNcbiAgICovXG4gIEV2ZW50SGFuZGxlci5vbih3aW5kb3csIEVWRU5UX0xPQURfREFUQV9BUEksICgpID0+IHtcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9EQVRBX1RPR0dMRV9BQ1RJVkUpKSB7XG4gICAgICBUYWIuZ2V0T3JDcmVhdGVJbnN0YW5jZShlbGVtZW50KTtcbiAgICB9XG4gIH0pO1xuICAvKipcbiAgICogalF1ZXJ5XG4gICAqL1xuXG4gIGRlZmluZUpRdWVyeVBsdWdpbihUYWIpO1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgdG9hc3QuanNcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4gICAqL1xuXG5cbiAgLyoqXG4gICAqIENvbnN0YW50c1xuICAgKi9cblxuICBjb25zdCBOQU1FID0gJ3RvYXN0JztcbiAgY29uc3QgREFUQV9LRVkgPSAnYnMudG9hc3QnO1xuICBjb25zdCBFVkVOVF9LRVkgPSBgLiR7REFUQV9LRVl9YDtcbiAgY29uc3QgRVZFTlRfTU9VU0VPVkVSID0gYG1vdXNlb3ZlciR7RVZFTlRfS0VZfWA7XG4gIGNvbnN0IEVWRU5UX01PVVNFT1VUID0gYG1vdXNlb3V0JHtFVkVOVF9LRVl9YDtcbiAgY29uc3QgRVZFTlRfRk9DVVNJTiA9IGBmb2N1c2luJHtFVkVOVF9LRVl9YDtcbiAgY29uc3QgRVZFTlRfRk9DVVNPVVQgPSBgZm9jdXNvdXQke0VWRU5UX0tFWX1gO1xuICBjb25zdCBFVkVOVF9ISURFID0gYGhpZGUke0VWRU5UX0tFWX1gO1xuICBjb25zdCBFVkVOVF9ISURERU4gPSBgaGlkZGVuJHtFVkVOVF9LRVl9YDtcbiAgY29uc3QgRVZFTlRfU0hPVyA9IGBzaG93JHtFVkVOVF9LRVl9YDtcbiAgY29uc3QgRVZFTlRfU0hPV04gPSBgc2hvd24ke0VWRU5UX0tFWX1gO1xuICBjb25zdCBDTEFTU19OQU1FX0ZBREUgPSAnZmFkZSc7XG4gIGNvbnN0IENMQVNTX05BTUVfSElERSA9ICdoaWRlJzsgLy8gQGRlcHJlY2F0ZWQgLSBrZXB0IGhlcmUgb25seSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHlcbiAgY29uc3QgQ0xBU1NfTkFNRV9TSE9XID0gJ3Nob3cnO1xuICBjb25zdCBDTEFTU19OQU1FX1NIT1dJTkcgPSAnc2hvd2luZyc7XG4gIGNvbnN0IERlZmF1bHRUeXBlID0ge1xuICAgIGFuaW1hdGlvbjogJ2Jvb2xlYW4nLFxuICAgIGF1dG9oaWRlOiAnYm9vbGVhbicsXG4gICAgZGVsYXk6ICdudW1iZXInXG4gIH07XG4gIGNvbnN0IERlZmF1bHQgPSB7XG4gICAgYW5pbWF0aW9uOiB0cnVlLFxuICAgIGF1dG9oaWRlOiB0cnVlLFxuICAgIGRlbGF5OiA1MDAwXG4gIH07XG5cbiAgLyoqXG4gICAqIENsYXNzIGRlZmluaXRpb25cbiAgICovXG5cbiAgY2xhc3MgVG9hc3QgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcbiAgICAgIHN1cGVyKGVsZW1lbnQsIGNvbmZpZyk7XG4gICAgICB0aGlzLl90aW1lb3V0ID0gbnVsbDtcbiAgICAgIHRoaXMuX2hhc01vdXNlSW50ZXJhY3Rpb24gPSBmYWxzZTtcbiAgICAgIHRoaXMuX2hhc0tleWJvYXJkSW50ZXJhY3Rpb24gPSBmYWxzZTtcbiAgICAgIHRoaXMuX3NldExpc3RlbmVycygpO1xuICAgIH1cblxuICAgIC8vIEdldHRlcnNcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XG4gICAgICByZXR1cm4gRGVmYXVsdDtcbiAgICB9XG4gICAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcbiAgICAgIHJldHVybiBEZWZhdWx0VHlwZTtcbiAgICB9XG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xuICAgICAgcmV0dXJuIE5BTUU7XG4gICAgfVxuXG4gICAgLy8gUHVibGljXG4gICAgc2hvdygpIHtcbiAgICAgIGNvbnN0IHNob3dFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1cpO1xuICAgICAgaWYgKHNob3dFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2NsZWFyVGltZW91dCgpO1xuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5hbmltYXRpb24pIHtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfRkFERSk7XG4gICAgICB9XG4gICAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPV0lORyk7XG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1dOKTtcbiAgICAgICAgdGhpcy5fbWF5YmVTY2hlZHVsZUhpZGUoKTtcbiAgICAgIH07XG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9ISURFKTsgLy8gQGRlcHJlY2F0ZWRcbiAgICAgIHJlZmxvdyh0aGlzLl9lbGVtZW50KTtcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1csIENMQVNTX05BTUVfU0hPV0lORyk7XG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlLCB0aGlzLl9lbGVtZW50LCB0aGlzLl9jb25maWcuYW5pbWF0aW9uKTtcbiAgICB9XG4gICAgaGlkZSgpIHtcbiAgICAgIGlmICghdGhpcy5pc1Nob3duKCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgaGlkZUV2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElERSk7XG4gICAgICBpZiAoaGlkZUV2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0hJREUpOyAvLyBAZGVwcmVjYXRlZFxuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XSU5HLCBDTEFTU19OQU1FX1NIT1cpO1xuICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURERU4pO1xuICAgICAgfTtcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1dJTkcpO1xuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZSwgdGhpcy5fZWxlbWVudCwgdGhpcy5fY29uZmlnLmFuaW1hdGlvbik7XG4gICAgfVxuICAgIGRpc3Bvc2UoKSB7XG4gICAgICB0aGlzLl9jbGVhclRpbWVvdXQoKTtcbiAgICAgIGlmICh0aGlzLmlzU2hvd24oKSkge1xuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XKTtcbiAgICAgIH1cbiAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcbiAgICB9XG4gICAgaXNTaG93bigpIHtcbiAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NIT1cpO1xuICAgIH1cblxuICAgIC8vIFByaXZhdGVcblxuICAgIF9tYXliZVNjaGVkdWxlSGlkZSgpIHtcbiAgICAgIGlmICghdGhpcy5fY29uZmlnLmF1dG9oaWRlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9oYXNNb3VzZUludGVyYWN0aW9uIHx8IHRoaXMuX2hhc0tleWJvYXJkSW50ZXJhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5fdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLmhpZGUoKTtcbiAgICAgIH0sIHRoaXMuX2NvbmZpZy5kZWxheSk7XG4gICAgfVxuICAgIF9vbkludGVyYWN0aW9uKGV2ZW50LCBpc0ludGVyYWN0aW5nKSB7XG4gICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgY2FzZSAnbW91c2VvdmVyJzpcbiAgICAgICAgY2FzZSAnbW91c2VvdXQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2hhc01vdXNlSW50ZXJhY3Rpb24gPSBpc0ludGVyYWN0aW5nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICBjYXNlICdmb2N1c2luJzpcbiAgICAgICAgY2FzZSAnZm9jdXNvdXQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHRoaXMuX2hhc0tleWJvYXJkSW50ZXJhY3Rpb24gPSBpc0ludGVyYWN0aW5nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzSW50ZXJhY3RpbmcpIHtcbiAgICAgICAgdGhpcy5fY2xlYXJUaW1lb3V0KCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG5leHRFbGVtZW50ID0gZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgICAgIGlmICh0aGlzLl9lbGVtZW50ID09PSBuZXh0RWxlbWVudCB8fCB0aGlzLl9lbGVtZW50LmNvbnRhaW5zKG5leHRFbGVtZW50KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9tYXliZVNjaGVkdWxlSGlkZSgpO1xuICAgIH1cbiAgICBfc2V0TGlzdGVuZXJzKCkge1xuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX01PVVNFT1ZFUiwgZXZlbnQgPT4gdGhpcy5fb25JbnRlcmFjdGlvbihldmVudCwgdHJ1ZSkpO1xuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX01PVVNFT1VULCBldmVudCA9PiB0aGlzLl9vbkludGVyYWN0aW9uKGV2ZW50LCBmYWxzZSkpO1xuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0ZPQ1VTSU4sIGV2ZW50ID0+IHRoaXMuX29uSW50ZXJhY3Rpb24oZXZlbnQsIHRydWUpKTtcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9GT0NVU09VVCwgZXZlbnQgPT4gdGhpcy5fb25JbnRlcmFjdGlvbihldmVudCwgZmFsc2UpKTtcbiAgICB9XG4gICAgX2NsZWFyVGltZW91dCgpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcbiAgICAgIHRoaXMuX3RpbWVvdXQgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFN0YXRpY1xuICAgIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc3QgZGF0YSA9IFRvYXN0LmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgY29uZmlnKTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkYXRhW2NvbmZpZ10odGhpcyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxuICAgKi9cblxuICBlbmFibGVEaXNtaXNzVHJpZ2dlcihUb2FzdCk7XG5cbiAgLyoqXG4gICAqIGpRdWVyeVxuICAgKi9cblxuICBkZWZpbmVKUXVlcnlQbHVnaW4oVG9hc3QpO1xuXG4gIC8qKlxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKiBCb290c3RyYXAgaW5kZXgudW1kLmpzXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuICAgKi9cblxuICBjb25zdCBpbmRleF91bWQgPSB7XG4gICAgQWxlcnQsXG4gICAgQnV0dG9uLFxuICAgIENhcm91c2VsLFxuICAgIENvbGxhcHNlLFxuICAgIERyb3Bkb3duLFxuICAgIE1vZGFsLFxuICAgIE9mZmNhbnZhcyxcbiAgICBQb3BvdmVyLFxuICAgIFNjcm9sbFNweSxcbiAgICBUYWIsXG4gICAgVG9hc3QsXG4gICAgVG9vbHRpcFxuICB9O1xuXG4gIHJldHVybiBpbmRleF91bWQ7XG5cbn0pKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJvb3RzdHJhcC5idW5kbGUuanMubWFwXG4iXSwibmFtZXMiOlsiZ2xvYmFsIiwiZmFjdG9yeSIsImV4cG9ydHMiLCJtb2R1bGUiLCJkZWZpbmUiLCJhbWQiLCJnbG9iYWxUaGlzIiwic2VsZiIsImJvb3RzdHJhcCIsImVsZW1lbnRNYXAiLCJNYXAiLCJEYXRhIiwic2V0IiwiZWxlbWVudCIsImtleSIsImluc3RhbmNlIiwiaGFzIiwiaW5zdGFuY2VNYXAiLCJnZXQiLCJzaXplIiwiY29uc29sZSIsImVycm9yIiwiQXJyYXkiLCJmcm9tIiwia2V5cyIsInJlbW92ZSIsImRlbGV0ZSIsIk1BWF9VSUQiLCJNSUxMSVNFQ09ORFNfTVVMVElQTElFUiIsIlRSQU5TSVRJT05fRU5EIiwicGFyc2VTZWxlY3RvciIsInNlbGVjdG9yIiwid2luZG93IiwiQ1NTIiwiZXNjYXBlIiwicmVwbGFjZSIsIm1hdGNoIiwiaWQiLCJ0b1R5cGUiLCJvYmplY3QiLCJ1bmRlZmluZWQiLCJPYmplY3QiLCJwcm90b3R5cGUiLCJ0b1N0cmluZyIsImNhbGwiLCJ0b0xvd2VyQ2FzZSIsImdldFVJRCIsInByZWZpeCIsIk1hdGgiLCJmbG9vciIsInJhbmRvbSIsImRvY3VtZW50IiwiZ2V0RWxlbWVudEJ5SWQiLCJnZXRUcmFuc2l0aW9uRHVyYXRpb25Gcm9tRWxlbWVudCIsInRyYW5zaXRpb25EdXJhdGlvbiIsInRyYW5zaXRpb25EZWxheSIsImdldENvbXB1dGVkU3R5bGUiLCJmbG9hdFRyYW5zaXRpb25EdXJhdGlvbiIsIk51bWJlciIsInBhcnNlRmxvYXQiLCJmbG9hdFRyYW5zaXRpb25EZWxheSIsInNwbGl0IiwidHJpZ2dlclRyYW5zaXRpb25FbmQiLCJkaXNwYXRjaEV2ZW50IiwiRXZlbnQiLCJpc0VsZW1lbnQkMSIsImpxdWVyeSIsIm5vZGVUeXBlIiwiZ2V0RWxlbWVudCIsImxlbmd0aCIsInF1ZXJ5U2VsZWN0b3IiLCJpc1Zpc2libGUiLCJnZXRDbGllbnRSZWN0cyIsImVsZW1lbnRJc1Zpc2libGUiLCJnZXRQcm9wZXJ0eVZhbHVlIiwiY2xvc2VkRGV0YWlscyIsImNsb3Nlc3QiLCJzdW1tYXJ5IiwicGFyZW50Tm9kZSIsImlzRGlzYWJsZWQiLCJOb2RlIiwiRUxFTUVOVF9OT0RFIiwiY2xhc3NMaXN0IiwiY29udGFpbnMiLCJkaXNhYmxlZCIsImhhc0F0dHJpYnV0ZSIsImdldEF0dHJpYnV0ZSIsImZpbmRTaGFkb3dSb290IiwiZG9jdW1lbnRFbGVtZW50IiwiYXR0YWNoU2hhZG93IiwiZ2V0Um9vdE5vZGUiLCJyb290IiwiU2hhZG93Um9vdCIsIm5vb3AiLCJyZWZsb3ciLCJvZmZzZXRIZWlnaHQiLCJnZXRqUXVlcnkiLCJqUXVlcnkiLCJib2R5IiwiRE9NQ29udGVudExvYWRlZENhbGxiYWNrcyIsIm9uRE9NQ29udGVudExvYWRlZCIsImNhbGxiYWNrIiwicmVhZHlTdGF0ZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJwdXNoIiwiaXNSVEwiLCJkaXIiLCJkZWZpbmVKUXVlcnlQbHVnaW4iLCJwbHVnaW4iLCIkIiwibmFtZSIsIk5BTUUiLCJKUVVFUllfTk9fQ09ORkxJQ1QiLCJmbiIsImpRdWVyeUludGVyZmFjZSIsIkNvbnN0cnVjdG9yIiwibm9Db25mbGljdCIsImV4ZWN1dGUiLCJwb3NzaWJsZUNhbGxiYWNrIiwiYXJncyIsImRlZmF1bHRWYWx1ZSIsImV4ZWN1dGVBZnRlclRyYW5zaXRpb24iLCJ0cmFuc2l0aW9uRWxlbWVudCIsIndhaXRGb3JUcmFuc2l0aW9uIiwiZHVyYXRpb25QYWRkaW5nIiwiZW11bGF0ZWREdXJhdGlvbiIsImNhbGxlZCIsImhhbmRsZXIiLCJ0YXJnZXQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwic2V0VGltZW91dCIsImdldE5leHRBY3RpdmVFbGVtZW50IiwibGlzdCIsImFjdGl2ZUVsZW1lbnQiLCJzaG91bGRHZXROZXh0IiwiaXNDeWNsZUFsbG93ZWQiLCJsaXN0TGVuZ3RoIiwiaW5kZXgiLCJpbmRleE9mIiwibWF4IiwibWluIiwibmFtZXNwYWNlUmVnZXgiLCJzdHJpcE5hbWVSZWdleCIsInN0cmlwVWlkUmVnZXgiLCJldmVudFJlZ2lzdHJ5IiwidWlkRXZlbnQiLCJjdXN0b21FdmVudHMiLCJtb3VzZWVudGVyIiwibW91c2VsZWF2ZSIsIm5hdGl2ZUV2ZW50cyIsIlNldCIsIm1ha2VFdmVudFVpZCIsInVpZCIsImdldEVsZW1lbnRFdmVudHMiLCJib290c3RyYXBIYW5kbGVyIiwiZXZlbnQiLCJoeWRyYXRlT2JqIiwiZGVsZWdhdGVUYXJnZXQiLCJvbmVPZmYiLCJFdmVudEhhbmRsZXIiLCJvZmYiLCJ0eXBlIiwiYXBwbHkiLCJib290c3RyYXBEZWxlZ2F0aW9uSGFuZGxlciIsImRvbUVsZW1lbnRzIiwicXVlcnlTZWxlY3RvckFsbCIsImRvbUVsZW1lbnQiLCJmaW5kSGFuZGxlciIsImV2ZW50cyIsImNhbGxhYmxlIiwiZGVsZWdhdGlvblNlbGVjdG9yIiwidmFsdWVzIiwiZmluZCIsIm5vcm1hbGl6ZVBhcmFtZXRlcnMiLCJvcmlnaW5hbFR5cGVFdmVudCIsImRlbGVnYXRpb25GdW5jdGlvbiIsImlzRGVsZWdhdGVkIiwidHlwZUV2ZW50IiwiZ2V0VHlwZUV2ZW50IiwiYWRkSGFuZGxlciIsIndyYXBGdW5jdGlvbiIsInJlbGF0ZWRUYXJnZXQiLCJoYW5kbGVycyIsInByZXZpb3VzRnVuY3Rpb24iLCJyZW1vdmVIYW5kbGVyIiwiQm9vbGVhbiIsInJlbW92ZU5hbWVzcGFjZWRIYW5kbGVycyIsIm5hbWVzcGFjZSIsInN0b3JlRWxlbWVudEV2ZW50IiwiaGFuZGxlcktleSIsImVudHJpZXMiLCJpbmNsdWRlcyIsIm9uIiwib25lIiwiaW5OYW1lc3BhY2UiLCJpc05hbWVzcGFjZSIsInN0YXJ0c1dpdGgiLCJlbGVtZW50RXZlbnQiLCJzbGljZSIsImtleUhhbmRsZXJzIiwidHJpZ2dlciIsImpRdWVyeUV2ZW50IiwiYnViYmxlcyIsIm5hdGl2ZURpc3BhdGNoIiwiZGVmYXVsdFByZXZlbnRlZCIsImlzUHJvcGFnYXRpb25TdG9wcGVkIiwiaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQiLCJpc0RlZmF1bHRQcmV2ZW50ZWQiLCJldnQiLCJjYW5jZWxhYmxlIiwicHJldmVudERlZmF1bHQiLCJvYmoiLCJtZXRhIiwidmFsdWUiLCJfdW51c2VkIiwiZGVmaW5lUHJvcGVydHkiLCJjb25maWd1cmFibGUiLCJub3JtYWxpemVEYXRhIiwiSlNPTiIsInBhcnNlIiwiZGVjb2RlVVJJQ29tcG9uZW50Iiwibm9ybWFsaXplRGF0YUtleSIsImNociIsIk1hbmlwdWxhdG9yIiwic2V0RGF0YUF0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZSIsInJlbW92ZURhdGFBdHRyaWJ1dGUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJnZXREYXRhQXR0cmlidXRlcyIsImF0dHJpYnV0ZXMiLCJic0tleXMiLCJkYXRhc2V0IiwiZmlsdGVyIiwicHVyZUtleSIsImNoYXJBdCIsImdldERhdGFBdHRyaWJ1dGUiLCJDb25maWciLCJEZWZhdWx0IiwiRGVmYXVsdFR5cGUiLCJFcnJvciIsIl9nZXRDb25maWciLCJjb25maWciLCJfbWVyZ2VDb25maWdPYmoiLCJfY29uZmlnQWZ0ZXJNZXJnZSIsIl90eXBlQ2hlY2tDb25maWciLCJqc29uQ29uZmlnIiwiY29uc3RydWN0b3IiLCJjb25maWdUeXBlcyIsInByb3BlcnR5IiwiZXhwZWN0ZWRUeXBlcyIsInZhbHVlVHlwZSIsIlJlZ0V4cCIsInRlc3QiLCJUeXBlRXJyb3IiLCJ0b1VwcGVyQ2FzZSIsIlZFUlNJT04iLCJCYXNlQ29tcG9uZW50IiwiX2VsZW1lbnQiLCJfY29uZmlnIiwiREFUQV9LRVkiLCJkaXNwb3NlIiwiRVZFTlRfS0VZIiwicHJvcGVydHlOYW1lIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIl9xdWV1ZUNhbGxiYWNrIiwiaXNBbmltYXRlZCIsImdldEluc3RhbmNlIiwiZ2V0T3JDcmVhdGVJbnN0YW5jZSIsImV2ZW50TmFtZSIsImdldFNlbGVjdG9yIiwiaHJlZkF0dHJpYnV0ZSIsInRyaW0iLCJtYXAiLCJzZWwiLCJqb2luIiwiU2VsZWN0b3JFbmdpbmUiLCJjb25jYXQiLCJFbGVtZW50IiwiZmluZE9uZSIsImNoaWxkcmVuIiwiY2hpbGQiLCJtYXRjaGVzIiwicGFyZW50cyIsImFuY2VzdG9yIiwicHJldiIsInByZXZpb3VzIiwicHJldmlvdXNFbGVtZW50U2libGluZyIsIm5leHQiLCJuZXh0RWxlbWVudFNpYmxpbmciLCJmb2N1c2FibGVDaGlsZHJlbiIsImZvY3VzYWJsZXMiLCJlbCIsImdldFNlbGVjdG9yRnJvbUVsZW1lbnQiLCJnZXRFbGVtZW50RnJvbVNlbGVjdG9yIiwiZ2V0TXVsdGlwbGVFbGVtZW50c0Zyb21TZWxlY3RvciIsImVuYWJsZURpc21pc3NUcmlnZ2VyIiwiY29tcG9uZW50IiwibWV0aG9kIiwiY2xpY2tFdmVudCIsInRhZ05hbWUiLCJOQU1FJGYiLCJEQVRBX0tFWSRhIiwiRVZFTlRfS0VZJGIiLCJFVkVOVF9DTE9TRSIsIkVWRU5UX0NMT1NFRCIsIkNMQVNTX05BTUVfRkFERSQ1IiwiQ0xBU1NfTkFNRV9TSE9XJDgiLCJBbGVydCIsImNsb3NlIiwiY2xvc2VFdmVudCIsIl9kZXN0cm95RWxlbWVudCIsImVhY2giLCJkYXRhIiwiTkFNRSRlIiwiREFUQV9LRVkkOSIsIkVWRU5UX0tFWSRhIiwiREFUQV9BUElfS0VZJDYiLCJDTEFTU19OQU1FX0FDVElWRSQzIiwiU0VMRUNUT1JfREFUQV9UT0dHTEUkNSIsIkVWRU5UX0NMSUNLX0RBVEFfQVBJJDYiLCJCdXR0b24iLCJ0b2dnbGUiLCJidXR0b24iLCJOQU1FJGQiLCJFVkVOVF9LRVkkOSIsIkVWRU5UX1RPVUNIU1RBUlQiLCJFVkVOVF9UT1VDSE1PVkUiLCJFVkVOVF9UT1VDSEVORCIsIkVWRU5UX1BPSU5URVJET1dOIiwiRVZFTlRfUE9JTlRFUlVQIiwiUE9JTlRFUl9UWVBFX1RPVUNIIiwiUE9JTlRFUl9UWVBFX1BFTiIsIkNMQVNTX05BTUVfUE9JTlRFUl9FVkVOVCIsIlNXSVBFX1RIUkVTSE9MRCIsIkRlZmF1bHQkYyIsImVuZENhbGxiYWNrIiwibGVmdENhbGxiYWNrIiwicmlnaHRDYWxsYmFjayIsIkRlZmF1bHRUeXBlJGMiLCJTd2lwZSIsImlzU3VwcG9ydGVkIiwiX2RlbHRhWCIsIl9zdXBwb3J0UG9pbnRlckV2ZW50cyIsIlBvaW50ZXJFdmVudCIsIl9pbml0RXZlbnRzIiwiX3N0YXJ0IiwidG91Y2hlcyIsImNsaWVudFgiLCJfZXZlbnRJc1BvaW50ZXJQZW5Ub3VjaCIsIl9lbmQiLCJfaGFuZGxlU3dpcGUiLCJfbW92ZSIsImFic0RlbHRhWCIsImFicyIsImRpcmVjdGlvbiIsImFkZCIsInBvaW50ZXJUeXBlIiwibmF2aWdhdG9yIiwibWF4VG91Y2hQb2ludHMiLCJOQU1FJGMiLCJEQVRBX0tFWSQ4IiwiRVZFTlRfS0VZJDgiLCJEQVRBX0FQSV9LRVkkNSIsIkFSUk9XX0xFRlRfS0VZJDEiLCJBUlJPV19SSUdIVF9LRVkkMSIsIlRPVUNIRVZFTlRfQ09NUEFUX1dBSVQiLCJPUkRFUl9ORVhUIiwiT1JERVJfUFJFViIsIkRJUkVDVElPTl9MRUZUIiwiRElSRUNUSU9OX1JJR0hUIiwiRVZFTlRfU0xJREUiLCJFVkVOVF9TTElEIiwiRVZFTlRfS0VZRE9XTiQxIiwiRVZFTlRfTU9VU0VFTlRFUiQxIiwiRVZFTlRfTU9VU0VMRUFWRSQxIiwiRVZFTlRfRFJBR19TVEFSVCIsIkVWRU5UX0xPQURfREFUQV9BUEkkMyIsIkVWRU5UX0NMSUNLX0RBVEFfQVBJJDUiLCJDTEFTU19OQU1FX0NBUk9VU0VMIiwiQ0xBU1NfTkFNRV9BQ1RJVkUkMiIsIkNMQVNTX05BTUVfU0xJREUiLCJDTEFTU19OQU1FX0VORCIsIkNMQVNTX05BTUVfU1RBUlQiLCJDTEFTU19OQU1FX05FWFQiLCJDTEFTU19OQU1FX1BSRVYiLCJTRUxFQ1RPUl9BQ1RJVkUiLCJTRUxFQ1RPUl9JVEVNIiwiU0VMRUNUT1JfQUNUSVZFX0lURU0iLCJTRUxFQ1RPUl9JVEVNX0lNRyIsIlNFTEVDVE9SX0lORElDQVRPUlMiLCJTRUxFQ1RPUl9EQVRBX1NMSURFIiwiU0VMRUNUT1JfREFUQV9SSURFIiwiS0VZX1RPX0RJUkVDVElPTiIsIkRlZmF1bHQkYiIsImludGVydmFsIiwia2V5Ym9hcmQiLCJwYXVzZSIsInJpZGUiLCJ0b3VjaCIsIndyYXAiLCJEZWZhdWx0VHlwZSRiIiwiQ2Fyb3VzZWwiLCJfaW50ZXJ2YWwiLCJfYWN0aXZlRWxlbWVudCIsIl9pc1NsaWRpbmciLCJ0b3VjaFRpbWVvdXQiLCJfc3dpcGVIZWxwZXIiLCJfaW5kaWNhdG9yc0VsZW1lbnQiLCJfYWRkRXZlbnRMaXN0ZW5lcnMiLCJjeWNsZSIsIl9zbGlkZSIsIm5leHRXaGVuVmlzaWJsZSIsImhpZGRlbiIsIl9jbGVhckludGVydmFsIiwiX3VwZGF0ZUludGVydmFsIiwic2V0SW50ZXJ2YWwiLCJfbWF5YmVFbmFibGVDeWNsZSIsInRvIiwiaXRlbXMiLCJfZ2V0SXRlbXMiLCJhY3RpdmVJbmRleCIsIl9nZXRJdGVtSW5kZXgiLCJfZ2V0QWN0aXZlIiwib3JkZXIiLCJkZWZhdWx0SW50ZXJ2YWwiLCJfa2V5ZG93biIsIl9hZGRUb3VjaEV2ZW50TGlzdGVuZXJzIiwiaW1nIiwiZW5kQ2FsbEJhY2siLCJjbGVhclRpbWVvdXQiLCJzd2lwZUNvbmZpZyIsIl9kaXJlY3Rpb25Ub09yZGVyIiwiX3NldEFjdGl2ZUluZGljYXRvckVsZW1lbnQiLCJhY3RpdmVJbmRpY2F0b3IiLCJuZXdBY3RpdmVJbmRpY2F0b3IiLCJlbGVtZW50SW50ZXJ2YWwiLCJwYXJzZUludCIsImlzTmV4dCIsIm5leHRFbGVtZW50IiwibmV4dEVsZW1lbnRJbmRleCIsInRyaWdnZXJFdmVudCIsIl9vcmRlclRvRGlyZWN0aW9uIiwic2xpZGVFdmVudCIsImlzQ3ljbGluZyIsImRpcmVjdGlvbmFsQ2xhc3NOYW1lIiwib3JkZXJDbGFzc05hbWUiLCJjb21wbGV0ZUNhbGxCYWNrIiwiX2lzQW5pbWF0ZWQiLCJjbGVhckludGVydmFsIiwiY2Fyb3VzZWwiLCJzbGlkZUluZGV4IiwiY2Fyb3VzZWxzIiwiTkFNRSRiIiwiREFUQV9LRVkkNyIsIkVWRU5UX0tFWSQ3IiwiREFUQV9BUElfS0VZJDQiLCJFVkVOVF9TSE9XJDYiLCJFVkVOVF9TSE9XTiQ2IiwiRVZFTlRfSElERSQ2IiwiRVZFTlRfSElEREVOJDYiLCJFVkVOVF9DTElDS19EQVRBX0FQSSQ0IiwiQ0xBU1NfTkFNRV9TSE9XJDciLCJDTEFTU19OQU1FX0NPTExBUFNFIiwiQ0xBU1NfTkFNRV9DT0xMQVBTSU5HIiwiQ0xBU1NfTkFNRV9DT0xMQVBTRUQiLCJDTEFTU19OQU1FX0RFRVBFUl9DSElMRFJFTiIsIkNMQVNTX05BTUVfSE9SSVpPTlRBTCIsIldJRFRIIiwiSEVJR0hUIiwiU0VMRUNUT1JfQUNUSVZFUyIsIlNFTEVDVE9SX0RBVEFfVE9HR0xFJDQiLCJEZWZhdWx0JGEiLCJwYXJlbnQiLCJEZWZhdWx0VHlwZSRhIiwiQ29sbGFwc2UiLCJfaXNUcmFuc2l0aW9uaW5nIiwiX3RyaWdnZXJBcnJheSIsInRvZ2dsZUxpc3QiLCJlbGVtIiwiZmlsdGVyRWxlbWVudCIsImZvdW5kRWxlbWVudCIsIl9pbml0aWFsaXplQ2hpbGRyZW4iLCJfYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzIiwiX2lzU2hvd24iLCJoaWRlIiwic2hvdyIsImFjdGl2ZUNoaWxkcmVuIiwiX2dldEZpcnN0TGV2ZWxDaGlsZHJlbiIsInN0YXJ0RXZlbnQiLCJhY3RpdmVJbnN0YW5jZSIsImRpbWVuc2lvbiIsIl9nZXREaW1lbnNpb24iLCJzdHlsZSIsImNvbXBsZXRlIiwiY2FwaXRhbGl6ZWREaW1lbnNpb24iLCJzY3JvbGxTaXplIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0Iiwic2VsZWN0ZWQiLCJ0cmlnZ2VyQXJyYXkiLCJpc09wZW4iLCJ0b3AiLCJib3R0b20iLCJyaWdodCIsImxlZnQiLCJhdXRvIiwiYmFzZVBsYWNlbWVudHMiLCJzdGFydCIsImVuZCIsImNsaXBwaW5nUGFyZW50cyIsInZpZXdwb3J0IiwicG9wcGVyIiwicmVmZXJlbmNlIiwidmFyaWF0aW9uUGxhY2VtZW50cyIsInJlZHVjZSIsImFjYyIsInBsYWNlbWVudCIsInBsYWNlbWVudHMiLCJiZWZvcmVSZWFkIiwicmVhZCIsImFmdGVyUmVhZCIsImJlZm9yZU1haW4iLCJtYWluIiwiYWZ0ZXJNYWluIiwiYmVmb3JlV3JpdGUiLCJ3cml0ZSIsImFmdGVyV3JpdGUiLCJtb2RpZmllclBoYXNlcyIsImdldE5vZGVOYW1lIiwibm9kZU5hbWUiLCJnZXRXaW5kb3ciLCJub2RlIiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3IiwiaXNFbGVtZW50IiwiT3duRWxlbWVudCIsImlzSFRNTEVsZW1lbnQiLCJIVE1MRWxlbWVudCIsImlzU2hhZG93Um9vdCIsImFwcGx5U3R5bGVzIiwiX3JlZiIsInN0YXRlIiwiZWxlbWVudHMiLCJmb3JFYWNoIiwic3R5bGVzIiwiYXNzaWduIiwiZWZmZWN0JDIiLCJfcmVmMiIsImluaXRpYWxTdHlsZXMiLCJwb3NpdGlvbiIsIm9wdGlvbnMiLCJzdHJhdGVneSIsIm1hcmdpbiIsImFycm93Iiwic3R5bGVQcm9wZXJ0aWVzIiwiaGFzT3duUHJvcGVydHkiLCJhdHRyaWJ1dGUiLCJhcHBseVN0eWxlcyQxIiwiZW5hYmxlZCIsInBoYXNlIiwiZWZmZWN0IiwicmVxdWlyZXMiLCJnZXRCYXNlUGxhY2VtZW50Iiwicm91bmQiLCJnZXRVQVN0cmluZyIsInVhRGF0YSIsInVzZXJBZ2VudERhdGEiLCJicmFuZHMiLCJpc0FycmF5IiwiaXRlbSIsImJyYW5kIiwidmVyc2lvbiIsInVzZXJBZ2VudCIsImlzTGF5b3V0Vmlld3BvcnQiLCJpbmNsdWRlU2NhbGUiLCJpc0ZpeGVkU3RyYXRlZ3kiLCJjbGllbnRSZWN0Iiwic2NhbGVYIiwic2NhbGVZIiwib2Zmc2V0V2lkdGgiLCJ3aWR0aCIsImhlaWdodCIsInZpc3VhbFZpZXdwb3J0IiwiYWRkVmlzdWFsT2Zmc2V0cyIsIngiLCJvZmZzZXRMZWZ0IiwieSIsIm9mZnNldFRvcCIsImdldExheW91dFJlY3QiLCJyb290Tm9kZSIsImlzU2FtZU5vZGUiLCJob3N0IiwiZ2V0Q29tcHV0ZWRTdHlsZSQxIiwiaXNUYWJsZUVsZW1lbnQiLCJnZXREb2N1bWVudEVsZW1lbnQiLCJnZXRQYXJlbnROb2RlIiwiYXNzaWduZWRTbG90IiwiZ2V0VHJ1ZU9mZnNldFBhcmVudCIsIm9mZnNldFBhcmVudCIsImdldENvbnRhaW5pbmdCbG9jayIsImlzRmlyZWZveCIsImlzSUUiLCJlbGVtZW50Q3NzIiwiY3VycmVudE5vZGUiLCJjc3MiLCJ0cmFuc2Zvcm0iLCJwZXJzcGVjdGl2ZSIsImNvbnRhaW4iLCJ3aWxsQ2hhbmdlIiwiZ2V0T2Zmc2V0UGFyZW50IiwiZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50Iiwid2l0aGluIiwibWluJDEiLCJtYXgkMSIsIndpdGhpbk1heENsYW1wIiwidiIsImdldEZyZXNoU2lkZU9iamVjdCIsIm1lcmdlUGFkZGluZ09iamVjdCIsInBhZGRpbmdPYmplY3QiLCJleHBhbmRUb0hhc2hNYXAiLCJoYXNoTWFwIiwidG9QYWRkaW5nT2JqZWN0IiwicGFkZGluZyIsInJlY3RzIiwiX3N0YXRlJG1vZGlmaWVyc0RhdGEkIiwiYXJyb3dFbGVtZW50IiwicG9wcGVyT2Zmc2V0cyIsIm1vZGlmaWVyc0RhdGEiLCJiYXNlUGxhY2VtZW50IiwiYXhpcyIsImlzVmVydGljYWwiLCJsZW4iLCJhcnJvd1JlY3QiLCJtaW5Qcm9wIiwibWF4UHJvcCIsImVuZERpZmYiLCJzdGFydERpZmYiLCJhcnJvd09mZnNldFBhcmVudCIsImNsaWVudFNpemUiLCJjbGllbnRIZWlnaHQiLCJjbGllbnRXaWR0aCIsImNlbnRlclRvUmVmZXJlbmNlIiwiY2VudGVyIiwib2Zmc2V0IiwiYXhpc1Byb3AiLCJjZW50ZXJPZmZzZXQiLCJlZmZlY3QkMSIsIl9vcHRpb25zJGVsZW1lbnQiLCJhcnJvdyQxIiwicmVxdWlyZXNJZkV4aXN0cyIsImdldFZhcmlhdGlvbiIsInVuc2V0U2lkZXMiLCJyb3VuZE9mZnNldHNCeURQUiIsIndpbiIsImRwciIsImRldmljZVBpeGVsUmF0aW8iLCJtYXBUb1N0eWxlcyIsIl9PYmplY3QkYXNzaWduMiIsInBvcHBlclJlY3QiLCJ2YXJpYXRpb24iLCJvZmZzZXRzIiwiZ3B1QWNjZWxlcmF0aW9uIiwiYWRhcHRpdmUiLCJyb3VuZE9mZnNldHMiLCJpc0ZpeGVkIiwiX29mZnNldHMkeCIsIl9vZmZzZXRzJHkiLCJfcmVmMyIsImhhc1giLCJoYXNZIiwic2lkZVgiLCJzaWRlWSIsImhlaWdodFByb3AiLCJ3aWR0aFByb3AiLCJvZmZzZXRZIiwib2Zmc2V0WCIsImNvbW1vblN0eWxlcyIsIl9yZWY0IiwiX09iamVjdCRhc3NpZ24iLCJjb21wdXRlU3R5bGVzIiwiX3JlZjUiLCJfb3B0aW9ucyRncHVBY2NlbGVyYXQiLCJfb3B0aW9ucyRhZGFwdGl2ZSIsIl9vcHRpb25zJHJvdW5kT2Zmc2V0cyIsImNvbXB1dGVTdHlsZXMkMSIsInBhc3NpdmUiLCJfb3B0aW9ucyRzY3JvbGwiLCJzY3JvbGwiLCJfb3B0aW9ucyRyZXNpemUiLCJyZXNpemUiLCJzY3JvbGxQYXJlbnRzIiwic2Nyb2xsUGFyZW50IiwidXBkYXRlIiwiZXZlbnRMaXN0ZW5lcnMiLCJoYXNoJDEiLCJnZXRPcHBvc2l0ZVBsYWNlbWVudCIsIm1hdGNoZWQiLCJoYXNoIiwiZ2V0T3Bwb3NpdGVWYXJpYXRpb25QbGFjZW1lbnQiLCJnZXRXaW5kb3dTY3JvbGwiLCJzY3JvbGxMZWZ0IiwicGFnZVhPZmZzZXQiLCJzY3JvbGxUb3AiLCJwYWdlWU9mZnNldCIsImdldFdpbmRvd1Njcm9sbEJhclgiLCJnZXRWaWV3cG9ydFJlY3QiLCJodG1sIiwibGF5b3V0Vmlld3BvcnQiLCJnZXREb2N1bWVudFJlY3QiLCJfZWxlbWVudCRvd25lckRvY3VtZW4iLCJ3aW5TY3JvbGwiLCJzY3JvbGxXaWR0aCIsInNjcm9sbEhlaWdodCIsImlzU2Nyb2xsUGFyZW50IiwiX2dldENvbXB1dGVkU3R5bGUiLCJvdmVyZmxvdyIsIm92ZXJmbG93WCIsIm92ZXJmbG93WSIsImdldFNjcm9sbFBhcmVudCIsImxpc3RTY3JvbGxQYXJlbnRzIiwiaXNCb2R5IiwidXBkYXRlZExpc3QiLCJyZWN0VG9DbGllbnRSZWN0IiwicmVjdCIsImdldElubmVyQm91bmRpbmdDbGllbnRSZWN0IiwiY2xpZW50VG9wIiwiY2xpZW50TGVmdCIsImdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlIiwiY2xpcHBpbmdQYXJlbnQiLCJnZXRDbGlwcGluZ1BhcmVudHMiLCJjYW5Fc2NhcGVDbGlwcGluZyIsImNsaXBwZXJFbGVtZW50IiwiZ2V0Q2xpcHBpbmdSZWN0IiwiYm91bmRhcnkiLCJyb290Qm91bmRhcnkiLCJtYWluQ2xpcHBpbmdQYXJlbnRzIiwiZmlyc3RDbGlwcGluZ1BhcmVudCIsImNsaXBwaW5nUmVjdCIsImFjY1JlY3QiLCJjb21wdXRlT2Zmc2V0cyIsImNvbW1vblgiLCJjb21tb25ZIiwibWFpbkF4aXMiLCJkZXRlY3RPdmVyZmxvdyIsIl9vcHRpb25zIiwiX29wdGlvbnMkcGxhY2VtZW50IiwiX29wdGlvbnMkc3RyYXRlZ3kiLCJfb3B0aW9ucyRib3VuZGFyeSIsIl9vcHRpb25zJHJvb3RCb3VuZGFyeSIsIl9vcHRpb25zJGVsZW1lbnRDb250ZSIsImVsZW1lbnRDb250ZXh0IiwiX29wdGlvbnMkYWx0Qm91bmRhcnkiLCJhbHRCb3VuZGFyeSIsIl9vcHRpb25zJHBhZGRpbmciLCJhbHRDb250ZXh0IiwiY2xpcHBpbmdDbGllbnRSZWN0IiwiY29udGV4dEVsZW1lbnQiLCJyZWZlcmVuY2VDbGllbnRSZWN0IiwicG9wcGVyQ2xpZW50UmVjdCIsImVsZW1lbnRDbGllbnRSZWN0Iiwib3ZlcmZsb3dPZmZzZXRzIiwib2Zmc2V0RGF0YSIsIm11bHRpcGx5IiwiY29tcHV0ZUF1dG9QbGFjZW1lbnQiLCJmbGlwVmFyaWF0aW9ucyIsIl9vcHRpb25zJGFsbG93ZWRBdXRvUCIsImFsbG93ZWRBdXRvUGxhY2VtZW50cyIsInBsYWNlbWVudHMkMSIsImFsbG93ZWRQbGFjZW1lbnRzIiwib3ZlcmZsb3dzIiwic29ydCIsImEiLCJiIiwiZ2V0RXhwYW5kZWRGYWxsYmFja1BsYWNlbWVudHMiLCJvcHBvc2l0ZVBsYWNlbWVudCIsImZsaXAiLCJfc2tpcCIsIl9vcHRpb25zJG1haW5BeGlzIiwiY2hlY2tNYWluQXhpcyIsIl9vcHRpb25zJGFsdEF4aXMiLCJhbHRBeGlzIiwiY2hlY2tBbHRBeGlzIiwic3BlY2lmaWVkRmFsbGJhY2tQbGFjZW1lbnRzIiwiZmFsbGJhY2tQbGFjZW1lbnRzIiwiX29wdGlvbnMkZmxpcFZhcmlhdGlvIiwicHJlZmVycmVkUGxhY2VtZW50IiwiaXNCYXNlUGxhY2VtZW50IiwicmVmZXJlbmNlUmVjdCIsImNoZWNrc01hcCIsIm1ha2VGYWxsYmFja0NoZWNrcyIsImZpcnN0Rml0dGluZ1BsYWNlbWVudCIsImkiLCJfYmFzZVBsYWNlbWVudCIsImlzU3RhcnRWYXJpYXRpb24iLCJtYWluVmFyaWF0aW9uU2lkZSIsImFsdFZhcmlhdGlvblNpZGUiLCJjaGVja3MiLCJldmVyeSIsImNoZWNrIiwibnVtYmVyT2ZDaGVja3MiLCJfbG9vcCIsIl9pIiwiZml0dGluZ1BsYWNlbWVudCIsIl9yZXQiLCJyZXNldCIsImZsaXAkMSIsImdldFNpZGVPZmZzZXRzIiwicHJldmVudGVkT2Zmc2V0cyIsImlzQW55U2lkZUZ1bGx5Q2xpcHBlZCIsInNvbWUiLCJzaWRlIiwicHJldmVudE92ZXJmbG93IiwicmVmZXJlbmNlT3ZlcmZsb3ciLCJwb3BwZXJBbHRPdmVyZmxvdyIsInJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyIsInBvcHBlckVzY2FwZU9mZnNldHMiLCJpc1JlZmVyZW5jZUhpZGRlbiIsImhhc1BvcHBlckVzY2FwZWQiLCJoaWRlJDEiLCJkaXN0YW5jZUFuZFNraWRkaW5nVG9YWSIsImludmVydERpc3RhbmNlIiwic2tpZGRpbmciLCJkaXN0YW5jZSIsIl9vcHRpb25zJG9mZnNldCIsIl9kYXRhJHN0YXRlJHBsYWNlbWVudCIsIm9mZnNldCQxIiwicG9wcGVyT2Zmc2V0cyQxIiwiZ2V0QWx0QXhpcyIsIl9vcHRpb25zJHRldGhlciIsInRldGhlciIsIl9vcHRpb25zJHRldGhlck9mZnNldCIsInRldGhlck9mZnNldCIsInRldGhlck9mZnNldFZhbHVlIiwibm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlIiwib2Zmc2V0TW9kaWZpZXJTdGF0ZSIsIl9vZmZzZXRNb2RpZmllclN0YXRlJCIsIm1haW5TaWRlIiwiYWx0U2lkZSIsImFkZGl0aXZlIiwibWluTGVuIiwibWF4TGVuIiwiYXJyb3dQYWRkaW5nT2JqZWN0IiwiYXJyb3dQYWRkaW5nTWluIiwiYXJyb3dQYWRkaW5nTWF4IiwiYXJyb3dMZW4iLCJtaW5PZmZzZXQiLCJtYXhPZmZzZXQiLCJjbGllbnRPZmZzZXQiLCJvZmZzZXRNb2RpZmllclZhbHVlIiwidGV0aGVyTWluIiwidGV0aGVyTWF4IiwicHJldmVudGVkT2Zmc2V0IiwiX29mZnNldE1vZGlmaWVyU3RhdGUkMiIsIl9tYWluU2lkZSIsIl9hbHRTaWRlIiwiX29mZnNldCIsIl9sZW4iLCJfbWluIiwiX21heCIsImlzT3JpZ2luU2lkZSIsIl9vZmZzZXRNb2RpZmllclZhbHVlIiwiX3RldGhlck1pbiIsIl90ZXRoZXJNYXgiLCJfcHJldmVudGVkT2Zmc2V0IiwicHJldmVudE92ZXJmbG93JDEiLCJnZXRIVE1MRWxlbWVudFNjcm9sbCIsImdldE5vZGVTY3JvbGwiLCJpc0VsZW1lbnRTY2FsZWQiLCJnZXRDb21wb3NpdGVSZWN0IiwiZWxlbWVudE9yVmlydHVhbEVsZW1lbnQiLCJpc09mZnNldFBhcmVudEFuRWxlbWVudCIsIm9mZnNldFBhcmVudElzU2NhbGVkIiwibW9kaWZpZXJzIiwidmlzaXRlZCIsInJlc3VsdCIsIm1vZGlmaWVyIiwiZGVwIiwiZGVwTW9kaWZpZXIiLCJvcmRlck1vZGlmaWVycyIsIm9yZGVyZWRNb2RpZmllcnMiLCJkZWJvdW5jZSIsInBlbmRpbmciLCJQcm9taXNlIiwicmVzb2x2ZSIsInRoZW4iLCJtZXJnZUJ5TmFtZSIsIm1lcmdlZCIsImN1cnJlbnQiLCJleGlzdGluZyIsIkRFRkFVTFRfT1BUSU9OUyIsImFyZVZhbGlkRWxlbWVudHMiLCJhcmd1bWVudHMiLCJfa2V5IiwicG9wcGVyR2VuZXJhdG9yIiwiZ2VuZXJhdG9yT3B0aW9ucyIsIl9nZW5lcmF0b3JPcHRpb25zIiwiX2dlbmVyYXRvck9wdGlvbnMkZGVmIiwiZGVmYXVsdE1vZGlmaWVycyIsIl9nZW5lcmF0b3JPcHRpb25zJGRlZjIiLCJkZWZhdWx0T3B0aW9ucyIsImNyZWF0ZVBvcHBlciIsImVmZmVjdENsZWFudXBGbnMiLCJpc0Rlc3Ryb3llZCIsInNldE9wdGlvbnMiLCJzZXRPcHRpb25zQWN0aW9uIiwiY2xlYW51cE1vZGlmaWVyRWZmZWN0cyIsIm0iLCJydW5Nb2RpZmllckVmZmVjdHMiLCJmb3JjZVVwZGF0ZSIsIl9zdGF0ZSRlbGVtZW50cyIsIl9zdGF0ZSRvcmRlcmVkTW9kaWZpZSIsIl9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIiLCJkZXN0cm95Iiwib25GaXJzdFVwZGF0ZSIsIl9yZWYkb3B0aW9ucyIsImNsZWFudXBGbiIsIm5vb3BGbiIsImNyZWF0ZVBvcHBlciQyIiwiZGVmYXVsdE1vZGlmaWVycyQxIiwiY3JlYXRlUG9wcGVyJDEiLCJQb3BwZXIiLCJmcmVlemUiLCJfX3Byb3RvX18iLCJjcmVhdGVQb3BwZXJCYXNlIiwiY3JlYXRlUG9wcGVyTGl0ZSIsIlN5bWJvbCIsInRvU3RyaW5nVGFnIiwiTkFNRSRhIiwiREFUQV9LRVkkNiIsIkVWRU5UX0tFWSQ2IiwiREFUQV9BUElfS0VZJDMiLCJFU0NBUEVfS0VZJDIiLCJUQUJfS0VZJDEiLCJBUlJPV19VUF9LRVkkMSIsIkFSUk9XX0RPV05fS0VZJDEiLCJSSUdIVF9NT1VTRV9CVVRUT04iLCJFVkVOVF9ISURFJDUiLCJFVkVOVF9ISURERU4kNSIsIkVWRU5UX1NIT1ckNSIsIkVWRU5UX1NIT1dOJDUiLCJFVkVOVF9DTElDS19EQVRBX0FQSSQzIiwiRVZFTlRfS0VZRE9XTl9EQVRBX0FQSSIsIkVWRU5UX0tFWVVQX0RBVEFfQVBJIiwiQ0xBU1NfTkFNRV9TSE9XJDYiLCJDTEFTU19OQU1FX0RST1BVUCIsIkNMQVNTX05BTUVfRFJPUEVORCIsIkNMQVNTX05BTUVfRFJPUFNUQVJUIiwiQ0xBU1NfTkFNRV9EUk9QVVBfQ0VOVEVSIiwiQ0xBU1NfTkFNRV9EUk9QRE9XTl9DRU5URVIiLCJTRUxFQ1RPUl9EQVRBX1RPR0dMRSQzIiwiU0VMRUNUT1JfREFUQV9UT0dHTEVfU0hPV04iLCJTRUxFQ1RPUl9NRU5VIiwiU0VMRUNUT1JfTkFWQkFSIiwiU0VMRUNUT1JfTkFWQkFSX05BViIsIlNFTEVDVE9SX1ZJU0lCTEVfSVRFTVMiLCJQTEFDRU1FTlRfVE9QIiwiUExBQ0VNRU5UX1RPUEVORCIsIlBMQUNFTUVOVF9CT1RUT00iLCJQTEFDRU1FTlRfQk9UVE9NRU5EIiwiUExBQ0VNRU5UX1JJR0hUIiwiUExBQ0VNRU5UX0xFRlQiLCJQTEFDRU1FTlRfVE9QQ0VOVEVSIiwiUExBQ0VNRU5UX0JPVFRPTUNFTlRFUiIsIkRlZmF1bHQkOSIsImF1dG9DbG9zZSIsImRpc3BsYXkiLCJwb3BwZXJDb25maWciLCJEZWZhdWx0VHlwZSQ5IiwiRHJvcGRvd24iLCJfcG9wcGVyIiwiX3BhcmVudCIsIl9tZW51IiwiX2luTmF2YmFyIiwiX2RldGVjdE5hdmJhciIsInNob3dFdmVudCIsIl9jcmVhdGVQb3BwZXIiLCJmb2N1cyIsIl9jb21wbGV0ZUhpZGUiLCJoaWRlRXZlbnQiLCJyZWZlcmVuY2VFbGVtZW50IiwiX2dldFBvcHBlckNvbmZpZyIsIl9nZXRQbGFjZW1lbnQiLCJwYXJlbnREcm9wZG93biIsImlzRW5kIiwiX2dldE9mZnNldCIsInBvcHBlckRhdGEiLCJkZWZhdWx0QnNQb3BwZXJDb25maWciLCJfc2VsZWN0TWVudUl0ZW0iLCJjbGVhck1lbnVzIiwib3BlblRvZ2dsZXMiLCJjb250ZXh0IiwiY29tcG9zZWRQYXRoIiwiaXNNZW51VGFyZ2V0IiwiZGF0YUFwaUtleWRvd25IYW5kbGVyIiwiaXNJbnB1dCIsImlzRXNjYXBlRXZlbnQiLCJpc1VwT3JEb3duRXZlbnQiLCJnZXRUb2dnbGVCdXR0b24iLCJzdG9wUHJvcGFnYXRpb24iLCJOQU1FJDkiLCJDTEFTU19OQU1FX0ZBREUkNCIsIkNMQVNTX05BTUVfU0hPVyQ1IiwiRVZFTlRfTU9VU0VET1dOIiwiRGVmYXVsdCQ4IiwiY2xhc3NOYW1lIiwiY2xpY2tDYWxsYmFjayIsInJvb3RFbGVtZW50IiwiRGVmYXVsdFR5cGUkOCIsIkJhY2tkcm9wIiwiX2lzQXBwZW5kZWQiLCJfYXBwZW5kIiwiX2dldEVsZW1lbnQiLCJfZW11bGF0ZUFuaW1hdGlvbiIsImJhY2tkcm9wIiwiY3JlYXRlRWxlbWVudCIsImFwcGVuZCIsIk5BTUUkOCIsIkRBVEFfS0VZJDUiLCJFVkVOVF9LRVkkNSIsIkVWRU5UX0ZPQ1VTSU4kMiIsIkVWRU5UX0tFWURPV05fVEFCIiwiVEFCX0tFWSIsIlRBQl9OQVZfRk9SV0FSRCIsIlRBQl9OQVZfQkFDS1dBUkQiLCJEZWZhdWx0JDciLCJhdXRvZm9jdXMiLCJ0cmFwRWxlbWVudCIsIkRlZmF1bHRUeXBlJDciLCJGb2N1c1RyYXAiLCJfaXNBY3RpdmUiLCJfbGFzdFRhYk5hdkRpcmVjdGlvbiIsImFjdGl2YXRlIiwiX2hhbmRsZUZvY3VzaW4iLCJfaGFuZGxlS2V5ZG93biIsImRlYWN0aXZhdGUiLCJzaGlmdEtleSIsIlNFTEVDVE9SX0ZJWEVEX0NPTlRFTlQiLCJTRUxFQ1RPUl9TVElDS1lfQ09OVEVOVCIsIlBST1BFUlRZX1BBRERJTkciLCJQUk9QRVJUWV9NQVJHSU4iLCJTY3JvbGxCYXJIZWxwZXIiLCJnZXRXaWR0aCIsImRvY3VtZW50V2lkdGgiLCJpbm5lcldpZHRoIiwiX2Rpc2FibGVPdmVyRmxvdyIsIl9zZXRFbGVtZW50QXR0cmlidXRlcyIsImNhbGN1bGF0ZWRWYWx1ZSIsIl9yZXNldEVsZW1lbnRBdHRyaWJ1dGVzIiwiaXNPdmVyZmxvd2luZyIsIl9zYXZlSW5pdGlhbEF0dHJpYnV0ZSIsInN0eWxlUHJvcGVydHkiLCJzY3JvbGxiYXJXaWR0aCIsIm1hbmlwdWxhdGlvbkNhbGxCYWNrIiwic2V0UHJvcGVydHkiLCJfYXBwbHlNYW5pcHVsYXRpb25DYWxsYmFjayIsImFjdHVhbFZhbHVlIiwicmVtb3ZlUHJvcGVydHkiLCJjYWxsQmFjayIsIk5BTUUkNyIsIkRBVEFfS0VZJDQiLCJFVkVOVF9LRVkkNCIsIkRBVEFfQVBJX0tFWSQyIiwiRVNDQVBFX0tFWSQxIiwiRVZFTlRfSElERSQ0IiwiRVZFTlRfSElERV9QUkVWRU5URUQkMSIsIkVWRU5UX0hJRERFTiQ0IiwiRVZFTlRfU0hPVyQ0IiwiRVZFTlRfU0hPV04kNCIsIkVWRU5UX1JFU0laRSQxIiwiRVZFTlRfQ0xJQ0tfRElTTUlTUyIsIkVWRU5UX01PVVNFRE9XTl9ESVNNSVNTIiwiRVZFTlRfS0VZRE9XTl9ESVNNSVNTJDEiLCJFVkVOVF9DTElDS19EQVRBX0FQSSQyIiwiQ0xBU1NfTkFNRV9PUEVOIiwiQ0xBU1NfTkFNRV9GQURFJDMiLCJDTEFTU19OQU1FX1NIT1ckNCIsIkNMQVNTX05BTUVfU1RBVElDIiwiT1BFTl9TRUxFQ1RPUiQxIiwiU0VMRUNUT1JfRElBTE9HIiwiU0VMRUNUT1JfTU9EQUxfQk9EWSIsIlNFTEVDVE9SX0RBVEFfVE9HR0xFJDIiLCJEZWZhdWx0JDYiLCJEZWZhdWx0VHlwZSQ2IiwiTW9kYWwiLCJfZGlhbG9nIiwiX2JhY2tkcm9wIiwiX2luaXRpYWxpemVCYWNrRHJvcCIsIl9mb2N1c3RyYXAiLCJfaW5pdGlhbGl6ZUZvY3VzVHJhcCIsIl9zY3JvbGxCYXIiLCJfYWRqdXN0RGlhbG9nIiwiX3Nob3dFbGVtZW50IiwiX2hpZGVNb2RhbCIsImhhbmRsZVVwZGF0ZSIsIm1vZGFsQm9keSIsInRyYW5zaXRpb25Db21wbGV0ZSIsIl90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uIiwiZXZlbnQyIiwiX3Jlc2V0QWRqdXN0bWVudHMiLCJpc01vZGFsT3ZlcmZsb3dpbmciLCJpbml0aWFsT3ZlcmZsb3dZIiwiaXNCb2R5T3ZlcmZsb3dpbmciLCJwYWRkaW5nTGVmdCIsInBhZGRpbmdSaWdodCIsImFscmVhZHlPcGVuIiwiTkFNRSQ2IiwiREFUQV9LRVkkMyIsIkVWRU5UX0tFWSQzIiwiREFUQV9BUElfS0VZJDEiLCJFVkVOVF9MT0FEX0RBVEFfQVBJJDIiLCJFU0NBUEVfS0VZIiwiQ0xBU1NfTkFNRV9TSE9XJDMiLCJDTEFTU19OQU1FX1NIT1dJTkckMSIsIkNMQVNTX05BTUVfSElESU5HIiwiQ0xBU1NfTkFNRV9CQUNLRFJPUCIsIk9QRU5fU0VMRUNUT1IiLCJFVkVOVF9TSE9XJDMiLCJFVkVOVF9TSE9XTiQzIiwiRVZFTlRfSElERSQzIiwiRVZFTlRfSElERV9QUkVWRU5URUQiLCJFVkVOVF9ISURERU4kMyIsIkVWRU5UX1JFU0laRSIsIkVWRU5UX0NMSUNLX0RBVEFfQVBJJDEiLCJFVkVOVF9LRVlET1dOX0RJU01JU1MiLCJTRUxFQ1RPUl9EQVRBX1RPR0dMRSQxIiwiRGVmYXVsdCQ1IiwiRGVmYXVsdFR5cGUkNSIsIk9mZmNhbnZhcyIsImJsdXIiLCJjb21wbGV0ZUNhbGxiYWNrIiwiQVJJQV9BVFRSSUJVVEVfUEFUVEVSTiIsIkRlZmF1bHRBbGxvd2xpc3QiLCJhcmVhIiwiYnIiLCJjb2wiLCJjb2RlIiwiZGQiLCJkaXYiLCJkbCIsImR0IiwiZW0iLCJociIsImgxIiwiaDIiLCJoMyIsImg0IiwiaDUiLCJoNiIsImxpIiwib2wiLCJwIiwicHJlIiwicyIsInNtYWxsIiwic3BhbiIsInN1YiIsInN1cCIsInN0cm9uZyIsInUiLCJ1bCIsInVyaUF0dHJpYnV0ZXMiLCJTQUZFX1VSTF9QQVRURVJOIiwiYWxsb3dlZEF0dHJpYnV0ZSIsImFsbG93ZWRBdHRyaWJ1dGVMaXN0IiwiYXR0cmlidXRlTmFtZSIsIm5vZGVWYWx1ZSIsImF0dHJpYnV0ZVJlZ2V4IiwicmVnZXgiLCJzYW5pdGl6ZUh0bWwiLCJ1bnNhZmVIdG1sIiwiYWxsb3dMaXN0Iiwic2FuaXRpemVGdW5jdGlvbiIsImRvbVBhcnNlciIsIkRPTVBhcnNlciIsImNyZWF0ZWREb2N1bWVudCIsInBhcnNlRnJvbVN0cmluZyIsImVsZW1lbnROYW1lIiwiYXR0cmlidXRlTGlzdCIsImFsbG93ZWRBdHRyaWJ1dGVzIiwiaW5uZXJIVE1MIiwiTkFNRSQ1IiwiRGVmYXVsdCQ0IiwiY29udGVudCIsImV4dHJhQ2xhc3MiLCJzYW5pdGl6ZSIsInNhbml0aXplRm4iLCJ0ZW1wbGF0ZSIsIkRlZmF1bHRUeXBlJDQiLCJEZWZhdWx0Q29udGVudFR5cGUiLCJlbnRyeSIsIlRlbXBsYXRlRmFjdG9yeSIsImdldENvbnRlbnQiLCJfcmVzb2x2ZVBvc3NpYmxlRnVuY3Rpb24iLCJoYXNDb250ZW50IiwiY2hhbmdlQ29udGVudCIsIl9jaGVja0NvbnRlbnQiLCJ0b0h0bWwiLCJ0ZW1wbGF0ZVdyYXBwZXIiLCJfbWF5YmVTYW5pdGl6ZSIsInRleHQiLCJfc2V0Q29udGVudCIsImFyZyIsInRlbXBsYXRlRWxlbWVudCIsIl9wdXRFbGVtZW50SW5UZW1wbGF0ZSIsInRleHRDb250ZW50IiwiTkFNRSQ0IiwiRElTQUxMT1dFRF9BVFRSSUJVVEVTIiwiQ0xBU1NfTkFNRV9GQURFJDIiLCJDTEFTU19OQU1FX01PREFMIiwiQ0xBU1NfTkFNRV9TSE9XJDIiLCJTRUxFQ1RPUl9UT09MVElQX0lOTkVSIiwiU0VMRUNUT1JfTU9EQUwiLCJFVkVOVF9NT0RBTF9ISURFIiwiVFJJR0dFUl9IT1ZFUiIsIlRSSUdHRVJfRk9DVVMiLCJUUklHR0VSX0NMSUNLIiwiVFJJR0dFUl9NQU5VQUwiLCJFVkVOVF9ISURFJDIiLCJFVkVOVF9ISURERU4kMiIsIkVWRU5UX1NIT1ckMiIsIkVWRU5UX1NIT1dOJDIiLCJFVkVOVF9JTlNFUlRFRCIsIkVWRU5UX0NMSUNLJDEiLCJFVkVOVF9GT0NVU0lOJDEiLCJFVkVOVF9GT0NVU09VVCQxIiwiRVZFTlRfTU9VU0VFTlRFUiIsIkVWRU5UX01PVVNFTEVBVkUiLCJBdHRhY2htZW50TWFwIiwiQVVUTyIsIlRPUCIsIlJJR0hUIiwiQk9UVE9NIiwiTEVGVCIsIkRlZmF1bHQkMyIsImFuaW1hdGlvbiIsImNvbnRhaW5lciIsImN1c3RvbUNsYXNzIiwiZGVsYXkiLCJ0aXRsZSIsIkRlZmF1bHRUeXBlJDMiLCJUb29sdGlwIiwiX2lzRW5hYmxlZCIsIl90aW1lb3V0IiwiX2lzSG92ZXJlZCIsIl9hY3RpdmVUcmlnZ2VyIiwiX3RlbXBsYXRlRmFjdG9yeSIsIl9uZXdDb250ZW50IiwidGlwIiwiX3NldExpc3RlbmVycyIsIl9maXhUaXRsZSIsImVuYWJsZSIsImRpc2FibGUiLCJ0b2dnbGVFbmFibGVkIiwiY2xpY2siLCJfbGVhdmUiLCJfZW50ZXIiLCJfaGlkZU1vZGFsSGFuZGxlciIsIl9kaXNwb3NlUG9wcGVyIiwiX2lzV2l0aENvbnRlbnQiLCJzaGFkb3dSb290IiwiaXNJblRoZURvbSIsIl9nZXRUaXBFbGVtZW50IiwiX2lzV2l0aEFjdGl2ZVRyaWdnZXIiLCJfZ2V0VGl0bGUiLCJfY3JlYXRlVGlwRWxlbWVudCIsIl9nZXRDb250ZW50Rm9yVGVtcGxhdGUiLCJfZ2V0VGVtcGxhdGVGYWN0b3J5IiwidGlwSWQiLCJzZXRDb250ZW50IiwiX2luaXRpYWxpemVPbkRlbGVnYXRlZFRhcmdldCIsIl9nZXREZWxlZ2F0ZUNvbmZpZyIsImF0dGFjaG1lbnQiLCJ0cmlnZ2VycyIsImV2ZW50SW4iLCJldmVudE91dCIsIl9zZXRUaW1lb3V0IiwidGltZW91dCIsImRhdGFBdHRyaWJ1dGVzIiwiZGF0YUF0dHJpYnV0ZSIsIk5BTUUkMyIsIlNFTEVDVE9SX1RJVExFIiwiU0VMRUNUT1JfQ09OVEVOVCIsIkRlZmF1bHQkMiIsIkRlZmF1bHRUeXBlJDIiLCJQb3BvdmVyIiwiX2dldENvbnRlbnQiLCJOQU1FJDIiLCJEQVRBX0tFWSQyIiwiRVZFTlRfS0VZJDIiLCJEQVRBX0FQSV9LRVkiLCJFVkVOVF9BQ1RJVkFURSIsIkVWRU5UX0NMSUNLIiwiRVZFTlRfTE9BRF9EQVRBX0FQSSQxIiwiQ0xBU1NfTkFNRV9EUk9QRE9XTl9JVEVNIiwiQ0xBU1NfTkFNRV9BQ1RJVkUkMSIsIlNFTEVDVE9SX0RBVEFfU1BZIiwiU0VMRUNUT1JfVEFSR0VUX0xJTktTIiwiU0VMRUNUT1JfTkFWX0xJU1RfR1JPVVAiLCJTRUxFQ1RPUl9OQVZfTElOS1MiLCJTRUxFQ1RPUl9OQVZfSVRFTVMiLCJTRUxFQ1RPUl9MSVNUX0lURU1TIiwiU0VMRUNUT1JfTElOS19JVEVNUyIsIlNFTEVDVE9SX0RST1BET1dOIiwiU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFJDEiLCJEZWZhdWx0JDEiLCJyb290TWFyZ2luIiwic21vb3RoU2Nyb2xsIiwidGhyZXNob2xkIiwiRGVmYXVsdFR5cGUkMSIsIlNjcm9sbFNweSIsIl90YXJnZXRMaW5rcyIsIl9vYnNlcnZhYmxlU2VjdGlvbnMiLCJfcm9vdEVsZW1lbnQiLCJfYWN0aXZlVGFyZ2V0IiwiX29ic2VydmVyIiwiX3ByZXZpb3VzU2Nyb2xsRGF0YSIsInZpc2libGVFbnRyeVRvcCIsInBhcmVudFNjcm9sbFRvcCIsInJlZnJlc2giLCJfaW5pdGlhbGl6ZVRhcmdldHNBbmRPYnNlcnZhYmxlcyIsIl9tYXliZUVuYWJsZVNtb290aFNjcm9sbCIsImRpc2Nvbm5lY3QiLCJfZ2V0TmV3T2JzZXJ2ZXIiLCJzZWN0aW9uIiwib2JzZXJ2ZSIsIm9ic2VydmFibGVTZWN0aW9uIiwic2Nyb2xsVG8iLCJiZWhhdmlvciIsIkludGVyc2VjdGlvbk9ic2VydmVyIiwiX29ic2VydmVyQ2FsbGJhY2siLCJ0YXJnZXRFbGVtZW50IiwiX3Byb2Nlc3MiLCJ1c2VyU2Nyb2xsc0Rvd24iLCJpc0ludGVyc2VjdGluZyIsIl9jbGVhckFjdGl2ZUNsYXNzIiwiZW50cnlJc0xvd2VyVGhhblByZXZpb3VzIiwidGFyZ2V0TGlua3MiLCJhbmNob3IiLCJkZWNvZGVVUkkiLCJfYWN0aXZhdGVQYXJlbnRzIiwibGlzdEdyb3VwIiwiYWN0aXZlTm9kZXMiLCJzcHkiLCJOQU1FJDEiLCJEQVRBX0tFWSQxIiwiRVZFTlRfS0VZJDEiLCJFVkVOVF9ISURFJDEiLCJFVkVOVF9ISURERU4kMSIsIkVWRU5UX1NIT1ckMSIsIkVWRU5UX1NIT1dOJDEiLCJFVkVOVF9DTElDS19EQVRBX0FQSSIsIkVWRU5UX0tFWURPV04iLCJFVkVOVF9MT0FEX0RBVEFfQVBJIiwiQVJST1dfTEVGVF9LRVkiLCJBUlJPV19SSUdIVF9LRVkiLCJBUlJPV19VUF9LRVkiLCJBUlJPV19ET1dOX0tFWSIsIkhPTUVfS0VZIiwiRU5EX0tFWSIsIkNMQVNTX05BTUVfQUNUSVZFIiwiQ0xBU1NfTkFNRV9GQURFJDEiLCJDTEFTU19OQU1FX1NIT1ckMSIsIkNMQVNTX0RST1BET1dOIiwiU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFIiwiU0VMRUNUT1JfRFJPUERPV05fTUVOVSIsIk5PVF9TRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEUiLCJTRUxFQ1RPUl9UQUJfUEFORUwiLCJTRUxFQ1RPUl9PVVRFUiIsIlNFTEVDVE9SX0lOTkVSIiwiU0VMRUNUT1JfREFUQV9UT0dHTEUiLCJTRUxFQ1RPUl9JTk5FUl9FTEVNIiwiU0VMRUNUT1JfREFUQV9UT0dHTEVfQUNUSVZFIiwiVGFiIiwiX3NldEluaXRpYWxBdHRyaWJ1dGVzIiwiX2dldENoaWxkcmVuIiwiaW5uZXJFbGVtIiwiX2VsZW1Jc0FjdGl2ZSIsImFjdGl2ZSIsIl9nZXRBY3RpdmVFbGVtIiwiX2RlYWN0aXZhdGUiLCJfYWN0aXZhdGUiLCJyZWxhdGVkRWxlbSIsIl90b2dnbGVEcm9wRG93biIsIm5leHRBY3RpdmVFbGVtZW50IiwicHJldmVudFNjcm9sbCIsIl9zZXRBdHRyaWJ1dGVJZk5vdEV4aXN0cyIsIl9zZXRJbml0aWFsQXR0cmlidXRlc09uQ2hpbGQiLCJfZ2V0SW5uZXJFbGVtZW50IiwiaXNBY3RpdmUiLCJvdXRlckVsZW0iLCJfZ2V0T3V0ZXJFbGVtZW50IiwiX3NldEluaXRpYWxBdHRyaWJ1dGVzT25UYXJnZXRQYW5lbCIsIm9wZW4iLCJFVkVOVF9NT1VTRU9WRVIiLCJFVkVOVF9NT1VTRU9VVCIsIkVWRU5UX0ZPQ1VTSU4iLCJFVkVOVF9GT0NVU09VVCIsIkVWRU5UX0hJREUiLCJFVkVOVF9ISURERU4iLCJFVkVOVF9TSE9XIiwiRVZFTlRfU0hPV04iLCJDTEFTU19OQU1FX0ZBREUiLCJDTEFTU19OQU1FX0hJREUiLCJDTEFTU19OQU1FX1NIT1ciLCJDTEFTU19OQU1FX1NIT1dJTkciLCJhdXRvaGlkZSIsIlRvYXN0IiwiX2hhc01vdXNlSW50ZXJhY3Rpb24iLCJfaGFzS2V5Ym9hcmRJbnRlcmFjdGlvbiIsIl9jbGVhclRpbWVvdXQiLCJfbWF5YmVTY2hlZHVsZUhpZGUiLCJpc1Nob3duIiwiX29uSW50ZXJhY3Rpb24iLCJpc0ludGVyYWN0aW5nIiwiaW5kZXhfdW1kIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/bootstrap@5.3.3_@popperjs+core@2.11.8/node_modules/bootstrap/dist/js/bootstrap.bundle.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/.pnpm/bootstrap@5.3.3_@popperjs+core@2.11.8/node_modules/bootstrap/dist/css/bootstrap.min.css":
/*!********************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/bootstrap@5.3.3_@popperjs+core@2.11.8/node_modules/bootstrap/dist/css/bootstrap.min.css ***!
  \********************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (\"c5ac1dee961c\");\nif (false) {}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vYm9vdHN0cmFwQDUuMy4zX0Bwb3BwZXJqcytjb3JlQDIuMTEuOC9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL2Rpc3QvY3NzL2Jvb3RzdHJhcC5taW4uY3NzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxpRUFBZSxjQUFjO0FBQzdCLElBQUksS0FBVSxFQUFFLEVBQXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmF2YmFyLy4vbm9kZV9tb2R1bGVzLy5wbnBtL2Jvb3RzdHJhcEA1LjMuM19AcG9wcGVyanMrY29yZUAyLjExLjgvbm9kZV9tb2R1bGVzL2Jvb3RzdHJhcC9kaXN0L2Nzcy9ib290c3RyYXAubWluLmNzcz9kNGQ0Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBkZWZhdWx0IFwiYzVhYzFkZWU5NjFjXCJcbmlmIChtb2R1bGUuaG90KSB7IG1vZHVsZS5ob3QuYWNjZXB0KCkgfVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/bootstrap@5.3.3_@popperjs+core@2.11.8/node_modules/bootstrap/dist/css/bootstrap.min.css\n");

/***/ })

};
;